(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){ var Client = require('./lib'); module.exports = Client; // Errors thrown by the library Client.errors = require('./lib/errors'); },{"./lib":10,"./lib/errors":8}],2:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var $ = require('preconditions').singleton(); var util = require('util'); var async = require('async'); var events = require('events'); var Digibyte = require('digibyte'); var Mnemonic = require('digibytejs-mnemonic'); var sjcl = require('sjcl'); var url = require('url'); var querystring = require('querystring'); var Stringify = require('json-stable-stringify'); var request = require('superagent'); var Common = require('./common'); var Constants = Common.Constants; var Defaults = Common.Defaults; var Utils = Common.Utils; var PayPro = require('./paypro'); var log = require('./log'); var Credentials = require('./credentials'); var Verifier = require('./verifier'); var Package = require('../package.json'); var Errors = require('./errors'); var BASE_URL = 'http://localhost:3232/bws/api'; /** * @desc ClientAPI constructor. * * @param {Object} opts * @constructor */ function API(opts) { opts = opts || {}; this.request = opts.request || request; this.baseUrl = opts.baseUrl || BASE_URL; this.payProHttp = null; // Only for testing this.doNotVerifyPayPro = opts.doNotVerifyPayPro; this.timeout = opts.timeout || 50000; this.logLevel = opts.logLevel || 'silent'; this.supportStaffWalletId = opts.supportStaffWalletId; log.setLevel(this.logLevel); }; util.inherits(API, events.EventEmitter); API.privateKeyEncryptionOpts = { iter: 10000 }; API.prototype.initNotifications = function(cb) { log.warn('DEPRECATED: use initialize() instead.'); this.initialize({}, cb); }; API.prototype.initialize = function(opts, cb) { $.checkState(this.credentials); var self = this; self.notificationIncludeOwn = !!opts.notificationIncludeOwn; self._initNotifications(opts); return cb(); }; API.prototype.dispose = function(cb) { var self = this; self._disposeNotifications(); self._logout(cb); }; API.prototype._fetchLatestNotifications = function(interval, cb) { var self = this; cb = cb || function() {}; var opts = { lastNotificationId: self.lastNotificationId, includeOwn: self.notificationIncludeOwn, }; if (!self.lastNotificationId) { opts.timeSpan = interval + 1; } self.getNotifications(opts, function(err, notifications) { if (err) { log.warn('Error receiving notifications.'); log.debug(err); return cb(err); } if (notifications.length > 0) { self.lastNotificationId = _.last(notifications).id; } _.each(notifications, function(notification) { self.emit('notification', notification); }); return cb(); }); }; API.prototype._initNotifications = function(opts) { var self = this; opts = opts || {}; var interval = opts.notificationIntervalSeconds || 5; self.notificationsIntervalId = setInterval(function() { self._fetchLatestNotifications(interval, function(err) { if (err) { if (err instanceof Errors.NOT_FOUND || err instanceof Errors.NOT_AUTHORIZED) { self._disposeNotifications(); } } }); }, interval * 1000); }; API.prototype._disposeNotifications = function() { var self = this; if (self.notificationsIntervalId) { clearInterval(self.notificationsIntervalId); self.notificationsIntervalId = null; } }; /** * Reset notification polling with new interval * @param {Numeric} notificationIntervalSeconds - use 0 to pause notifications */ API.prototype.setNotificationsInterval = function(notificationIntervalSeconds) { var self = this; self._disposeNotifications(); if (notificationIntervalSeconds > 0) { self._initNotifications({ notificationIntervalSeconds: notificationIntervalSeconds }); } }; /** * Encrypt a message * @private * @static * @memberof Client.API * @param {String} message * @param {String} encryptingKey */ API._encryptMessage = function(message, encryptingKey) { if (!message) return null; return Utils.encryptMessage(message, encryptingKey); }; /** * Decrypt a message * @private * @static * @memberof Client.API * @param {String} message * @param {String} encryptingKey */ API._decryptMessage = function(message, encryptingKey) { if (!message) return ''; try { return Utils.decryptMessage(message, encryptingKey); } catch (ex) { return '<ECANNOTDECRYPT>'; } }; API.prototype._processTxNotes = function(notes) { var self = this; if (!notes) return; var encryptingKey = self.credentials.sharedEncryptingKey; _.each([].concat(notes), function(note) { note.encryptedBody = note.body; note.body = API._decryptMessage(note.body, encryptingKey); note.encryptedEditedByName = note.editedByName; note.editedByName = API._decryptMessage(note.editedByName, encryptingKey); }); }; /** * Decrypt text fields in transaction proposals * @private * @static * @memberof Client.API * @param {Array} txps * @param {String} encryptingKey */ API.prototype._processTxps = function(txps) { var self = this; if (!txps) return; var encryptingKey = self.credentials.sharedEncryptingKey; _.each([].concat(txps), function(txp) { txp.encryptedMessage = txp.message; txp.message = API._decryptMessage(txp.message, encryptingKey) || null; txp.creatorName = API._decryptMessage(txp.creatorName, encryptingKey); _.each(txp.actions, function(action) { action.copayerName = API._decryptMessage(action.copayerName, encryptingKey); action.comment = API._decryptMessage(action.comment, encryptingKey); // TODO get copayerName from Credentials -> copayerId to copayerName // action.copayerName = null; }); _.each(txp.outputs, function(output) { output.encryptedMessage = output.message; output.message = API._decryptMessage(output.message, encryptingKey) || null; }); txp.hasUnconfirmedInputs = _.some(txp.inputs, function(input) { return input.confirmations == 0; }); self._processTxNotes(txp.note); }); }; /** * Parse errors * @private * @static * @memberof Client.API * @param {Object} body */ API._parseError = function(body) { if (!body) return; if (_.isString(body)) { try { body = JSON.parse(body); } catch (e) { body = { error: body }; } } var ret; if (body.code) { if (Errors[body.code]) { ret = new Errors[body.code]; if (body.message) ret.message = body.message; } else { ret = new Error(body.code + ': ' + body.message); } } else { ret = new Error(body.error || JSON.stringify(body)); } log.error(ret); return ret; }; /** * Sign an HTTP request * @private * @static * @memberof Client.API * @param {String} method - The HTTP method * @param {String} url - The URL for the request * @param {Object} args - The arguments in case this is a POST/PUT request * @param {String} privKey - Private key to sign the request */ API._signRequest = function(method, url, args, privKey) { var message = [method.toLowerCase(), url, JSON.stringify(args)].join('|'); return Utils.signMessage(message, privKey); }; /** * Seed from random * * @param {Object} opts * @param {String} opts.network - default 'livenet' */ API.prototype.seedFromRandom = function(opts) { $.checkArgument(arguments.length <= 1, 'DEPRECATED: only 1 argument accepted.'); $.checkArgument(_.isUndefined(opts) || _.isObject(opts), 'DEPRECATED: argument should be an options object.'); opts = opts || {}; this.credentials = Credentials.create(opts.network || 'livenet'); }; var _deviceValidated; /** * Seed from random * * @param {Object} opts * @param {String} opts.passphrase * @param {String} opts.skipDeviceValidation */ API.prototype.validateKeyDerivation = function(opts, cb) { var self = this; opts = opts || {}; var c = self.credentials; function testMessageSigning(xpriv, xpub) { var nonHardenedPath = 'm/0/0'; var message = 'Lorem ipsum dolor sit amet, ne amet urbanitas percipitur vim, libris disputando his ne, et facer suavitate qui. Ei quidam laoreet sea. Cu pro dico aliquip gubergren, in mundi postea usu. Ad labitur posidonium interesset duo, est et doctus molestie adipiscing.'; var priv = xpriv.deriveChild(nonHardenedPath).privateKey; var signature = Utils.signMessage(message, priv); var pub = xpub.deriveChild(nonHardenedPath).publicKey; return Utils.verifyMessage(message, signature, pub); }; function testHardcodedKeys() { var words = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"; var xpriv = Mnemonic(words).toHDPrivateKey(); if (xpriv.toString() != 'xprv9s21ZrQH143K3GJpoapnV8SFfukcVBSfeCficPSGfubmSFDxo1kuHnLisriDvSnRRuL2Qrg5ggqHKNVpxR86QEC8w35uxmGoggxtQTPvfUu') return false; xpriv = xpriv.deriveChild("m/44'/0'/0'"); if (xpriv.toString() != 'xprv9xpXFhFpqdQK3TmytPBqXtGSwS3DLjojFhTGht8gwAAii8py5X6pxeBnQ6ehJiyJ6nDjWGJfZ95WxByFXVkDxHXrqu53WCRGypk2ttuqncb') return false; var xpub = Digibyte.HDPublicKey.fromString('xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj'); return testMessageSigning(xpriv, xpub); }; function testLiveKeys() { var words; try { words = c.getMnemonic(); } catch (ex) {} var xpriv; if (words && (!c.mnemonicHasPassphrase || opts.passphrase)) { var m = new Mnemonic(words); xpriv = m.toHDPrivateKey(opts.passphrase, c.network); } if (!xpriv) { xpriv = new Digibyte.HDPrivateKey(c.xPrivKey); } xpriv = xpriv.deriveChild(c.getBaseAddressDerivationPath()); var xpub = new Digibyte.HDPublicKey(c.xPubKey); return testMessageSigning(xpriv, xpub); }; var hardcodedOk = true; if (!_deviceValidated && !opts.skipDeviceValidation) { hardcodedOk = testHardcodedKeys(); _deviceValidated = true; } var liveOk = (c.canSign() && !c.isPrivKeyEncrypted()) ? testLiveKeys() : true; self.keyDerivationOk = hardcodedOk && liveOk; return cb(null, self.keyDerivationOk); }; var _deviceValidated; /** * Seed from random * * @param {Object} opts * @param {String} opts.passphrase * @param {String} opts.skipDeviceValidation */ API.prototype.validateKeyDerivation = function(opts, cb) { var self = this; opts = opts || {}; var c = self.credentials; function testMessageSigning(xpriv, xpub) { var nonHardenedPath = 'm/0/0'; var message = 'Lorem ipsum dolor sit amet, ne amet urbanitas percipitur vim, libris disputando his ne, et facer suavitate qui. Ei quidam laoreet sea. Cu pro dico aliquip gubergren, in mundi postea usu. Ad labitur posidonium interesset duo, est et doctus molestie adipiscing.'; var priv = xpriv.deriveChild(nonHardenedPath).privateKey; var signature = Utils.signMessage(message, priv); var pub = xpub.deriveChild(nonHardenedPath).publicKey; return Utils.verifyMessage(message, signature, pub); }; function testHardcodedKeys() { var words = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"; var xpriv = Mnemonic(words).toHDPrivateKey(); if (xpriv.toString() != 'xprv9s21ZrQH143K3GJpoapnV8SFfukcVBSfeCficPSGfubmSFDxo1kuHnLisriDvSnRRuL2Qrg5ggqHKNVpxR86QEC8w35uxmGoggxtQTPvfUu') return false; xpriv = xpriv.deriveChild("m/44'/0'/0'"); if (xpriv.toString() != 'xprv9xpXFhFpqdQK3TmytPBqXtGSwS3DLjojFhTGht8gwAAii8py5X6pxeBnQ6ehJiyJ6nDjWGJfZ95WxByFXVkDxHXrqu53WCRGypk2ttuqncb') return false; var xpub = Digibyte.HDPublicKey.fromString('xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj'); return testMessageSigning(xpriv, xpub); }; function testLiveKeys() { var words; try { words = c.getMnemonic(); } catch (ex) {} var xpriv; if (words && (!c.mnemonicHasPassphrase || opts.passphrase)) { var m = new Mnemonic(words); xpriv = m.toHDPrivateKey(opts.passphrase, c.network); } if (!xpriv) { xpriv = new Digibyte.HDPrivateKey(c.xPrivKey); } xpriv = xpriv.deriveChild(c.getBaseAddressDerivationPath()); var xpub = new Digibyte.HDPublicKey(c.xPubKey); return testMessageSigning(xpriv, xpub); }; var hardcodedOk = true; if (!_deviceValidated && !opts.skipDeviceValidation) { hardcodedOk = testHardcodedKeys(); _deviceValidated = true; } var liveOk = (c.canSign() && !c.isPrivKeyEncrypted()) ? testLiveKeys() : true; self.keyDerivationOk = hardcodedOk && liveOk; return cb(null, self.keyDerivationOk); }; /** * Seed from random with mnemonic * * @param {Object} opts * @param {String} opts.network - default 'livenet' * @param {String} opts.passphrase * @param {Number} opts.language - default 'en' * @param {Number} opts.account - default 0 */ API.prototype.seedFromRandomWithMnemonic = function(opts) { $.checkArgument(arguments.length <= 1, 'DEPRECATED: only 1 argument accepted.'); $.checkArgument(_.isUndefined(opts) || _.isObject(opts), 'DEPRECATED: argument should be an options object.'); opts = opts || {}; this.credentials = Credentials.createWithMnemonic(opts.network || 'livenet', opts.passphrase, opts.language || 'en', opts.account || 0); }; API.prototype.getMnemonic = function() { return this.credentials.getMnemonic(); }; API.prototype.mnemonicHasPassphrase = function() { return this.credentials.mnemonicHasPassphrase; }; API.prototype.clearMnemonic = function() { return this.credentials.clearMnemonic(); }; /** * Seed from extended private key * * @param {String} xPrivKey * @param {Number} opts.account - default 0 * @param {String} opts.derivationStrategy - default 'BIP44' */ API.prototype.seedFromExtendedPrivateKey = function(xPrivKey, opts) { opts = opts || {}; this.credentials = Credentials.fromExtendedPrivateKey(xPrivKey, opts.account || 0, opts.derivationStrategy || Constants.DERIVATION_STRATEGIES.BIP44, opts); }; /** * Seed from Mnemonics (language autodetected) * Can throw an error if mnemonic is invalid * * @param {String} BIP39 words * @param {Object} opts * @param {String} opts.network - default 'livenet' * @param {String} opts.passphrase * @param {Number} opts.account - default 0 * @param {String} opts.derivationStrategy - default 'BIP44' */ API.prototype.seedFromMnemonic = function(words, opts) { $.checkArgument(_.isUndefined(opts) || _.isObject(opts), 'DEPRECATED: second argument should be an options object.'); opts = opts || {}; this.credentials = Credentials.fromMnemonic(opts.network || 'livenet', words, opts.passphrase, opts.account || 0, opts.derivationStrategy || Constants.DERIVATION_STRATEGIES.BIP44, opts); }; /** * Seed from external wallet public key * * @param {String} xPubKey * @param {String} source - A name identifying the source of the xPrivKey (e.g. ledger, TREZOR, ...) * @param {String} entropySourceHex - A HEX string containing pseudo-random data, that can be deterministically derived from the xPrivKey, and should not be derived from xPubKey. * @param {Object} opts * @param {Number} opts.account - default 0 * @param {String} opts.derivationStrategy - default 'BIP44' */ API.prototype.seedFromExtendedPublicKey = function(xPubKey, source, entropySourceHex, opts) { $.checkArgument(_.isUndefined(opts) || _.isObject(opts)); opts = opts || {}; this.credentials = Credentials.fromExtendedPublicKey(xPubKey, source, entropySourceHex, opts.account || 0, opts.derivationStrategy || Constants.DERIVATION_STRATEGIES.BIP44); }; /** * Export wallet * * @param {Object} opts * @param {Boolean} opts.password * @param {Boolean} opts.noSign */ API.prototype.export = function(opts) { $.checkState(this.credentials); opts = opts || {}; var output; var c = Credentials.fromObj(this.credentials); if (opts.noSign) { c.setNoSign(); } else if (opts.password) { c.decryptPrivateKey(opts.password); } output = JSON.stringify(c.toObj()); return output; }; /** * Import wallet * * @param {Object} str - The serialized JSON created with #export */ API.prototype.import = function(str) { try { var credentials = Credentials.fromObj(JSON.parse(str)); this.credentials = credentials; } catch (ex) { throw new Errors.INVALID_BACKUP; } }; API.prototype._import = function(cb) { $.checkState(this.credentials); var self = this; // First option, grab wallet info from BWS. self.openWallet(function(err, ret) { // it worked? if (!err) return cb(null, ret); // Is the error other than "copayer was not found"? || or no priv key. if (err instanceof Errors.NOT_AUTHORIZED || self.isPrivKeyExternal()) return cb(err); //Second option, lets try to add an access log.info('Copayer not found, trying to add access'); self.addAccess({}, function(err) { if (err) { return cb(new Errors.WALLET_DOES_NOT_EXIST); } self.openWallet(cb); }); }); }; /** * Import from Mnemonics (language autodetected) * Can throw an error if mnemonic is invalid * * @param {String} BIP39 words * @param {Object} opts * @param {String} opts.network - default 'livenet' * @param {String} opts.passphrase * @param {Number} opts.account - default 0 * @param {String} opts.derivationStrategy - default 'BIP44' * @param {String} opts.entropySourcePath - Only used if the wallet was created on a HW wallet, in which that private keys was not available for all the needed derivations * @param {String} opts.walletPrivKey - if available, walletPrivKey for encrypting metadata */ API.prototype.importFromMnemonic = function(words, opts, cb) { log.debug('Importing from 12 Words'); var self = this; opts = opts || {}; function derive(nonCompliantDerivation) { return Credentials.fromMnemonic(opts.network || 'livenet', words, opts.passphrase, opts.account || 0, opts.derivationStrategy || Constants.DERIVATION_STRATEGIES.BIP44, { nonCompliantDerivation: nonCompliantDerivation, entropySourcePath: opts.entropySourcePath, walletPrivKey: opts.walletPrivKey, }); }; try { self.credentials = derive(false); } catch (e) { log.info('Mnemonic error:', e); return cb(new Errors.INVALID_BACKUP); } self._import(function(err, ret) { if (!err) return cb(null, ret); if (err instanceof Errors.INVALID_BACKUP) return cb(err); if (err instanceof Errors.NOT_AUTHORIZED || err instanceof Errors.WALLET_DOES_NOT_EXIST) { var altCredentials = derive(true); if (altCredentials.xPubKey.toString() == self.credentials.xPubKey.toString()) return cb(err); self.credentials = altCredentials; return self._import(cb); } return cb(err); }); }; /* * Import from extended private key * * @param {String} xPrivKey * @param {Number} opts.account - default 0 * @param {String} opts.derivationStrategy - default 'BIP44' * @param {String} opts.compliantDerivation - default 'true' * @param {String} opts.walletPrivKey - if available, walletPrivKey for encrypting metadata * @param {Callback} cb - The callback that handles the response. It returns a flag indicating that the wallet is imported. */ API.prototype.importFromExtendedPrivateKey = function(xPrivKey, opts, cb) { log.debug('Importing from Extended Private Key'); if (!cb) { cb = opts; opts = {}; log.warn('DEPRECATED WARN: importFromExtendedPrivateKey should receive 3 parameters.'); } try { this.credentials = Credentials.fromExtendedPrivateKey(xPrivKey, opts.account || 0, opts.derivationStrategy || Constants.DERIVATION_STRATEGIES.BIP44, opts); } catch (e) { log.info('xPriv error:', e); return cb(new Errors.INVALID_BACKUP); }; this._import(cb); }; /** * Import from Extended Public Key * * @param {String} xPubKey * @param {String} source - A name identifying the source of the xPrivKey * @param {String} entropySourceHex - A HEX string containing pseudo-random data, that can be deterministically derived from the xPrivKey, and should not be derived from xPubKey. * @param {Object} opts * @param {Number} opts.account - default 0 * @param {String} opts.derivationStrategy - default 'BIP44' * @param {String} opts.compliantDerivation - default 'true' */ API.prototype.importFromExtendedPublicKey = function(xPubKey, source, entropySourceHex, opts, cb) { $.checkArgument(arguments.length == 5, "DEPRECATED: should receive 5 arguments"); $.checkArgument(_.isUndefined(opts) || _.isObject(opts)); $.shouldBeFunction(cb); opts = opts || {}; log.debug('Importing from Extended Private Key'); try { this.credentials = Credentials.fromExtendedPublicKey(xPubKey, source, entropySourceHex, opts.account || 0, opts.derivationStrategy || Constants.DERIVATION_STRATEGIES.BIP44, opts); } catch (e) { log.info('xPriv error:', e); return cb(new Errors.INVALID_BACKUP); }; this._import(cb); }; API.prototype.decryptBIP38PrivateKey = function(encryptedPrivateKeyBase58, passphrase, opts, cb) { var Bip38 = require('bip38'); var bip38 = new Bip38(); var privateKeyWif; try { privateKeyWif = bip38.decrypt(encryptedPrivateKeyBase58, passphrase); } catch (ex) { return cb(new Error('Could not decrypt BIP38 private key', ex)); } var privateKey = new Digibyte.PrivateKey(privateKeyWif); var address = privateKey.publicKey.toAddress().toString(); var addrBuff = new Buffer(address, 'ascii'); var actualChecksum = Digibyte.crypto.Hash.sha256sha256(addrBuff).toString('hex').substring(0, 8); var expectedChecksum = Digibyte.encoding.Base58Check.decode(encryptedPrivateKeyBase58).toString('hex').substring(6, 14); if (actualChecksum != expectedChecksum) return cb(new Error('Incorrect passphrase')); return cb(null, privateKeyWif); }; API.prototype.getBalanceFromPrivateKey = function(privateKey, cb) { var self = this; var privateKey = new Digibyte.PrivateKey(privateKey); var address = privateKey.publicKey.toAddress(); self.getUtxos({ addresses: address.toString(), }, function(err, utxos) { if (err) return cb(err); return cb(null, _.sumBy(utxos, 'satoshis')); }); }; API.prototype.buildTxFromPrivateKey = function(privateKey, destinationAddress, opts, cb) { var self = this; opts = opts || {}; var privateKey = Digibyte.PrivateKey(privateKey); var address = privateKey.publicKey.toAddress(); async.waterfall([ function(next) { self.getUtxos({ addresses: address.toString(), }, function(err, utxos) { return next(err, utxos); }); }, function(utxos, next) { if (!_.isArray(utxos) || utxos.length == 0) return next(new Error('No utxos found')); var fee = opts.fee || 10000; var amount = _.sumBy(utxos, 'satoshis') - fee; if (amount <= 0) return next(new Errors.INSUFFICIENT_FUNDS); var tx; try { var toAddress = Digibyte.Address.fromString(destinationAddress); tx = new Digibyte.Transaction() .from(utxos) .to(toAddress, amount) .fee(fee) .sign(privateKey); // Make sure the tx can be serialized tx.serialize(); } catch (ex) { log.error('Could not build transaction from private key', ex); return next(new Errors.COULD_NOT_BUILD_TRANSACTION); } return next(null, tx); } ], cb); }; /** * Open a wallet and try to complete the public key ring. * * @param {Callback} cb - The callback that handles the response. It returns a flag indicating that the wallet is complete. * @fires API#walletCompleted */ API.prototype.openWallet = function(cb) { $.checkState(this.credentials); var self = this; if (self.credentials.isComplete() && self.credentials.hasWalletInfo()) return cb(null, true); self._doGetRequest('/v2/wallets/?includeExtendedInfo=1', function(err, ret) { if (err) return cb(err); var wallet = ret.wallet; self._processStatus(ret); if (!self.credentials.hasWalletInfo()) { var me = _.find(wallet.copayers, { id: self.credentials.copayerId }); self.credentials.addWalletInfo(wallet.id, wallet.name, wallet.m, wallet.n, me.name); } if (wallet.status != 'complete') return cb(); if (self.credentials.walletPrivKey) { if (!Verifier.checkCopayers(self.credentials, wallet.copayers)) { return cb(new Errors.SERVER_COMPROMISED); } } else { // this should only happen in AIR-GAPPED flows log.warn('Could not verify copayers key (missing wallet Private Key)'); } self.credentials.addPublicKeyRing(API._extractPublicKeyRing(wallet.copayers)); self.emit('walletCompleted', wallet); return cb(null, ret); }); }; API.prototype._getHeaders = function(method, url, args) { var headers = { 'x-client-version': 'bwc-' + Package.version, }; if (this.supportStaffWalletId) { headers['x-wallet-id'] = this.supportStaffWalletId; } return headers; }; /** * Do an HTTP request * @private * * @param {Object} method * @param {String} url * @param {Object} args * @param {Callback} cb */ API.prototype._doRequest = function(method, url, args, useSession, cb) { var self = this; var headers = self._getHeaders(method, url, args); if (self.credentials) { headers['x-identity'] = self.credentials.copayerId; if (useSession && self.session) { headers['x-session'] = self.session; } else { var reqSignature; var key = args._requestPrivKey || self.credentials.requestPrivKey; if (key) { delete args['_requestPrivKey']; reqSignature = API._signRequest(method, url, args, key); } headers['x-signature'] = reqSignature; } } var r = self.request[method](self.baseUrl + url); r.accept('json'); _.each(headers, function(v, k) { if (v) r.set(k, v); }); if (args) { if (method == 'post' || method == 'put') { r.send(args); } else { r.query(args); } } r.timeout(self.timeout); r.end(function(err, res) { if (!res) { return cb(new Errors.CONNECTION_ERROR); } if (res.body) log.debug(util.inspect(res.body, { depth: 10 })); if (res.status !== 200) { if (res.status === 404) return cb(new Errors.NOT_FOUND); if (!res.status) return cb(new Errors.CONNECTION_ERROR); log.error('HTTP Error:' + res.status); if (!res.body) return cb(new Error(res.status)); return cb(API._parseError(res.body)); } if (res.body === '{"error":"read ECONNRESET"}') return cb(new Errors.ECONNRESET_ERROR(JSON.parse(res.body))); return cb(null, res.body, res.header); }); }; API.prototype._login = function(cb) { this._doPostRequest('/v1/login', {}, cb); }; API.prototype._logout = function(cb) { this._doPostRequest('/v1/logout', {}, cb); }; /** * Do an HTTP request * @private * * @param {Object} method * @param {String} url * @param {Object} args * @param {Callback} cb */ API.prototype._doRequestWithLogin = function(method, url, args, cb) { var self = this; function doLogin(cb) { self._login(function(err, s) { if (err) return cb(err); if (!s) return cb(new Errors.NOT_AUTHORIZED); self.session = s; cb(); }); }; async.waterfall([ function(next) { if (self.session) return next(); doLogin(next); }, function(next) { self._doRequest(method, url, args, true, function(err, body, header) { if (err && err instanceof Errors.NOT_AUTHORIZED) { doLogin(function(err) { if (err) return next(err); return self._doRequest(method, url, args, true, next); }); } next(null, body, header); }); }, ], cb); }; /** * Do a POST request * @private * * @param {String} url * @param {Object} args * @param {Callback} cb */ API.prototype._doPostRequest = function(url, args, cb) { return this._doRequest('post', url, args, false, cb); }; API.prototype._doPutRequest = function(url, args, cb) { return this._doRequest('put', url, args, false, cb); }; /** * Do a GET request * @private * * @param {String} url * @param {Callback} cb */ API.prototype._doGetRequest = function(url, cb) { url += url.indexOf('?') > 0 ? '&' : '?'; url += 'r=' + _.random(10000, 99999); return this._doRequest('get', url, {}, false, cb); }; API.prototype._doGetRequestWithLogin = function(url, cb) { url += url.indexOf('?') > 0 ? '&' : '?'; url += 'r=' + _.random(10000, 99999); return this._doRequestWithLogin('get', url, {}, cb); }; /** * Do a DELETE request * @private * * @param {String} url * @param {Callback} cb */ API.prototype._doDeleteRequest = function(url, cb) { return this._doRequest('delete', url, {}, false, cb); }; API._buildSecret = function(walletId, walletPrivKey, network) { if (_.isString(walletPrivKey)) { walletPrivKey = Digibyte.PrivateKey.fromString(walletPrivKey); } var widHex = new Buffer(walletId.replace(/-/g, ''), 'hex'); var widBase58 = new Digibyte.encoding.Base58(widHex).toString(); return _.padEnd(widBase58, 22, '0') + walletPrivKey.toWIF() + (network == 'testnet' ? 'T' : 'L'); }; API.parseSecret = function(secret) { $.checkArgument(secret); function split(str, indexes) { var parts = []; indexes.push(str.length); var i = 0; while (i < indexes.length) { parts.push(str.substring(i == 0 ? 0 : indexes[i - 1], indexes[i])); i++; }; return parts; }; try { var secretSplit = split(secret, [22, 74, 75]); var widBase58 = secretSplit[0].replace(/0/g, ''); var widHex = Digibyte.encoding.Base58.decode(widBase58).toString('hex'); var walletId = split(widHex, [8, 12, 16, 20]).join('-'); var walletPrivKey = Digibyte.PrivateKey.fromString(secretSplit[1]); var networkChar = secretSplit[2]; return { walletId: walletId, walletPrivKey: walletPrivKey, network: networkChar == 'T' ? 'testnet' : 'livenet', }; } catch (ex) { throw new Error('Invalid secret'); } }; API.getRawTx = function(txp) { var t = Utils.buildTx(txp); return t.uncheckedSerialize(); }; API.signTxp = function(txp, derivedXPrivKey) { //Derive proper key to sign, for each input var privs = []; var derived = {}; var xpriv = new Digibyte.HDPrivateKey(derivedXPrivKey); _.each(txp.inputs, function(i) { $.checkState(i.path, "Input derivation path not available (signing transaction)") if (!derived[i.path]) { derived[i.path] = xpriv.deriveChild(i.path).privateKey; privs.push(derived[i.path]); } }); var t = Utils.buildTx(txp); var signatures = _.map(privs, function(priv, i) { return t.getSignatures(priv); }); signatures = _.map(_.sortBy(_.flatten(signatures), 'inputIndex'), function(s) { return s.signature.toDER().toString('hex'); }); return signatures; }; API.prototype._signTxp = function(txp, password) { var derived = this.credentials.getDerivedXPrivKey(password); return API.signTxp(txp, derived); }; API.prototype._getCurrentSignatures = function(txp) { var acceptedActions = _.filter(txp.actions, { type: 'accept' }); return _.map(acceptedActions, function(x) { return { signatures: x.signatures, xpub: x.xpub, }; }); }; API.prototype._addSignaturesToBitcoreTx = function(txp, t, signatures, xpub) { if (signatures.length != txp.inputs.length) throw new Error('Number of signatures does not match number of inputs'); var i = 0, x = new Digibyte.HDPublicKey(xpub); _.each(signatures, function(signatureHex) { var input = txp.inputs[i]; try { var signature = Digibyte.crypto.Signature.fromString(signatureHex); var pub = x.deriveChild(txp.inputPaths[i]).publicKey; var s = { inputIndex: i, signature: signature, sigtype: Digibyte.crypto.Signature.SIGHASH_ALL | Digibyte.crypto.Signature.SIGHASH_FORKID, publicKey: pub, } ; t.inputs[i].addSignature(t, s); i++; } catch (e) {} ; }); if (i != txp.inputs.length) throw new Error('Wrong signatures'); }; API.prototype._applyAllSignatures = function(txp, t) { var self = this; $.checkState(txp.status == 'accepted'); var sigs = self._getCurrentSignatures(txp); _.each(sigs, function(x) { self._addSignaturesToBitcoreTx(txp, t, x.signatures, x.xpub); }); }; /** * Join * @private * * @param {String} walletId * @param {String} walletPrivKey * @param {String} xPubKey * @param {String} requestPubKey * @param {String} copayerName * @param {Object} Optional args * @param {String} opts.customData * @param {Callback} cb */ API.prototype._doJoinWallet = function(walletId, walletPrivKey, xPubKey, requestPubKey, copayerName, opts, cb) { $.shouldBeFunction(cb); var self = this; opts = opts || {}; // Adds encrypted walletPrivateKey to CustomData opts.customData = opts.customData || {}; opts.customData.walletPrivKey = walletPrivKey.toString(); var encCustomData = Utils.encryptMessage(JSON.stringify(opts.customData), this.credentials.personalEncryptingKey); var encCopayerName = Utils.encryptMessage(copayerName, this.credentials.sharedEncryptingKey); var args = { walletId: walletId, name: encCopayerName, xPubKey: xPubKey, requestPubKey: requestPubKey, customData: encCustomData, }; if (opts.dryRun) args.dryRun = true; if (_.isBoolean(opts.supportBIP44AndP2PKH)) args.supportBIP44AndP2PKH = opts.supportBIP44AndP2PKH; var hash = Utils.getCopayerHash(args.name, args.xPubKey, args.requestPubKey); args.copayerSignature = Utils.signMessage(hash, walletPrivKey); var url = '/v2/wallets/' + walletId + '/copayers'; this._doPostRequest(url, args, function(err, body) { if (err) return cb(err); self._processWallet(body.wallet); return cb(null, body.wallet); }); }; /** * Return if wallet is complete */ API.prototype.isComplete = function() { return this.credentials && this.credentials.isComplete(); }; /** * Is private key currently encrypted? * * @return {Boolean} */ API.prototype.isPrivKeyEncrypted = function() { return this.credentials && this.credentials.isPrivKeyEncrypted(); }; /** * Is private key external? * * @return {Boolean} */ API.prototype.isPrivKeyExternal = function() { return this.credentials && this.credentials.hasExternalSource(); }; /** * Get external wallet source name * * @return {String} */ API.prototype.getPrivKeyExternalSourceName = function() { return this.credentials ? this.credentials.getExternalSourceName() : null; }; /** * Returns unencrypted extended private key and mnemonics * * @param password */ API.prototype.getKeys = function(password) { return this.credentials.getKeys(password); }; /** * Checks is password is valid * Returns null (keys not encrypted), true or false. * * @param password */ API.prototype.checkPassword = function(password) { if (!this.isPrivKeyEncrypted()) return; try { var keys = this.getKeys(password); return !!keys.xPrivKey; } catch (e) { return false; }; }; /** * Can this credentials sign a transaction? * (Only returns fail on a 'proxy' setup for airgapped operation) * * @return {undefined} */ API.prototype.canSign = function() { return this.credentials && this.credentials.canSign(); }; API._extractPublicKeyRing = function(copayers) { return _.map(copayers, function(copayer) { var pkr = _.pick(copayer, ['xPubKey', 'requestPubKey']); pkr.copayerName = copayer.name; return pkr; }); }; /** * sets up encryption for the extended private key * * @param {String} password Password used to encrypt * @param {Object} opts optional: SJCL options to encrypt (.iter, .salt, etc). * @return {undefined} */ API.prototype.encryptPrivateKey = function(password, opts) { this.credentials.encryptPrivateKey(password, opts || API.privateKeyEncryptionOpts); }; /** * disables encryption for private key. * * @param {String} password Password used to encrypt */ API.prototype.decryptPrivateKey = function(password) { return this.credentials.decryptPrivateKey(password); }; /** * Get current fee levels for the specified network * * @param {string} network - 'livenet' (default) or 'testnet' * @param {Callback} cb * @returns {Callback} cb - Returns error or an object with status information */ API.prototype.getFeeLevels = function(network, cb) { var self = this; $.checkArgument(network || _.includes(['livenet', 'testnet'], network)); self._doGetRequest('/v2/feelevels/?network=' + (network || 'livenet'), function(err, result) { if (err) return cb(err); return cb(err, result); }); }; /** * Get service version * * @param {Callback} cb */ API.prototype.getVersion = function(cb) { this._doGetRequest('/v1/version/', cb); }; API.prototype._checkKeyDerivation = function() { var isInvalid = (this.keyDerivationOk === false); if (isInvalid) { log.error('Key derivation for this device is not working as expected'); } return !isInvalid; }; /** * * Create a wallet. * @param {String} walletName * @param {String} copayerName * @param {Number} m * @param {Number} n * @param {object} opts (optional: advanced options) * @param {string} opts.network[='livenet'] * @param {string} opts.singleAddress[=false] - The wallet will only ever have one address. * @param {String} opts.walletPrivKey - set a walletPrivKey (instead of random) * @param {String} opts.id - set a id for wallet (instead of server given) * @param cb * @return {undefined} */ API.prototype.createWallet = function(walletName, copayerName, m, n, opts, cb) { var self = this; if (!self._checkKeyDerivation()) return cb(new Error('Cannot create new wallet')); if (opts) $.shouldBeObject(opts); opts = opts || {}; var network = opts.network || 'livenet'; if (!_.includes(['testnet', 'livenet'], network)) return cb(new Error('Invalid network')); if (!self.credentials) { log.info('Generating new keys'); self.seedFromRandom({ network: network }); } else { log.info('Using existing keys'); } if (network != self.credentials.network) { return cb(new Error('Existing keys were created for a different network')); } var walletPrivKey = opts.walletPrivKey || new Digibyte.PrivateKey(); var c = self.credentials; c.addWalletPrivateKey(walletPrivKey.toString()); var encWalletName = Utils.encryptMessage(walletName, c.sharedEncryptingKey); var args = { name: encWalletName, m: m, n: n, pubKey: (new Digibyte.PrivateKey(walletPrivKey)).toPublicKey().toString(), network: network, singleAddress: !!opts.singleAddress, id: opts.id, }; self._doPostRequest('/v2/wallets/', args, function(err, res) { if (err) return cb(err); var walletId = res.walletId; c.addWalletInfo(walletId, walletName, m, n, copayerName); var secret = API._buildSecret(c.walletId, c.walletPrivKey, c.network); self._doJoinWallet(walletId, walletPrivKey, c.xPubKey, c.requestPubKey, copayerName, { }, function(err, wallet) { if (err) return cb(err); return cb(null, n > 1 ? secret : null); }); }); }; /** * Join an existent wallet * * @param {String} secret * @param {String} copayerName * @param {Object} opts * @param {Boolean} opts.dryRun[=false] - Simulate wallet join * @param {Callback} cb * @returns {Callback} cb - Returns the wallet */ API.prototype.joinWallet = function(secret, copayerName, opts, cb) { var self = this; if (!cb) { cb = opts; opts = {}; log.warn('DEPRECATED WARN: joinWallet should receive 4 parameters.'); } if (!self._checkKeyDerivation()) return cb(new Error('Cannot join wallet')); opts = opts || {}; try { var secretData = API.parseSecret(secret); } catch (ex) { return cb(ex); } if (!self.credentials) { self.seedFromRandom({ network: secretData.network }); } self.credentials.addWalletPrivateKey(secretData.walletPrivKey.toString()); self._doJoinWallet(secretData.walletId, secretData.walletPrivKey, self.credentials.xPubKey, self.credentials.requestPubKey, copayerName, { dryRun: !!opts.dryRun, }, function(err, wallet) { if (err) return cb(err); if (!opts.dryRun) { self.credentials.addWalletInfo(wallet.id, wallet.name, wallet.m, wallet.n, copayerName); } return cb(null, wallet); }); }; /** * Recreates a wallet, given credentials (with wallet id) * * @returns {Callback} cb - Returns the wallet */ API.prototype.recreateWallet = function(cb) { $.checkState(this.credentials); $.checkState(this.credentials.isComplete()); $.checkState(this.credentials.walletPrivKey); //$.checkState(this.credentials.hasWalletInfo()); var self = this; // First: Try to get the wallet with current credentials this.getStatus({ includeExtendedInfo: true }, function(err) { // No error? -> Wallet is ready. if (!err) { log.info('Wallet is already created'); return cb(); }; var c = self.credentials; var walletPrivKey = Digibyte.PrivateKey.fromString(c.walletPrivKey); var walletId = c.walletId; var supportBIP44AndP2PKH = c.derivationStrategy != Constants.DERIVATION_STRATEGIES.BIP45; var encWalletName = Utils.encryptMessage(c.walletName || 'recovered wallet', c.sharedEncryptingKey); var args = { name: encWalletName, m: c.m, n: c.n, pubKey: walletPrivKey.toPublicKey().toString(), network: c.network, id: walletId, supportBIP44AndP2PKH: supportBIP44AndP2PKH, }; self._doPostRequest('/v2/wallets/', args, function(err, body) { if (err) { if (!(err instanceof Errors.WALLET_ALREADY_EXISTS)) return cb(err); return self.addAccess({}, function(err) { if (err) return cb(err); self.openWallet(function(err) { return cb(err); }); }); } if (!walletId) { walletId = body.walletId; } var i = 1; async.each(self.credentials.publicKeyRing, function(item, next) { var name = item.copayerName || ('copayer ' + i++); self._doJoinWallet(walletId, walletPrivKey, item.xPubKey, item.requestPubKey, name, { supportBIP44AndP2PKH: supportBIP44AndP2PKH, }, function(err) { //Ignore error is copayer already in wallet if (err && err instanceof Errors.COPAYER_IN_WALLET) return next(); return next(err); }); }, cb); }); }); }; API.prototype._processWallet = function(wallet) { var self = this; var encryptingKey = self.credentials.sharedEncryptingKey; var name = Utils.decryptMessage(wallet.name, encryptingKey); if (name != wallet.name) { wallet.encryptedName = wallet.name; } wallet.name = name; _.each(wallet.copayers, function(copayer) { var name = Utils.decryptMessage(copayer.name, encryptingKey); if (name != copayer.name) { copayer.encryptedName = copayer.name; } copayer.name = name; _.each(copayer.requestPubKeys, function(access) { if (!access.name) return; var name = Utils.decryptMessage(access.name, encryptingKey); if (name != access.name) { access.encryptedName = access.name; } access.name = name; }); }); }; API.prototype._processStatus = function(status) { var self = this; function processCustomData(data) { var copayers = data.wallet.copayers; if (!copayers) return; var me = _.find(copayers, { 'id': self.credentials.copayerId }); if (!me || !me.customData) return; var customData; try { customData = JSON.parse(Utils.decryptMessage(me.customData, self.credentials.personalEncryptingKey)); } catch (e) { log.warn('Could not decrypt customData:', me.customData); } if (!customData) return; // Add it to result data.customData = customData; // Update walletPrivateKey if (!self.credentials.walletPrivKey && customData.walletPrivKey) self.credentials.addWalletPrivateKey(customData.walletPrivKey); }; processCustomData(status); self._processWallet(status.wallet); self._processTxps(status.pendingTxps); } /** * Get latest notifications * * @param {object} opts * @param {String} opts.lastNotificationId (optional) - The ID of the last received notification * @param {String} opts.timeSpan (optional) - A time window on which to look for notifications (in seconds) * @param {String} opts.includeOwn[=false] (optional) - Do not ignore notifications generated by the current copayer * @returns {Callback} cb - Returns error or an array of notifications */ API.prototype.getNotifications = function(opts, cb) { $.checkState(this.credentials); var self = this; opts = opts || {}; var url = '/v1/notifications/'; if (opts.lastNotificationId) { url += '?notificationId=' + opts.lastNotificationId; } else if (opts.timeSpan) { url += '?timeSpan=' + opts.timeSpan; } self._doGetRequestWithLogin(url, function(err, result) { if (err) return cb(err); var notifications = _.filter(result, function(notification) { return opts.includeOwn || (notification.creatorId != self.credentials.copayerId); }); return cb(null, notifications); }); }; /** * Get status of the wallet * * @param {Boolean} opts.twoStep[=false] - Optional: use 2-step balance computation for improved performance * @param {Boolean} opts.includeExtendedInfo (optional: query extended status) * @returns {Callback} cb - Returns error or an object with status information */ API.prototype.getStatus = function(opts, cb) { $.checkState(this.credentials); if (!cb) { cb = opts; opts = {}; log.warn('DEPRECATED WARN: getStatus should receive 2 parameters.') } var self = this; opts = opts || {}; var qs = []; qs.push('includeExtendedInfo=' + (opts.includeExtendedInfo ? '1' : '0')); qs.push('twoStep=' + (opts.twoStep ? '1' : '0')); self._doGetRequest('/v2/wallets/?' + qs.join('&'), function(err, result) { if (err) return cb(err); if (result.wallet.status == 'pending') { var c = self.credentials; result.wallet.secret = API._buildSecret(c.walletId, c.walletPrivKey, c.network); } self._processStatus(result); return cb(err, result); }); }; /** * Get copayer preferences * * @param {Callback} cb * @return {Callback} cb - Return error or object */ API.prototype.getPreferences = function(cb) { $.checkState(this.credentials); $.checkArgument(cb); var self = this; self._doGetRequest('/v1/preferences/', function(err, preferences) { if (err) return cb(err); return cb(null, preferences); }); }; /** * Save copayer preferences * * @param {Object} preferences * @param {Callback} cb * @return {Callback} cb - Return error or object */ API.prototype.savePreferences = function(preferences, cb) { $.checkState(this.credentials); $.checkArgument(cb); var self = this; self._doPutRequest('/v1/preferences/', preferences, cb); }; /** * fetchPayPro * * @param opts.payProUrl URL for paypro request * @returns {Callback} cb - Return error or the parsed payment protocol request * Returns (err,paypro) * paypro.amount * paypro.toAddress * paypro.memo */ API.prototype.fetchPayPro = function(opts, cb) { $.checkArgument(opts) .checkArgument(opts.payProUrl); PayPro.get({ url: opts.payProUrl, http: this.payProHttp, }, function(err, paypro) { if (err) return cb(err); return cb(null, paypro); }); }; /** * Gets list of utxos * * @param {Function} cb * @param {Object} opts * @param {Array} opts.addresses (optional) - List of addresses from where to fetch UTXOs. * @returns {Callback} cb - Return error or the list of utxos */ API.prototype.getUtxos = function(opts, cb) { $.checkState(this.credentials && this.credentials.isComplete()); opts = opts || {}; var url = '/v1/utxos/'; if (opts.addresses) { url += '?' + querystring.stringify({ addresses: [].concat(opts.addresses).join(',') }); } this._doGetRequest(url, cb); }; API.prototype._getCreateTxProposalArgs = function(opts) { var self = this; var args = _.cloneDeep(opts); args.message = API._encryptMessage(opts.message, this.credentials.sharedEncryptingKey) || null; args.payProUrl = opts.payProUrl || null; args.fee = opts.fee; _.each(args.outputs, function(o) { o.message = API._encryptMessage(o.message, self.credentials.sharedEncryptingKey) || null; }); return args; }; /** * Create a transaction proposal * * @param {Object} opts * @param {string} opts.txProposalId - Optional. If provided it will be used as this TX proposal ID. Should be unique in the scope of the wallet. * @param {Array} opts.outputs - List of outputs. * @param {string} opts.outputs[].toAddress - Destination address. * @param {number} opts.outputs[].amount - Amount to transfer in satoshi. * @param {string} opts.outputs[].message - A message to attach to this output. * @param {string} opts.message - A message to attach to this transaction. * @param {number} opts.feeLevel[='normal'] - Optional. Specify the fee level for this TX ('priority', 'normal', 'economy', 'superEconomy'). * @param {number} opts.feePerKb - Optional. Specify the fee per KB for this TX (in satoshi). * @param {string} opts.changeAddress - Optional. Use this address as the change address for the tx. The address should belong to the wallet. In the case of singleAddress wallets, the first main address will be used. * @param {Boolean} opts.sendMax - Optional. Send maximum amount of funds that make sense under the specified fee/feePerKb conditions. (defaults to false). * @param {string} opts.payProUrl - Optional. Paypro URL for peers to verify TX * @param {Boolean} opts.excludeUnconfirmedUtxos[=false] - Optional. Do not use UTXOs of unconfirmed transactions as inputs * @param {Boolean} opts.validateOutputs[=true] - Optional. Perform validation on outputs. * @param {Boolean} opts.dryRun[=false] - Optional. Simulate the action but do not change server state. * @param {Array} opts.inputs - Optional. Inputs for this TX * @param {number} opts.fee - Optional. Use an fixed fee for this TX (only when opts.inputs is specified) * @param {Boolean} opts.noShuffleOutputs - Optional. If set, TX outputs won't be shuffled. Defaults to false * @returns {Callback} cb - Return error or the transaction proposal */ API.prototype.createTxProposal = function(opts, cb) { $.checkState(this.credentials && this.credentials.isComplete()); $.checkState(this.credentials.sharedEncryptingKey); $.checkArgument(opts); var self = this; var args = self._getCreateTxProposalArgs(opts); self._doPostRequest('/v2/txproposals/', args, function(err, txp) { if (err) return cb(err); self._processTxps(txp); if (!Verifier.checkProposalCreation(args, txp, self.credentials.sharedEncryptingKey)) { return cb(new Errors.SERVER_COMPROMISED); } return cb(null, txp); }); }; /** * Publish a transaction proposal * * @param {Object} opts * @param {Object} opts.txp - The transaction proposal object returned by the API#createTxProposal method * @returns {Callback} cb - Return error or null */ API.prototype.publishTxProposal = function(opts, cb) { $.checkState(this.credentials && this.credentials.isComplete()); $.checkArgument(opts) .checkArgument(opts.txp); $.checkState(parseInt(opts.txp.version) >= 3); var self = this; var t = Utils.buildTx(opts.txp); var hash = t.uncheckedSerialize(); var args = { proposalSignature: Utils.signMessage(hash, self.credentials.requestPrivKey) }; var url = '/v1/txproposals/' + opts.txp.id + '/publish/'; self._doPostRequest(url, args, function(err, txp) { if (err) return cb(err); self._processTxps(txp); return cb(null, txp); }); }; /** * Publish a transaction proposal * * @param {Object} opts * @param {Object} opts.txp - The transaction proposal object returned by the API#createTxProposal method * @returns {Callback} cb - Return error or null */ API.prototype.publishTxProposal = function(opts, cb) { $.checkState(this.credentials && this.credentials.isComplete()); $.checkArgument(opts) .checkArgument(opts.txp); $.checkState(parseInt(opts.txp.version) >= 3); var self = this; var t = Utils.buildTx(opts.txp); var hash = t.uncheckedSerialize(); var args = { proposalSignature: Utils.signMessage(hash, self.credentials.requestPrivKey) }; var url = '/v1/txproposals/' + opts.txp.id + '/publish/'; self._doPostRequest(url, args, function(err, txp) { if (err) return cb(err); self._processTxps(txp); return cb(null, txp); }); }; /** * Create a new address * * @param {Object} opts * @param {Boolean} opts.ignoreMaxGap[=false] * @param {Callback} cb * @returns {Callback} cb - Return error or the address */ API.prototype.createAddress = function(opts, cb) { $.checkState(this.credentials && this.credentials.isComplete()); var self = this; if (!cb) { cb = opts; opts = {}; log.warn('DEPRECATED WARN: createAddress should receive 2 parameters.') } if (!self._checkKeyDerivation()) return cb(new Error('Cannot create new address for this wallet')); opts = opts || {}; self._doPostRequest('/v3/addresses/', opts, function(err, address) { if (err) return cb(err); if (!Verifier.checkAddress(self.credentials, address)) { return cb(new Errors.SERVER_COMPROMISED); } return cb(null, address); }); }; /** * Get your main addresses * * @param {Object} opts * @param {Boolean} opts.doNotVerify * @param {Numeric} opts.limit (optional) - Limit the resultset. Return all addresses by default. * @param {Boolean} [opts.reverse=false] (optional) - Reverse the order of returned addresses. * @param {Callback} cb * @returns {Callback} cb - Return error or the array of addresses */ API.prototype.getMainAddresses = function(opts, cb) { $.checkState(this.credentials && this.credentials.isComplete()); var self = this; opts = opts || {}; var args = []; if (opts.limit) args.push('limit=' + opts.limit); if (opts.reverse) args.push('reverse=1'); var qs = ''; if (args.length > 0) { qs = '?' + args.join('&'); } var url = '/v1/addresses/' + qs; self._doGetRequest(url, function(err, addresses) { if (err) return cb(err); if (!opts.doNotVerify) { var fake = _.some(addresses, function(address) { return !Verifier.checkAddress(self.credentials, address); }); if (fake) return cb(new Errors.SERVER_COMPROMISED); } return cb(null, addresses); }); }; /** * Update wallet balance * * @param {Boolean} opts.twoStep[=false] - Optional: use 2-step balance computation for improved performance * @param {Callback} cb */ API.prototype.getBalance = function(opts, cb) { if (!cb) { cb = opts; opts = {}; log.warn('DEPRECATED WARN: getBalance should receive 2 parameters.') } var self = this; opts = opts || {}; $.checkState(this.credentials && this.credentials.isComplete()); var args = []; if (opts.twoStep) args.push('?twoStep=1'); var qs = ''; if (args.length > 0) { qs = '?' + args.join('&'); } var url = '/v1/balance/' + qs; this._doGetRequest(url, cb); }; /** * Get list of transactions proposals * * @param {Object} opts * @param {Boolean} opts.doNotVerify * @param {Boolean} opts.forAirGapped * @param {Boolean} opts.doNotEncryptPkr * @return {Callback} cb - Return error or array of transactions proposals */ API.prototype.getTxProposals = function(opts, cb) { $.checkState(this.credentials && this.credentials.isComplete()); var self = this; self._doGetRequest('/v1/txproposals/', function(err, txps) { if (err) return cb(err); self._processTxps(txps); async.every(txps, function(txp, acb) { if (opts.doNotVerify) return acb(true); self.getPayPro(txp, function(err, paypro) { var isLegit = Verifier.checkTxProposal(self.credentials, txp, { paypro: paypro, }); return acb(isLegit); }); }, function(isLegit) { if (!isLegit) return cb(new Errors.SERVER_COMPROMISED); var result; if (opts.forAirGapped) { result = { txps: JSON.parse(JSON.stringify(txps)), encryptedPkr: opts.doNotEncryptPkr ? null : Utils.encryptMessage(JSON.stringify(self.credentials.publicKeyRing), self.credentials.personalEncryptingKey), unencryptedPkr: opts.doNotEncryptPkr ? JSON.stringify(self.credentials.publicKeyRing) : null, m: self.credentials.m, n: self.credentials.n, }; } else { result = txps; } return cb(null, result); }); }); }; //private? API.prototype.getPayPro = function(txp, cb) { var self = this; if (!txp.payProUrl || this.doNotVerifyPayPro) return cb(); PayPro.get({ url: txp.payProUrl, http: self.payProHttp, }, function(err, paypro) { if (err) return cb(new Error('Cannot check transaction now:' + err)); return cb(null, paypro); }); }; /** * Sign a transaction proposal * * @param {Object} txp * @param {String} password - (optional) A password to decrypt the encrypted private key (if encryption is set). * @param {Callback} cb * @return {Callback} cb - Return error or object */ API.prototype.signTxProposal = function(txp, password, cb) { $.checkState(this.credentials && this.credentials.isComplete()); $.checkArgument(txp.creatorId); if (_.isFunction(password)) { cb = password; password = null; } var self = this; if (!txp.signatures) { if (!self.canSign()) return cb(new Errors.MISSING_PRIVATE_KEY); if (self.isPrivKeyEncrypted() && !password) return cb(new Errors.ENCRYPTED_PRIVATE_KEY); } self.getPayPro(txp, function(err, paypro) { if (err) return cb(err); var isLegit = Verifier.checkTxProposal(self.credentials, txp, { paypro: paypro, }); if (!isLegit) return cb(new Errors.SERVER_COMPROMISED); var signatures = txp.signatures; if (_.isEmpty(signatures)) { try { signatures = self._signTxp(txp, password); } catch (ex) { log.error('Error signing tx', ex); return cb(ex); } } var url = '/v1/txproposals/' + txp.id + '/signatures/'; var args = { signatures: signatures }; self._doPostRequest(url, args, function(err, txp) { if (err) return cb(err); self._processTxps(txp); return cb(null, txp); }); }); }; /** * Sign transaction proposal from AirGapped * * @param {Object} txp * @param {String} encryptedPkr * @param {Number} m * @param {Number} n * @param {String} password - (optional) A password to decrypt the encrypted private key (if encryption is set). * @return {Object} txp - Return transaction */ API.prototype.signTxProposalFromAirGapped = function(txp, encryptedPkr, m, n, password) { $.checkState(this.credentials); var self = this; if (!self.canSign()) throw new Errors.MISSING_PRIVATE_KEY; if (self.isPrivKeyEncrypted() && !password) throw new Errors.ENCRYPTED_PRIVATE_KEY; var publicKeyRing; try { publicKeyRing = JSON.parse(Utils.decryptMessage(encryptedPkr, self.credentials.personalEncryptingKey)); } catch (ex) { throw new Error('Could not decrypt public key ring'); } if (!_.isArray(publicKeyRing) || publicKeyRing.length != n) { throw new Error('Invalid public key ring'); } self.credentials.m = m; self.credentials.n = n; self.credentials.addressType = txp.addressType; self.credentials.addPublicKeyRing(publicKeyRing); if (!Verifier.checkTxProposalSignature(self.credentials, txp)) throw new Error('Fake transaction proposal'); return self._signTxp(txp, password); }; /** * Sign transaction proposal from AirGapped * * @param {String} key - A mnemonic phrase or an xprv HD private key * @param {Object} txp * @param {String} unencryptedPkr * @param {Number} m * @param {Number} n * @param {Object} opts * @param {String} opts.passphrase * @param {Number} opts.account - default 0 * @param {String} opts.derivationStrategy - default 'BIP44' * @return {Object} txp - Return transaction */ API.signTxProposalFromAirGapped = function(key, txp, unencryptedPkr, m, n, opts) { var self = this; opts = opts || {} var publicKeyRing = JSON.parse(unencryptedPkr); if (!_.isArray(publicKeyRing) || publicKeyRing.length != n) { throw new Error('Invalid public key ring'); } var newClient = new API({ baseUrl: 'https://bws.example.com/bws/api' }); if (key.slice(0, 4) === 'xprv' || key.slice(0, 4) === 'tprv') { if (key.slice(0, 4) === 'xprv' && txp.network == 'testnet') throw new Error("testnet HD keys must start with tprv"); if (key.slice(0, 4) === 'tprv' && txp.network == 'livenet') throw new Error("livenet HD keys must start with xprv"); newClient.seedFromExtendedPrivateKey(key, { 'account': opts.account, 'derivationStrategy': opts.derivationStrategy }); } else { newClient.seedFromMnemonic(key, { 'network': txp.network, 'passphrase': opts.passphrase, 'account': opts.account, 'derivationStrategy': opts.derivationStrategy }) } newClient.credentials.m = m; newClient.credentials.n = n; newClient.credentials.addressType = txp.addressType; newClient.credentials.addPublicKeyRing(publicKeyRing); if (!Verifier.checkTxProposalSignature(newClient.credentials, txp)) throw new Error('Fake transaction proposal'); return newClient._signTxp(txp); }; /** * Reject a transaction proposal * * @param {Object} txp * @param {String} reason * @param {Callback} cb * @return {Callback} cb - Return error or object */ API.prototype.rejectTxProposal = function(txp, reason, cb) { $.checkState(this.credentials && this.credentials.isComplete()); $.checkArgument(cb); var self = this; var url = '/v1/txproposals/' + txp.id + '/rejections/'; var args = { reason: API._encryptMessage(reason, self.credentials.sharedEncryptingKey) || '', }; self._doPostRequest(url, args, function(err, txp) { if (err) return cb(err); self._processTxps(txp); return cb(null, txp); }); }; /** * Broadcast raw transaction * * @param {Object} opts * @param {String} opts.network * @param {String} opts.rawTx * @param {Callback} cb * @return {Callback} cb - Return error or txid */ API.prototype.broadcastRawTx = function(opts, cb) { $.checkState(this.credentials); $.checkArgument(cb); var self = this; opts = opts || {}; var url = '/v1/broadcast_raw/'; self._doPostRequest(url, opts, function(err, txid) { if (err) return cb(err); return cb(null, txid); }); }; API.prototype._doBroadcast = function(txp, opts, cb) { var self = this; var url = '/v1/txproposals/' + txp.id + '/broadcast/'; self._doPostRequest(url, opts, function(err, txp) { if (err) return cb(err); self._processTxps(txp); return cb(null, txp); }); }; /** * Broadcast a transaction proposal * * @param {Object} txp * @param {Callback} cb * @return {Callback} cb - Return error or object */ API.prototype.broadcastTxProposal = function(txp, opts, cb) { $.checkState(this.credentials && this.credentials.isComplete()); var self = this; self.getPayPro(txp, function(err, paypro) { if (paypro) { var t = Utils.buildTx(txp); self._applyAllSignatures(txp, t); PayPro.send({ http: self.payProHttp, url: txp.payProUrl, amountSat: txp.amount, refundAddr: txp.changeAddress.address, merchant_data: paypro.merchant_data, rawTx: t.serialize({ disableSmallFees: true, disableLargeFees: true, disableDustOutputs: true }), }, function(err, ack, memo) { if (err) return cb(err); self._doBroadcast(txp, opts, function(err, txp) { return cb(err, txp, memo); }); }); } else { self._doBroadcast(txp, opts, cb); } }); }; /** * Remove a transaction proposal * * @param {Object} txp * @param {Callback} cb * @return {Callback} cb - Return error or empty */ API.prototype.removeTxProposal = function(txp, cb) { $.checkState(this.credentials && this.credentials.isComplete()); var self = this; var url = '/v1/txproposals/' + txp.id; self._doDeleteRequest(url, function(err) { return cb(err); }); }; /** * Get transaction history * * @param {Object} opts * @param {Number} opts.skip (defaults to 0) * @param {Number} opts.limit * @param {Boolean} opts.includeExtendedInfo * @param {Callback} cb * @return {Callback} cb - Return error or array of transactions */ API.prototype.getTxHistory = function(opts, cb) { $.checkState(this.credentials && this.credentials.isComplete()); var self = this; var args = []; if (opts) { if (opts.skip) args.push('skip=' + opts.skip); if (opts.limit) args.push('limit=' + opts.limit); if (opts.includeExtendedInfo) args.push('includeExtendedInfo=1'); } var qs = ''; if (args.length > 0) { qs = '?' + args.join('&'); } var url = '/v1/txhistory/' + qs; self._doGetRequest(url, function(err, txs) { if (err) return cb(err); self._processTxps(txs); return cb(null, txs); }); }; /** * getTx * * @param {String} TransactionId * @return {Callback} cb - Return error or transaction */ API.prototype.getTx = function(id, cb) { $.checkState(this.credentials && this.credentials.isComplete()); var self = this; var url = '/v1/txproposals/' + id; this._doGetRequest(url, function(err, txp) { if (err) return cb(err); self._processTxps(txp); return cb(null, txp); }); }; /** * Start an address scanning process. * When finished, the scanning process will send a notification 'ScanFinished' to all copayers. * * @param {Object} opts * @param {Boolean} opts.includeCopayerBranches (defaults to false) * @param {Callback} cb */ API.prototype.startScan = function(opts, cb) { $.checkState(this.credentials && this.credentials.isComplete()); var self = this; var args = { includeCopayerBranches: opts.includeCopayerBranches, }; self._doPostRequest('/v1/addresses/scan', args, function(err) { return cb(err); }); }; /** * Adds access to the current copayer * @param {Object} opts * @param {bool} opts.generateNewKey Optional: generate a new key for the new access * @param {string} opts.restrictions * - cannotProposeTXs * - cannotXXX TODO * @param {string} opts.name (name for the new access) * * return the accesses Wallet and the requestPrivateKey */ API.prototype.addAccess = function(opts, cb) { $.checkState(this.credentials && this.credentials.canSign()); opts = opts || {}; var reqPrivKey = new Digibyte.PrivateKey(opts.generateNewKey ? null : this.credentials.requestPrivKey); var requestPubKey = reqPrivKey.toPublicKey().toString(); var xPriv = new Digibyte.HDPrivateKey(this.credentials.xPrivKey) .deriveChild(this.credentials.getBaseAddressDerivationPath()); var sig = Utils.signRequestPubKey(requestPubKey, xPriv); var copayerId = this.credentials.copayerId; var encCopayerName = opts.name ? Utils.encryptMessage(opts.name, this.credentials.sharedEncryptingKey) : null; var opts = { copayerId: copayerId, requestPubKey: requestPubKey, signature: sig, name: encCopayerName, restrictions: opts.restrictions, }; this._doPutRequest('/v1/copayers/' + copayerId + '/', opts, function(err, res) { if (err) return cb(err); return cb(null, res.wallet, reqPrivKey); }); }; /** * Get a note associated with the specified txid * @param {Object} opts * @param {string} opts.txid - The txid to associate this note with */ API.prototype.getTxNote = function(opts, cb) { $.checkState(this.credentials); var self = this; opts = opts || {}; self._doGetRequest('/v1/txnotes/' + opts.txid + '/', function(err, note) { if (err) return cb(err); self._processTxNotes(note); return cb(null, note); }); }; /** * Edit a note associated with the specified txid * @param {Object} opts * @param {string} opts.txid - The txid to associate this note with * @param {string} opts.body - The contents of the note */ API.prototype.editTxNote = function(opts, cb) { $.checkState(this.credentials); var self = this; opts = opts || {}; if (opts.body) { opts.body = API._encryptMessage(opts.body, this.credentials.sharedEncryptingKey); } self._doPutRequest('/v1/txnotes/' + opts.txid + '/', opts, function(err, note) { if (err) return cb(err); self._processTxNotes(note); return cb(null, note); }); }; /** * Get all notes edited after the specified date * @param {Object} opts * @param {string} opts.minTs - The starting timestamp */ API.prototype.getTxNotes = function(opts, cb) { $.checkState(this.credentials); var self = this; opts = opts || {}; var args = []; if (_.isNumber(opts.minTs)) { args.push('minTs=' + opts.minTs); } var qs = ''; if (args.length > 0) { qs = '?' + args.join('&'); } self._doGetRequest('/v1/txnotes/' + qs, function(err, notes) { if (err) return cb(err); self._processTxNotes(notes); return cb(null, notes); }); }; /** * Returns exchange rate for the specified currency & timestamp. * @param {Object} opts * @param {string} opts.code - Currency ISO code. * @param {Date} [opts.ts] - A timestamp to base the rate on (default Date.now()). * @param {String} [opts.provider] - A provider of exchange rates (default 'BitPay'). * @returns {Object} rates - The exchange rate. */ API.prototype.getFiatRate = function(opts, cb) { $.checkArgument(cb); var self = this; var opts = opts || {}; var args = []; if (opts.ts) args.push('ts=' + opts.ts); if (opts.provider) args.push('provider=' + opts.provider); var qs = ''; if (args.length > 0) { qs = '?' + args.join('&'); } self._doGetRequest('/v1/fiatrates/' + opts.code + '/' + qs, function(err, rates) { if (err) return cb(err); return cb(null, rates); }); } /** * Subscribe to push notifications. * @param {Object} opts * @param {String} opts.type - Device type (ios or android). * @param {String} opts.token - Device token. * @returns {Object} response - Status of subscription. */ API.prototype.pushNotificationsSubscribe = function(opts, cb) { var url = '/v1/pushnotifications/subscriptions/'; this._doPostRequest(url, opts, function(err, response) { if (err) return cb(err); return cb(null, response); }); }; /** * Unsubscribe from push notifications. * @param {String} token - Device token * @return {Callback} cb - Return error if exists */ API.prototype.pushNotificationsUnsubscribe = function(token, cb) { var url = '/v2/pushnotifications/subscriptions/' + token; this._doDeleteRequest(url, cb); }; /** * Listen to a tx for its first confirmation. * @param {Object} opts * @param {String} opts.txid - The txid to subscribe to. * @returns {Object} response - Status of subscription. */ API.prototype.txConfirmationSubscribe = function(opts, cb) { var url = '/v1/txconfirmations/'; this._doPostRequest(url, opts, function(err, response) { if (err) return cb(err); return cb(null, response); }); }; /** * Stop listening for a tx confirmation. * @param {String} txid - The txid to unsubscribe from. * @return {Callback} cb - Return error if exists */ API.prototype.txConfirmationUnsubscribe = function(txid, cb) { var url = '/v1/txconfirmations/' + txid; this._doDeleteRequest(url, cb); }; /** * Returns send max information. * @param {String} opts * @param {number} opts.feeLevel[='normal'] - Optional. Specify the fee level ('priority', 'normal', 'economy', 'superEconomy'). * @param {number} opts.feePerKb - Optional. Specify the fee per KB (in satoshi). * @param {Boolean} opts.excludeUnconfirmedUtxos - Indicates it if should use (or not) the unconfirmed utxos * @param {Boolean} opts.returnInputs - Indicates it if should return (or not) the inputs * @return {Callback} cb - Return error (if exists) and object result */ API.prototype.getSendMaxInfo = function(opts, cb) { var self = this; var args = []; opts = opts || {}; if (opts.feeLevel) args.push('feeLevel=' + opts.feeLevel); if (opts.feePerKb != null) args.push('feePerKb=' + opts.feePerKb); if (opts.excludeUnconfirmedUtxos) args.push('excludeUnconfirmedUtxos=1'); if (opts.returnInputs) args.push('returnInputs=1'); var qs = ''; if (args.length > 0) qs = '?' + args.join('&'); var url = '/v1/sendmaxinfo/' + qs; self._doGetRequest(url, function(err, result) { if (err) return cb(err); return cb(null, result); }); }; /** * Get wallet status based on a string identifier (one of: walletId, address, txid) * * @param {string} opts.identifier - The identifier * @param {Boolean} opts.twoStep[=false] - Optional: use 2-step balance computation for improved performance * @param {Boolean} opts.includeExtendedInfo (optional: query extended status) * @returns {Callback} cb - Returns error or an object with status information */ API.prototype.getStatusByIdentifier = function(opts, cb) { $.checkState(this.credentials); var self = this; opts = opts || {}; var qs = []; qs.push('includeExtendedInfo=' + (opts.includeExtendedInfo ? '1' : '0')); qs.push('twoStep=' + (opts.twoStep ? '1' : '0')); self._doGetRequest('/v1/wallets/' + opts.identifier + '?' + qs.join('&'), function(err, result) { if (err || !result || !result.wallet) return cb(err); if (result.wallet.status == 'pending') { var c = self.credentials; result.wallet.secret = API._buildSecret(c.walletId, c.walletPrivKey, c.network); } self._processStatus(result); return cb(err, result); }); }; /* * * Compatibility Functions * */ API.prototype._oldCopayDecrypt = function(username, password, blob) { var SEP1 = '@#$'; var SEP2 = '%^#@'; var decrypted; try { var passphrase = username + SEP1 + password; decrypted = sjcl.decrypt(passphrase, blob); } catch (e) { passphrase = username + SEP2 + password; try { decrypted = sjcl.decrypt(passphrase, blob); } catch (e) { log.debug(e); }; } if (!decrypted) return null; var ret; try { ret = JSON.parse(decrypted); } catch (e) {}; return ret; }; API.prototype.getWalletIdsFromOldCopay = function(username, password, blob) { var p = this._oldCopayDecrypt(username, password, blob); if (!p) return null; var ids = p.walletIds.concat(_.keys(p.focusedTimestamps)); return _.uniq(ids); }; /** * createWalletFromOldCopay * * @param username * @param password * @param blob * @param cb * @return {undefined} */ API.prototype.createWalletFromOldCopay = function(username, password, blob, cb) { var self = this; var w = this._oldCopayDecrypt(username, password, blob); if (!w) return cb(new Error('Could not decrypt')); if (w.publicKeyRing.copayersExtPubKeys.length != w.opts.totalCopayers) return cb(new Error('Wallet is incomplete, cannot be imported')); this.credentials = Credentials.fromOldCopayWallet(w); this.recreateWallet(cb); }; module.exports = API; }).call(this,require("buffer").Buffer) },{"../package.json":295,"./common":5,"./credentials":7,"./errors":8,"./log":11,"./paypro":12,"./verifier":13,"async":33,"bip38":40,"buffer":75,"digibyte":98,"digibytejs-mnemonic":148,"events":184,"json-stable-stringify":206,"lodash":211,"preconditions":228,"querystring":245,"sjcl":272,"superagent":280,"url":288,"util":292}],3:[function(require,module,exports){ 'use strict'; var Constants = {}; Constants.SCRIPT_TYPES = { P2SH: 'P2SH', P2PKH: 'P2PKH', }; Constants.DERIVATION_STRATEGIES = { BIP44: 'BIP44', BIP45: 'BIP45', BIP48: 'BIP48', }; Constants.PATHS = { REQUEST_KEY: "m/1'/0", TXPROPOSAL_KEY: "m/1'/1", REQUEST_KEY_AUTH: "m/2", // relative to BASE }; Constants.BIP45_SHARED_INDEX = 0x80000000 - 1; Constants.UNITS = { dgb: { toSatoshis: 100000000, full: { maxDecimals: 8, minDecimals: 8, }, short: { maxDecimals: 6, minDecimals: 2, } }, bit: { toSatoshis: 100, full: { maxDecimals: 2, minDecimals: 2, }, short: { maxDecimals: 0, minDecimals: 0, } }, }; module.exports = Constants; },{}],4:[function(require,module,exports){ 'use strict'; var Defaults = {}; Defaults.DEFAULT_FEE_PER_KB = 10000; Defaults.MIN_FEE_PER_KB = 0; Defaults.MAX_FEE_PER_KB = 1000000; Defaults.MAX_TX_FEE = 1 * 1e8; module.exports = Defaults; },{}],5:[function(require,module,exports){ var Common = {}; Common.Constants = require('./constants'); Common.Defaults = require('./defaults'); Common.Utils = require('./utils'); module.exports = Common; },{"./constants":3,"./defaults":4,"./utils":6}],6:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var $ = require('preconditions').singleton(); var sjcl = require('sjcl'); var Stringify = require('json-stable-stringify'); var Digibyte = require('digibyte'); var PrivateKey = Digibyte.PrivateKey; var PublicKey = Digibyte.PublicKey; var crypto = Digibyte.crypto; var encoding = Digibyte.encoding; var Constants = require('./constants'); var Defaults = require('./defaults'); function Utils() {}; Utils.SJCL = {}; Utils.encryptMessage = function(message, encryptingKey) { var key = sjcl.codec.base64.toBits(encryptingKey); return sjcl.encrypt(key, message, _.defaults({ ks: 128, iter: 1, }, Utils.SJCL)); }; Utils.decryptMessage = function(cyphertextJson, encryptingKey) { try { var key = sjcl.codec.base64.toBits(encryptingKey); return sjcl.decrypt(key, cyphertextJson); } catch (ex) { return cyphertextJson; } }; /* TODO: It would be nice to be compatible with bitcoind signmessage. How * the hash is calculated there? */ Utils.hashMessage = function(text) { $.checkArgument(text); var buf = new Buffer(text); var ret = crypto.Hash.sha256sha256(buf); ret = new Digibyte.encoding.BufferReader(ret).readReverse(); return ret; }; Utils.signMessage = function(text, privKey) { $.checkArgument(text); var priv = new PrivateKey(privKey); var hash = Utils.hashMessage(text); return crypto.ECDSA.sign(hash, priv, 'little').toString(); }; Utils.verifyMessage = function(text, signature, pubKey) { $.checkArgument(text); $.checkArgument(pubKey); if (!signature) return false; var pub = new PublicKey(pubKey); var hash = Utils.hashMessage(text); try { var sig = new crypto.Signature.fromString(signature); return crypto.ECDSA.verify(hash, sig, pub, 'little'); } catch (e) { return false; } }; Utils.privateKeyToAESKey = function(privKey) { $.checkArgument(privKey && _.isString(privKey)); $.checkArgument(Digibyte.PrivateKey.isValid(privKey), 'The private key received is invalid'); var pk = Digibyte.PrivateKey.fromString(privKey); return Digibyte.crypto.Hash.sha256(pk.toBuffer()).slice(0, 16).toString('base64'); }; Utils.getCopayerHash = function(name, xPubKey, requestPubKey) { return [name, xPubKey, requestPubKey].join('|'); }; Utils.getProposalHash = function(proposalHeader) { function getOldHash(toAddress, amount, message, payProUrl) { return [toAddress, amount, (message || ''), (payProUrl || '')].join('|'); }; // For backwards compatibility if (arguments.length > 1) { return getOldHash.apply(this, arguments); } return Stringify(proposalHeader); }; Utils.deriveAddress = function(scriptType, publicKeyRing, path, m, network) { $.checkArgument(_.includes(_.values(Constants.SCRIPT_TYPES), scriptType)); var publicKeys = _.map(publicKeyRing, function(item) { var xpub = new Digibyte.HDPublicKey(item.xPubKey); return xpub.deriveChild(path).publicKey; }); var bitcoreAddress; switch (scriptType) { case Constants.SCRIPT_TYPES.P2SH: bitcoreAddress = Digibyte.Address.createMultisig(publicKeys, m, network); break; case Constants.SCRIPT_TYPES.P2PKH: $.checkState(_.isArray(publicKeys) && publicKeys.length == 1); bitcoreAddress = Digibyte.Address.fromPublicKey(publicKeys[0], network); break; } return { address: bitcoreAddress.toString(), path: path, publicKeys: _.invokeMap(publicKeys, 'toString'), }; }; Utils.xPubToCopayerId = function(xpub) { var str = xpub; var hash = sjcl.hash.sha256.hash(str); return sjcl.codec.hex.fromBits(hash); }; Utils.signRequestPubKey = function(requestPubKey, xPrivKey) { var priv = new Digibyte.HDPrivateKey(xPrivKey).deriveChild(Constants.PATHS.REQUEST_KEY_AUTH).privateKey; return Utils.signMessage(requestPubKey, priv); }; Utils.verifyRequestPubKey = function(requestPubKey, signature, xPubKey) { var pub = (new Digibyte.HDPublicKey(xPubKey)).deriveChild(Constants.PATHS.REQUEST_KEY_AUTH).publicKey; return Utils.verifyMessage(requestPubKey, signature, pub.toString()); }; Utils.formatAmount = function(satoshis, unit, opts) { $.shouldBeNumber(satoshis); $.checkArgument(_.includes(_.keys(Constants.UNITS), unit)); function clipDecimals(number, decimals) { var x = number.toString().split('.'); var d = (x[1] || '0').substring(0, decimals); return parseFloat(x[0] + '.' + d); }; function addSeparators(nStr, thousands, decimal, minDecimals) { nStr = nStr.replace('.', decimal); var x = nStr.split(decimal); var x0 = x[0]; var x1 = x[1]; x1 = _.dropRightWhile(x1, function(n, i) { return n == '0' && i >= minDecimals; }).join(''); var x2 = x.length > 1 ? decimal + x1 : ''; x0 = x0.replace(/\B(?=(\d{3})+(?!\d))/g, thousands); return x0 + x2; }; opts = opts || {}; var u = Constants.UNITS[unit]; var precision = opts.fullPrecision ? 'full' : 'short'; var amount = clipDecimals((satoshis / u.toSatoshis), u[precision].maxDecimals).toFixed(u[precision].maxDecimals); return addSeparators(amount, opts.thousandsSeparator || ',', opts.decimalSeparator || '.', u[precision].minDecimals); }; Utils.buildTx = function(txp) { var t = new Digibyte.Transaction(); $.checkState(_.includes(_.values(Constants.SCRIPT_TYPES), txp.addressType)); switch (txp.addressType) { case Constants.SCRIPT_TYPES.P2SH: _.each(txp.inputs, function(i) { t.from(i, i.publicKeys, txp.requiredSignatures); }); break; case Constants.SCRIPT_TYPES.P2PKH: t.from(txp.inputs); break; } if (txp.toAddress && txp.amount && !txp.outputs) { t.to(txp.toAddress, txp.amount); } else if (txp.outputs) { _.each(txp.outputs, function(o) { $.checkState(o.script || o.toAddress, 'Output should have either toAddress or script specified'); if (o.script) { t.addOutput(new Digibyte.Transaction.Output({ script: o.script, satoshis: o.amount })); } else { t.to(o.toAddress, o.amount); } }); } t.fee(txp.fee); if (txp.changeAddress) { t.change(txp.changeAddress.address); } // Shuffle outputs for improved privacy if (t.outputs.length > 1) { var outputOrder = _.reject(txp.outputOrder, function(order) { return order >= t.outputs.length; }); $.checkState(t.outputs.length == outputOrder.length); t.sortOutputs(function(outputs) { return _.map(outputOrder, function(i) { return outputs[i]; }); }); } if (txp.type !== 'external') { // Validate inputs vs outputs independently of Bitcore var totalInputs = _.reduce(txp.inputs, function(memo, i) { return +i.satoshis + memo; }, 0); var totalOutputs = _.reduce(t.outputs, function(memo, o) { return +o.satoshis + memo; }, 0); $.checkState(totalInputs - totalOutputs >= 0); $.checkState(totalInputs - totalOutputs <= Defaults.MAX_TX_FEE); } return t; }; module.exports = Utils; }).call(this,require("buffer").Buffer) },{"./constants":3,"./defaults":4,"buffer":75,"digibyte":98,"json-stable-stringify":206,"lodash":211,"preconditions":228,"sjcl":272}],7:[function(require,module,exports){ (function (Buffer){ 'use strict'; var $ = require('preconditions').singleton(); var _ = require('lodash'); var Digibyte = require('digibyte'); var Mnemonic = require('digibytejs-mnemonic'); var sjcl = require('sjcl'); var Common = require('./common'); var Constants = Common.Constants; var Utils = Common.Utils; var FIELDS = [ 'network', 'xPrivKey', 'xPrivKeyEncrypted', 'xPubKey', 'requestPrivKey', 'requestPubKey', 'copayerId', 'publicKeyRing', 'walletId', 'walletName', 'm', 'n', 'walletPrivKey', 'personalEncryptingKey', 'sharedEncryptingKey', 'copayerName', 'externalSource', 'mnemonic', 'mnemonicEncrypted', 'entropySource', 'mnemonicHasPassphrase', 'derivationStrategy', 'account', 'compliantDerivation', 'addressType', 'hwInfo', 'entropySourcePath', ]; function Credentials() { this.version = '1.0.0'; this.derivationStrategy = Constants.DERIVATION_STRATEGIES.BIP44; this.account = 0; }; function _checkNetwork(network) { if (!_.includes(['livenet', 'testnet'], network)) throw new Error('Invalid network'); }; Credentials.create = function(network) { _checkNetwork(network); var x = new Credentials(); x.network = network; x.xPrivKey = (new Digibyte.HDPrivateKey(network)).toString(); x.compliantDerivation = true; x._expand(); return x; }; var wordsForLang = { 'en': Mnemonic.Words.ENGLISH, 'es': Mnemonic.Words.SPANISH, 'ja': Mnemonic.Words.JAPANESE, 'zh': Mnemonic.Words.CHINESE, 'fr': Mnemonic.Words.FRENCH, 'it': Mnemonic.Words.ITALIAN, }; Credentials.createWithMnemonic = function(network, passphrase, language, account, opts) { _checkNetwork(network); if (!wordsForLang[language]) throw new Error('Unsupported language'); $.shouldBeNumber(account); opts = opts || {}; var m = new Mnemonic(wordsForLang[language]); while (!Mnemonic.isValid(m.toString())) { m = new Mnemonic(wordsForLang[language]) }; var x = new Credentials(); x.network = network; x.account = account; x.xPrivKey = m.toHDPrivateKey(passphrase, network).toString(); x.compliantDerivation = true; x._expand(); x.mnemonic = m.phrase; x.mnemonicHasPassphrase = !!passphrase; return x; }; Credentials.fromExtendedPrivateKey = function(xPrivKey, account, derivationStrategy, opts) { $.shouldBeNumber(account); $.checkArgument(_.includes(_.values(Constants.DERIVATION_STRATEGIES), derivationStrategy)); opts = opts || {}; var x = new Credentials(); x.xPrivKey = xPrivKey; x.account = account; x.derivationStrategy = derivationStrategy; x.compliantDerivation = !opts.nonCompliantDerivation; if (opts.walletPrivKey) { x.addWalletPrivateKey(opts.walletPrivKey); } x._expand(); return x; }; // note that mnemonic / passphrase is NOT stored Credentials.fromMnemonic = function(network, words, passphrase, account, derivationStrategy, opts) { _checkNetwork(network); $.shouldBeNumber(account); $.checkArgument(_.includes(_.values(Constants.DERIVATION_STRATEGIES), derivationStrategy)); opts = opts || {}; var m = new Mnemonic(words); var x = new Credentials(); x.xPrivKey = m.toHDPrivateKey(passphrase, network).toString(); x.mnemonic = words; x.mnemonicHasPassphrase = !!passphrase; x.account = account; x.derivationStrategy = derivationStrategy; x.compliantDerivation = !opts.nonCompliantDerivation; x.entropySourcePath = opts.entropySourcePath; if (opts.walletPrivKey) { x.addWalletPrivateKey(opts.walletPrivKey); } x._expand(); return x; }; /* * BWC uses * xPrivKey -> m/44'/network'/account' -> Base Address Key * so, xPubKey is PublicKeyHD(xPrivKey.deriveChild("m/44'/network'/account'"). * * For external sources, this derivation should be done before * call fromExtendedPublicKey * * entropySource should be a HEX string containing pseudo-random data, that can * be deterministically derived from the xPrivKey, and should not be derived from xPubKey */ Credentials.fromExtendedPublicKey = function(xPubKey, source, entropySourceHex, account, derivationStrategy, opts) { $.checkArgument(entropySourceHex); $.shouldBeNumber(account); $.checkArgument(_.includes(_.values(Constants.DERIVATION_STRATEGIES), derivationStrategy)); opts = opts || {}; var entropyBuffer = new Buffer(entropySourceHex, 'hex'); //require at least 112 bits of entropy $.checkArgument(entropyBuffer.length >= 14, 'At least 112 bits of entropy are needed') var x = new Credentials(); x.xPubKey = xPubKey; x.entropySource = Digibyte.crypto.Hash.sha256sha256(entropyBuffer).toString('hex'); x.account = account; x.derivationStrategy = derivationStrategy; x.externalSource = source; x.compliantDerivation = true; x._expand(); return x; }; // Get network from extended private key or extended public key Credentials._getNetworkFromExtendedKey = function(xKey) { $.checkArgument(xKey && _.isString(xKey)); return xKey.charAt(0) == 't' ? 'testnet' : 'livenet'; }; Credentials.prototype._hashFromEntropy = function(prefix, length) { $.checkState(prefix); var b = new Buffer(this.entropySource, 'hex'); var b2 = Digibyte.crypto.Hash.sha256hmac(b, new Buffer(prefix)); return b2.slice(0, length); }; Credentials.prototype._expand = function() { $.checkState(this.xPrivKey || (this.xPubKey && this.entropySource)); var network = Credentials._getNetworkFromExtendedKey(this.xPrivKey || this.xPubKey); if (this.network) { $.checkState(this.network == network); } else { this.network = network; } if (this.xPrivKey) { var xPrivKey = new Digibyte.HDPrivateKey.fromString(this.xPrivKey); var deriveFn = this.compliantDerivation ? _.bind(xPrivKey.deriveChild, xPrivKey) : _.bind(xPrivKey.deriveNonCompliantChild, xPrivKey); var derivedXPrivKey = deriveFn(this.getBaseAddressDerivationPath()); // this is the xPubKey shared with the server. this.xPubKey = derivedXPrivKey.hdPublicKey.toString(); } // requests keys from mnemonics, but using a xPubkey // This is only used when importing mnemonics FROM // an hwwallet, in which xPriv was not available when // the wallet was created. if (this.entropySourcePath) { var seed = deriveFn(this.entropySourcePath).publicKey.toBuffer(); this.entropySource = Digibyte.crypto.Hash.sha256sha256(seed).toString('hex'); } if (this.entropySource) { // request keys from entropy (hw wallets) var seed = this._hashFromEntropy('reqPrivKey', 32); var privKey = new Digibyte.PrivateKey(seed.toString('hex'), network); this.requestPrivKey = privKey.toString(); this.requestPubKey = privKey.toPublicKey().toString(); } else { // request keys derived from xPriv var requestDerivation = deriveFn(Constants.PATHS.REQUEST_KEY); this.requestPrivKey = requestDerivation.privateKey.toString(); var pubKey = requestDerivation.publicKey; this.requestPubKey = pubKey.toString(); this.entropySource = Digibyte.crypto.Hash.sha256(requestDerivation.privateKey.toBuffer()).toString('hex'); } this.personalEncryptingKey = this._hashFromEntropy('personalKey', 16).toString('base64'); this.copayerId = Utils.xPubToCopayerId(this.xPubKey); this.publicKeyRing = [{ xPubKey: this.xPubKey, requestPubKey: this.requestPubKey, }]; }; Credentials.fromObj = function(obj) { var x = new Credentials(); _.each(FIELDS, function(k) { x[k] = obj[k]; }); x.derivationStrategy = x.derivationStrategy || Constants.DERIVATION_STRATEGIES.BIP45; x.addressType = x.addressType || Constants.SCRIPT_TYPES.P2SH; x.account = x.account || 0; $.checkState(x.xPrivKey || x.xPubKey || x.xPrivKeyEncrypted, "invalid input"); return x; }; Credentials.prototype.toObj = function() { var self = this; var x = {}; _.each(FIELDS, function(k) { x[k] = self[k]; }); return x; }; Credentials.prototype.getBaseAddressDerivationPath = function() { var purpose; switch (this.derivationStrategy) { case Constants.DERIVATION_STRATEGIES.BIP45: return "m/45'"; case Constants.DERIVATION_STRATEGIES.BIP44: purpose = '44'; break; case Constants.DERIVATION_STRATEGIES.BIP48: purpose = '48'; break; } var coin = (this.network == 'livenet' ? "0" : "1"); return "m/" + purpose + "'/" + coin + "'/" + this.account + "'"; }; Credentials.prototype.getDerivedXPrivKey = function(password) { var path = this.getBaseAddressDerivationPath(); var xPrivKey = new Digibyte.HDPrivateKey(this.getKeys(password).xPrivKey, this.network); var deriveFn = !!this.compliantDerivation ? _.bind(xPrivKey.deriveChild, xPrivKey) : _.bind(xPrivKey.deriveNonCompliantChild, xPrivKey); return deriveFn(path); }; Credentials.prototype.addWalletPrivateKey = function(walletPrivKey) { this.walletPrivKey = walletPrivKey; this.sharedEncryptingKey = Utils.privateKeyToAESKey(walletPrivKey); }; Credentials.prototype.addWalletInfo = function(walletId, walletName, m, n, copayerName) { this.walletId = walletId; this.walletName = walletName; this.m = m; this.n = n; if (copayerName) this.copayerName = copayerName; if (this.derivationStrategy == 'BIP44' && n == 1) this.addressType = Constants.SCRIPT_TYPES.P2PKH; else this.addressType = Constants.SCRIPT_TYPES.P2SH; // Use m/48' for multisig hardware wallets if (!this.xPrivKey && this.externalSource && n > 1) { this.derivationStrategy = Constants.DERIVATION_STRATEGIES.BIP48; } if (n == 1) { this.addPublicKeyRing([{ xPubKey: this.xPubKey, requestPubKey: this.requestPubKey, }]); } }; Credentials.prototype.hasWalletInfo = function() { return !!this.walletId; }; Credentials.prototype.isPrivKeyEncrypted = function() { return (!!this.xPrivKeyEncrypted) && !this.xPrivKey; }; Credentials.prototype.encryptPrivateKey = function(password, opts) { if (this.xPrivKeyEncrypted) throw new Error('Private key already encrypted'); if (!this.xPrivKey) throw new Error('No private key to encrypt'); this.xPrivKeyEncrypted = sjcl.encrypt(password, this.xPrivKey, opts); if (!this.xPrivKeyEncrypted) throw new Error('Could not encrypt'); if (this.mnemonic) this.mnemonicEncrypted = sjcl.encrypt(password, this.mnemonic, opts); delete this.xPrivKey; delete this.mnemonic; }; Credentials.prototype.decryptPrivateKey = function(password) { if (!this.xPrivKeyEncrypted) throw new Error('Private key is not encrypted'); try { this.xPrivKey = sjcl.decrypt(password, this.xPrivKeyEncrypted); if (this.mnemonicEncrypted) { this.mnemonic = sjcl.decrypt(password, this.mnemonicEncrypted); } delete this.xPrivKeyEncrypted; delete this.mnemonicEncrypted; } catch (ex) { throw new Error('Could not decrypt'); } }; Credentials.prototype.getKeys = function(password) { var keys = {}; if (this.isPrivKeyEncrypted()) { $.checkArgument(password, 'Private keys are encrypted, a password is needed'); try { keys.xPrivKey = sjcl.decrypt(password, this.xPrivKeyEncrypted); if (this.mnemonicEncrypted) { keys.mnemonic = sjcl.decrypt(password, this.mnemonicEncrypted); } } catch (ex) { throw new Error('Could not decrypt'); } } else { keys.xPrivKey = this.xPrivKey; keys.mnemonic = this.mnemonic; } return keys; }; Credentials.prototype.addPublicKeyRing = function(publicKeyRing) { this.publicKeyRing = _.clone(publicKeyRing); }; Credentials.prototype.canSign = function() { return (!!this.xPrivKey || !!this.xPrivKeyEncrypted); }; Credentials.prototype.setNoSign = function() { delete this.xPrivKey; delete this.xPrivKeyEncrypted; delete this.mnemonic; delete this.mnemonicEncrypted; }; Credentials.prototype.isComplete = function() { if (!this.m || !this.n) return false; if (!this.publicKeyRing || this.publicKeyRing.length != this.n) return false; return true; }; Credentials.prototype.hasExternalSource = function() { return (typeof this.externalSource == "string"); }; Credentials.prototype.getExternalSourceName = function() { return this.externalSource; }; Credentials.prototype.getMnemonic = function() { if (this.mnemonicEncrypted && !this.mnemonic) { throw new Error('Credentials are encrypted'); } return this.mnemonic; }; Credentials.prototype.clearMnemonic = function() { delete this.mnemonic; delete this.mnemonicEncrypted; }; Credentials.fromOldCopayWallet = function(w) { function walletPrivKeyFromOldCopayWallet(w) { // IN BWS, the master Pub Keys are not sent to the server, // so it is safe to use them as seed for wallet's shared secret. var seed = w.publicKeyRing.copayersExtPubKeys.sort().join(''); var seedBuf = new Buffer(seed); var privKey = new Digibyte.PrivateKey.fromBuffer(Digibyte.crypto.Hash.sha256(seedBuf)); return privKey.toString(); }; var credentials = new Credentials(); credentials.derivationStrategy = Constants.DERIVATION_STRATEGIES.BIP45; credentials.xPrivKey = w.privateKey.extendedPrivateKeyString; credentials._expand(); credentials.addWalletPrivateKey(walletPrivKeyFromOldCopayWallet(w)); credentials.addWalletInfo(w.opts.id, w.opts.name, w.opts.requiredCopayers, w.opts.totalCopayers) var pkr = _.map(w.publicKeyRing.copayersExtPubKeys, function(xPubStr) { var isMe = xPubStr === credentials.xPubKey; var requestDerivation; if (isMe) { var path = Constants.PATHS.REQUEST_KEY; requestDerivation = (new Digibyte.HDPrivateKey(credentials.xPrivKey)) .deriveChild(path).hdPublicKey; } else { // this var path = Constants.PATHS.REQUEST_KEY_AUTH; requestDerivation = (new Digibyte.HDPublicKey(xPubStr)).deriveChild(path); } // Grab Copayer Name var hd = new Digibyte.HDPublicKey(xPubStr).deriveChild('m/2147483646/0/0'); var pubKey = hd.publicKey.toString('hex'); var copayerName = w.publicKeyRing.nicknameFor[pubKey]; if (isMe) { credentials.copayerName = copayerName; } return { xPubKey: xPubStr, requestPubKey: requestDerivation.publicKey.toString(), copayerName: copayerName, }; }); credentials.addPublicKeyRing(pkr); return credentials; }; module.exports = Credentials; }).call(this,require("buffer").Buffer) },{"./common":5,"buffer":75,"digibyte":98,"digibytejs-mnemonic":148,"lodash":211,"preconditions":228,"sjcl":272}],8:[function(require,module,exports){ 'use strict'; var _ = require('lodash'); function format(message, args) { return message .replace('{0}', args[0]) .replace('{1}', args[1]) .replace('{2}', args[2]); } var traverseNode = function(parent, errorDefinition) { var NodeError = function() { if (_.isString(errorDefinition.message)) { this.message = format(errorDefinition.message, arguments); } else if (_.isFunction(errorDefinition.message)) { this.message = errorDefinition.message.apply(null, arguments); } else { throw new Error('Invalid error definition for ' + errorDefinition.name); } this.stack = this.message + '\n' + (new Error()).stack; }; NodeError.prototype = Object.create(parent.prototype); NodeError.prototype.name = parent.prototype.name + errorDefinition.name; parent[errorDefinition.name] = NodeError; if (errorDefinition.errors) { childDefinitions(NodeError, errorDefinition.errors); } return NodeError; }; /* jshint latedef: false */ var childDefinitions = function(parent, childDefinitions) { _.each(childDefinitions, function(childDefinition) { traverseNode(parent, childDefinition); }); }; /* jshint latedef: true */ var traverseRoot = function(parent, errorsDefinition) { childDefinitions(parent, errorsDefinition); return parent; }; var bwc = {}; bwc.Error = function() { this.message = 'Internal error'; this.stack = this.message + '\n' + (new Error()).stack; }; bwc.Error.prototype = Object.create(Error.prototype); bwc.Error.prototype.name = 'bwc.Error'; var data = require('./spec'); traverseRoot(bwc.Error, data); module.exports = bwc.Error; module.exports.extend = function(spec) { return traverseNode(bwc.Error, spec); }; },{"./spec":9,"lodash":211}],9:[function(require,module,exports){ 'use strict'; var errorSpec = [{ name: 'INVALID_BACKUP', message: 'Invalid Backup.' }, { name: 'WALLET_DOES_NOT_EXIST', message: 'Wallet does not exist.' }, { name: 'MISSING_PRIVATE_KEY', message: 'Missing private keys to sign.' }, { name: 'ENCRYPTED_PRIVATE_KEY', message: 'Private key is encrypted, cannot sign transaction.' }, { name: 'SERVER_COMPROMISED', message: 'Server response could not be verified.' }, { name: 'COULD_NOT_BUILD_TRANSACTION', message: 'Could not build the transaction.' }, { name: 'INSUFFICIENT_FUNDS', message: 'Insufficient funds.' }, { name: 'CONNECTION_ERROR', message: 'Wallet service connection error.' }, { name: 'NOT_FOUND', message: 'Wallet service not found.' }, { name: 'ECONNRESET_ERROR', message: 'ECONNRESET, body: {0}' }, { name: 'WALLET_ALREADY_EXISTS', message: 'Wallet already exists.' }, { name: 'COPAYER_IN_WALLET', message: 'Copayer in wallet.' }, { name: 'WALLET_FULL', message: 'Wallet is full.' }, { name: 'WALLET_NOT_FOUND', message: 'Wallet not found.' }, { name: 'INSUFFICIENT_FUNDS_FOR_FEE', message: 'Insufficient funds for fee.' }, { name: 'LOCKED_FUNDS', message: 'Locked funds.' }, { name: 'DUST_AMOUNT', message: 'Amount below dust threshold.' }, { name: 'COPAYER_VOTED', message: 'Copayer already voted on this transaction proposal.' }, { name: 'NOT_AUTHORIZED', message: 'Not authorized.' }, { name: 'UNAVAILABLE_UTXOS', message: 'Unavailable unspent outputs.' }, { name: 'TX_NOT_FOUND', message: 'Transaction proposal not found.' }, { name: 'MAIN_ADDRESS_GAP_REACHED', message: 'Maximum number of consecutive addresses without activity reached.' }, { name: 'COPAYER_REGISTERED', message: 'Copayer already register on server.' } ]; module.exports = errorSpec; },{}],10:[function(require,module,exports){ /** * The official client library for digibytejs-wallet-service. * @module Client */ /** * Client API. * @alias module:Client.API */ var client = module.exports = require('./api'); /** * Verifier module. * @alias module:Client.Verifier */ client.Verifier = require('./verifier'); client.Utils = require('./common/utils'); client.sjcl = require('sjcl'); // Expose digibyte client.Digibyte = require('digibyte'); },{"./api":2,"./common/utils":6,"./verifier":13,"digibyte":98,"sjcl":272}],11:[function(require,module,exports){ var _ = require('lodash'); var DEFAULT_LOG_LEVEL = 'silent'; /** * @desc * A simple logger that wraps the <tt>console.log</tt> methods when available. * * Usage: * <pre> * log = new Logger('copay'); * log.setLevel('info'); * log.debug('Message!'); // won't show * log.setLevel('debug'); * log.debug('Message!', 1); // will show '[debug] copay: Message!, 1' * </pre> * * @param {string} name - a name for the logger. This will show up on every log call * @constructor */ var Logger = function(name) { this.name = name || 'log'; this.level = DEFAULT_LOG_LEVEL; }; Logger.prototype.getLevels = function() { return levels; }; var levels = { 'silent': -1, 'debug': 0, 'info': 1, 'log': 2, 'warn': 3, 'error': 4, 'fatal': 5 }; _.each(levels, function(level, levelName) { if (levelName === 'silent') { // dont create a log.silent() method return; } Logger.prototype[levelName] = function() { if (this.level === 'silent') { return; } if (level >= levels[this.level]) { if (Error.stackTraceLimit && this.level == 'debug') { var old = Error.stackTraceLimit; Error.stackTraceLimit = 2; var stack; // this hack is to be compatible with IE11 try { anerror(); } catch (e) { stack = e.stack; } var lines = stack.split('\n'); var caller = lines[2]; caller = ':' + caller.substr(6); Error.stackTraceLimit = old; } var str = '[' + levelName + (caller || '') + '] ' + arguments[0], extraArgs, extraArgs = [].slice.call(arguments, 1); if (console[levelName]) { extraArgs.unshift(str); console[levelName].apply(console, extraArgs); } else { if (extraArgs.length) { str += JSON.stringify(extraArgs); } console.log(str); } } }; }); /** * @desc * Sets the level of a logger. A level can be any bewteen: 'debug', 'info', 'log', * 'warn', 'error', and 'fatal'. That order matters: if a logger's level is set to * 'warn', calling <tt>level.debug</tt> won't have any effect. * * @param {string} level - the name of the logging level */ Logger.prototype.setLevel = function(level) { this.level = level; }; /** * @class Logger * @method debug * @desc Log messages at the debug level. * @param {*} args - the arguments to be logged. */ /** * @class Logger * @method info * @desc Log messages at the info level. * @param {*} args - the arguments to be logged. */ /** * @class Logger * @method log * @desc Log messages at an intermediary level called 'log'. * @param {*} args - the arguments to be logged. */ /** * @class Logger * @method warn * @desc Log messages at the warn level. * @param {*} args - the arguments to be logged. */ /** * @class Logger * @method error * @desc Log messages at the error level. * @param {*} args - the arguments to be logged. */ /** * @class Logger * @method fatal * @desc Log messages at the fatal level. * @param {*} args - the arguments to be logged. */ var logger = new Logger('copay'); module.exports = logger; },{"lodash":211}],12:[function(require,module,exports){ (function (process,Buffer){ var $ = require('preconditions').singleton(); var Digibyte = require('digibyte'); var BitcorePayPro = require('digibytejs-payment-protocol'); var PayPro = {}; PayPro._nodeRequest = function(opts, cb) { opts.agent = false; var http = opts.httpNode || (opts.proto === 'http' ? require("http") : require("https")); var fn = opts.method == 'POST' ? 'post' : 'get'; http[fn](opts, function(res) { var data = []; // List of Buffer objects if (res.statusCode != 200) return cb(new Error('HTTP Request Error: ' + res.statusCode + ' ' + res.statusMessage + ' ' + ( data ? data : '' ) )); res.on("data", function(chunk) { data.push(chunk); // Append Buffer object }); res.on("end", function() { data = Buffer.concat(data); // Make one large Buffer of it return cb(null, data); }); }); }; PayPro._browserRequest = function(opts, cb) { var method = (opts.method || 'GET').toUpperCase(); var url = opts.url; var req = opts; req.headers = req.headers || {}; req.body = req.body || req.data || ''; var xhr = opts.xhr || new XMLHttpRequest(); xhr.open(method, url, true); Object.keys(req.headers).forEach(function(key) { var val = req.headers[key]; if (key === 'Content-Length') return; if (key === 'Content-Transfer-Encoding') return; xhr.setRequestHeader(key, val); }); xhr.responseType = 'arraybuffer'; xhr.onload = function(event) { var response = xhr.response; if (xhr.status == 200) { return cb(null, new Uint8Array(response)); } else { return cb('HTTP Request Error: ' + xhr.status + ' ' + xhr.statusText + ' ' + response ? response : ''); } }; xhr.onerror = function(event) { var status; if (xhr.status === 0 || !xhr.statusText) { status = 'HTTP Request Error'; } else { status = xhr.statusText; } return cb(new Error(status)); }; if (req.body) { xhr.send(req.body); } else { xhr.send(null); } }; var getHttp = function(opts) { var match = opts.url.match(/^((http[s]?):\/)?\/?([^:\/\s]+)((\/\w+)*\/)([\w\-\.]+[^#?\s]+)(.*)?(#[\w\-]+)?$/); opts.proto = RegExp.$2; opts.host = RegExp.$3; opts.path = RegExp.$4 + RegExp.$6; if (opts.http) return opts.http; var env = opts.env; if (!env) env = (process && !process.browser) ? 'node' : 'browser'; return (env == "node") ? PayPro._nodeRequest : http = PayPro._browserRequest;; }; PayPro.get = function(opts, cb) { $.checkArgument(opts && opts.url); var http = getHttp(opts); var PP = new BitcorePayPro(); opts.headers = opts.headers || { 'Accept': BitcorePayPro.LEGACY_PAYMENT.REQUEST_CONTENT_TYPE, 'Content-Type': 'application/octet-stream', }; http(opts, function(err, dataBuffer) { if (err) return cb(err); var request, verified, signature, serializedDetails; try { var body = BitcorePayPro.PaymentRequest.decode(dataBuffer); request = PP.makePaymentRequest(body); signature = request.get('signature'); serializedDetails = request.get('serialized_payment_details'); // Verify the signature verified = request.verify(true); } catch (e) { return cb(new Error('Could not parse payment protocol' + e)); } // Get the payment details var decodedDetails = BitcorePayPro.PaymentDetails.decode(serializedDetails); var pd = new BitcorePayPro(); pd = pd.makePaymentDetails(decodedDetails); var outputs = pd.get('outputs'); if (outputs.length > 1) return cb(new Error('Payment Protocol Error: Requests with more that one output are not supported')) var output = outputs[0]; var amount = output.get('amount').toNumber(); var network = pd.get('network') == 'test' ? 'testnet' : 'livenet'; // We love payment protocol var offset = output.get('script').offset; var limit = output.get('script').limit; // NOTE: For some reason output.script.buffer // is only an ArrayBuffer var buffer = new Buffer(new Uint8Array(output.get('script').buffer)); var scriptBuf = buffer.slice(offset, limit); var addr = new Digibyte.Address.fromScript(new Digibyte.Script(scriptBuf), network); var md = pd.get('merchant_data'); if (md) { md = md.toString(); } var ok = verified.verified; var caName; if (verified.isChain) { ok = ok && verified.chainVerified; } var ret = { verified: ok, caTrusted: verified.caTrusted, caName: verified.caName, selfSigned: verified.selfSigned, expires: pd.get('expires'), memo: pd.get('memo'), time: pd.get('time'), merchant_data: md, toAddress: addr.toString(), amount: amount, network: network, domain: opts.host, url: opts.url, }; var requiredFeeRate = pd.get('required_fee_rate'); if (requiredFeeRate) ret.requiredFeeRate = requiredFeeRate; return cb(null, ret); }); }; PayPro._getPayProRefundOutputs = function(addrStr, amount) { amount = amount.toString(10); var output = new BitcorePayPro.Output(); var addr = new bitcore.Address(addrStr); var s; if (addr.isPayToPublicKeyHash()) { s = Digibyte.Script.buildPublicKeyHashOut(addr); } else if (addr.isPayToScriptHash()) { s = Digibyte.Script.buildScriptHashOut(addr); } else { throw new Error('Unrecognized address type ' + addr.type); } // console.log('PayPro refund address set to:', addrStr,s); output.set('script', s.toBuffer()); output.set('amount', amount); return [output]; }; PayPro._createPayment = function(merchant_data, rawTx, refundAddr, amountSat) { var pay = new BitcorePayPro(); pay = pay.makePayment(); if (merchant_data) { merchant_data = new Buffer(merchant_data); pay.set('merchant_data', merchant_data); } var txBuf = new Buffer(rawTx, 'hex'); pay.set('transactions', [txBuf]); var refund_outputs = this._getPayProRefundOutputs(refundAddr, amountSat); if (refund_outputs) pay.set('refund_to', refund_outputs); // Unused for now // options.memo = ''; // pay.set('memo', options.memo); pay = pay.serialize(); var buf = new ArrayBuffer(pay.length); var view = new Uint8Array(buf); for (var i = 0; i < pay.length; i++) { view[i] = pay[i]; } return view; }; PayPro.send = function(opts, cb) { $.checkArgument(opts.merchant_data) .checkArgument(opts.url) .checkArgument(opts.rawTx) .checkArgument(opts.refundAddr) .checkArgument(opts.amountSat); var payment = PayPro._createPayment(opts.merchant_data, opts.rawTx, opts.refundAddr, opts.amountSat); var http = getHttp(opts); opts.method = 'POST'; opts.headers = opts.headers || { 'Accept': BitcorePayPro.LEGACY_PAYMENT.ACK_CONTENT_TYPE, 'Content-Type': BitcorePayPro.LEGACY_PAYMENT.CONTENT_TYPE, // 'Content-Type': 'application/octet-stream', }; opts.body = payment; http(opts, function(err, rawData) { if (err) return cb(err); var memo; if (rawData) { try { var data = BitcorePayPro.PaymentACK.decode(rawData); var pp = new BitcorePayPro(); var ack = pp.makePaymentACK(data); memo = ack.get('memo'); } catch (e) { console.log('Could not decode paymentACK'); }; } return cb(null, rawData, memo); }); }; module.exports = PayPro; }).call(this,require('_process'),require("buffer").Buffer) },{"_process":234,"buffer":75,"digibyte":98,"digibytejs-payment-protocol":159,"http":274,"https":200,"preconditions":228}],13:[function(require,module,exports){ var $ = require('preconditions').singleton(); var _ = require('lodash'); var Digibyte = require('digibyte'); var Common = require('./common'); var Utils = Common.Utils; var log = require('./log'); /** * @desc Verifier constructor. Checks data given by the server * * @constructor */ function Verifier(opts) {}; /** * Check address * * @param {Function} credentials * @param {String} address * @returns {Boolean} true or false */ Verifier.checkAddress = function(credentials, address) { $.checkState(credentials.isComplete()); var local = Utils.deriveAddress(address.type || credentials.addressType, credentials.publicKeyRing, address.path, credentials.m, credentials.network); return (local.address == address.address && _.difference(local.publicKeys, address.publicKeys).length === 0); }; /** * Check copayers * * @param {Function} credentials * @param {Array} copayers * @returns {Boolean} true or false */ Verifier.checkCopayers = function(credentials, copayers) { $.checkState(credentials.walletPrivKey); var walletPubKey = Digibyte.PrivateKey.fromString(credentials.walletPrivKey).toPublicKey().toString(); if (copayers.length != credentials.n) { log.error('Missing public keys in server response'); return false; } // Repeated xpub kes? var uniq = []; var error; _.each(copayers, function(copayer) { if (error) return; if (uniq[copayers.xPubKey]++) { log.error('Repeated public keys in server response'); error = true; } // Not signed pub keys if (!(copayer.encryptedName || copayer.name) || !copayer.xPubKey || !copayer.requestPubKey || !copayer.signature) { log.error('Missing copayer fields in server response'); error = true; } else { var hash = Utils.getCopayerHash(copayer.encryptedName || copayer.name, copayer.xPubKey, copayer.requestPubKey); if (!Utils.verifyMessage(hash, copayer.signature, walletPubKey)) { log.error('Invalid signatures in server response'); error = true; } } }); if (error) return false; if (!_.includes(_.map(copayers, 'xPubKey'), credentials.xPubKey)) { log.error('Server response does not contains our public keys') return false; } return true; }; Verifier.checkProposalCreation = function(args, txp, encryptingKey) { function strEqual(str1, str2) { return ((!str1 && !str2) || (str1 === str2)); } if (txp.outputs.length != args.outputs.length) return false; for (var i = 0; i < txp.outputs.length; i++) { var o1 = txp.outputs[i]; var o2 = args.outputs[i]; if (!strEqual(o1.toAddress, o2.toAddress)) return false; if (!strEqual(o1.script, o2.script)) return false; if (o1.amount != o2.amount) return false; var decryptedMessage = null; try { decryptedMessage = Utils.decryptMessage(o2.message, encryptingKey); } catch (e) { return false; } if (!strEqual(o1.message, decryptedMessage)) return false; } var changeAddress; if (txp.changeAddress) { changeAddress = txp.changeAddress.address; } if (args.changeAddress && !strEqual(changeAddress, args.changeAddress)) return false; if (_.isNumber(args.feePerKb) && (txp.feePerKb != args.feePerKb)) return false; if (!strEqual(txp.payProUrl, args.payProUrl)) return false; var decryptedMessage = null; try { decryptedMessage = Utils.decryptMessage(args.message, encryptingKey); } catch (e) { return false; } if (!strEqual(txp.message, decryptedMessage)) return false; if (args.customData && !_.isEqual(txp.customData, args.customData)) return false; return true; }; Verifier.checkTxProposalSignature = function(credentials, txp) { $.checkArgument(txp.creatorId); $.checkState(credentials.isComplete()); var creatorKeys = _.find(credentials.publicKeyRing, function(item) { if (Utils.xPubToCopayerId(item.xPubKey) === txp.creatorId) return true; }); if (!creatorKeys) return false; var creatorSigningPubKey; // If the txp using a selfsigned pub key? if (txp.proposalSignaturePubKey) { // Verify it... if (!Utils.verifyRequestPubKey(txp.proposalSignaturePubKey, txp.proposalSignaturePubKeySig, creatorKeys.xPubKey)) return false; creatorSigningPubKey = txp.proposalSignaturePubKey; } else { creatorSigningPubKey = creatorKeys.requestPubKey; } if (!creatorSigningPubKey) return false; var hash; if (parseInt(txp.version) >= 3) { var t = Utils.buildTx(txp); hash = t.uncheckedSerialize(); } else { throw new Error('Transaction proposal not supported'); } log.debug('Regenerating & verifying tx proposal hash -> Hash: ', hash, ' Signature: ', txp.proposalSignature); if (!Utils.verifyMessage(hash, txp.proposalSignature, creatorSigningPubKey)) return false; if (txp.changeAddress && !Verifier.checkAddress(credentials, txp.changeAddress)) return false; return true; }; Verifier.checkPaypro = function(txp, payproOpts) { var toAddress, amount, feeRate; if (parseInt(txp.version) >= 3) { toAddress = txp.outputs[0].toAddress; amount = txp.amount; if (txp.feePerKb) { feeRate = txp.feePerKb / 1024; } } else { toAddress = txp.toAddress; amount = txp.amount; } // if (feeRate && payproOpts.requiredFeeRate && // feeRate < payproOpts.requiredFeeRate) // return false; return toAddress == payproOpts.toAddress && amount == payproOpts.amount; }; /** * Check transaction proposal * * @param {Function} credentials * @param {Object} txp * @param {Object} Optional: paypro * @param {Boolean} isLegit */ Verifier.checkTxProposal = function(credentials, txp, opts) { opts = opts || {}; if (!this.checkTxProposalSignature(credentials, txp)) return false; if (opts.paypro && !this.checkPaypro(txp, opts.paypro)) return false; return true; }; module.exports = Verifier; },{"./common":5,"./log":11,"digibyte":98,"lodash":211,"preconditions":228}],14:[function(require,module,exports){ try { var asn1 = require('asn1.js'); } catch (e) { var asn1 = require('../..'); } /** * RFC5280 X509 and Extension Definitions */ var rfc5280 = exports; // OIDs var x509OIDs = { '2 5 29 9': 'subjectDirectoryAttributes', '2 5 29 14': 'subjectKeyIdentifier', '2 5 29 15': 'keyUsage', '2 5 29 17': 'subjectAlternativeName', '2 5 29 18': 'issuerAlternativeName', '2 5 29 19': 'basicConstraints', '2 5 29 20': 'cRLNumber', '2 5 29 21': 'reasonCode', '2 5 29 24': 'invalidityDate', '2 5 29 27': 'deltaCRLIndicator', '2 5 29 28': 'issuingDistributionPoint', '2 5 29 29': 'certificateIssuer', '2 5 29 30': 'nameConstraints', '2 5 29 31': 'cRLDistributionPoints', '2 5 29 32': 'certificatePolicies', '2 5 29 33': 'policyMappings', '2 5 29 35': 'authorityKeyIdentifier', '2 5 29 36': 'policyConstraints', '2 5 29 37': 'extendedKeyUsage', '2 5 29 46': 'freshestCRL', '2 5 29 54': 'inhibitAnyPolicy', '1 3 6 1 5 5 7 1 1': 'authorityInformationAccess', '1 3 6 1 5 5 7 11': 'subjectInformationAccess' }; // CertificateList ::= SEQUENCE { // tbsCertList TBSCertList, // signatureAlgorithm AlgorithmIdentifier, // signature BIT STRING } var CertificateList = asn1.define('CertificateList', function() { this.seq().obj( this.key('tbsCertList').use(TBSCertList), this.key('signatureAlgorithm').use(AlgorithmIdentifier), this.key('signature').bitstr() ); }); rfc5280.CertificateList = CertificateList; // AlgorithmIdentifier ::= SEQUENCE { // algorithm OBJECT IDENTIFIER, // parameters ANY DEFINED BY algorithm OPTIONAL } var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function() { this.seq().obj( this.key('algorithm').objid(), this.key('parameters').optional().any() ); }); rfc5280.AlgorithmIdentifier = AlgorithmIdentifier; // Certificate ::= SEQUENCE { // tbsCertificate TBSCertificate, // signatureAlgorithm AlgorithmIdentifier, // signature BIT STRING } var Certificate = asn1.define('Certificate', function() { this.seq().obj( this.key('tbsCertificate').use(TBSCertificate), this.key('signatureAlgorithm').use(AlgorithmIdentifier), this.key('signature').bitstr() ); }); rfc5280.Certificate = Certificate; // TBSCertificate ::= SEQUENCE { // version [0] Version DEFAULT v1, // serialNumber CertificateSerialNumber, // signature AlgorithmIdentifier, // issuer Name, // validity Validity, // subject Name, // subjectPublicKeyInfo SubjectPublicKeyInfo, // issuerUniqueID [1] IMPLICIT UniqueIdentifier OPTIONAL, // subjectUniqueID [2] IMPLICIT UniqueIdentifier OPTIONAL, // extensions [3] Extensions OPTIONAL var TBSCertificate = asn1.define('TBSCertificate', function() { this.seq().obj( this.key('version').def('v1').explicit(0).use(Version), this.key('serialNumber').int(), this.key('signature').use(AlgorithmIdentifier), this.key('issuer').use(Name), this.key('validity').use(Validity), this.key('subject').use(Name), this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo), this.key('issuerUniqueID').optional().implicit(1).bitstr(), this.key('subjectUniqueID').optional().implicit(2).bitstr(), this.key('extensions').optional().explicit(3).seqof(Extension) ); }); rfc5280.TBSCertificate = TBSCertificate; // Version ::= INTEGER { v1(0), v2(1), v3(2) } var Version = asn1.define('Version', function() { this.int({ 0: 'v1', 1: 'v2', 2: 'v3' }); }); rfc5280.Version = Version; // Validity ::= SEQUENCE { // notBefore Time, // notAfter Time } var Validity = asn1.define('Validity', function() { this.seq().obj( this.key('notBefore').use(Time), this.key('notAfter').use(Time) ); }); rfc5280.Validity = Validity; // Time ::= CHOICE { // utcTime UTCTime, // generalTime GeneralizedTime } var Time = asn1.define('Time', function() { this.choice({ utcTime: this.utctime(), genTime: this.gentime() }); }); rfc5280.Time = Time; // SubjectPublicKeyInfo ::= SEQUENCE { // algorithm AlgorithmIdentifier, // subjectPublicKey BIT STRING } var SubjectPublicKeyInfo = asn1.define('SubjectPublicKeyInfo', function() { this.seq().obj( this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPublicKey').bitstr() ); }); rfc5280.SubjectPublicKeyInfo = SubjectPublicKeyInfo; // TBSCertList ::= SEQUENCE { // version Version OPTIONAL, // signature AlgorithmIdentifier, // issuer Name, // thisUpdate Time, // nextUpdate Time OPTIONAL, // revokedCertificates SEQUENCE OF SEQUENCE { // userCertificate CertificateSerialNumber, // revocationDate Time, // crlEntryExtensions Extensions OPTIONAL // } OPTIONAL, // crlExtensions [0] Extensions OPTIONAL } var TBSCertList = asn1.define('TBSCertList', function() { this.seq().obj( this.key('version').optional().int(), this.key('signature').use(AlgorithmIdentifier), this.key('issuer').use(Name), this.key('thisUpdate').use(Time), this.key('nextUpdate').use(Time), this.key('revokedCertificates').optional().seqof(RevokedCertificate), this.key('crlExtensions').explicit(0).optional().seqof(Extension) ); }); rfc5280.TBSCertList = TBSCertList; var RevokedCertificate = asn1.define('RevokedCertificate', function() { this.seq().obj( this.key('userCertificate').use(CertificateSerialNumber), this.key('revocationDate').use(Time), this.key('crlEntryExtensions').optional().seqof(Extension) ) }); // Extension ::= SEQUENCE { // extnID OBJECT IDENTIFIER, // critical BOOLEAN DEFAULT FALSE, // extnValue OCTET STRING } var Extension = asn1.define('Extension', function() { this.seq().obj( this.key('extnID').objid(x509OIDs), this.key('critical').bool().def(false), this.key('extnValue').octstr().contains(function(obj) { var out = x509Extensions[obj.extnID]; // Cope with unknown extensions return out ? out : asn1.define('OctString', function() { this.any() }) }) ); }); rfc5280.Extension = Extension; // Name ::= CHOICE { -- only one possibility for now -- // rdnSequence RDNSequence } var Name = asn1.define('Name', function() { this.choice({ rdnSequence: this.use(RDNSequence) }); }); rfc5280.Name = Name; // GeneralName ::= CHOICE { // otherName [0] AnotherName, // rfc822Name [1] IA5String, // dNSName [2] IA5String, // x400Address [3] ORAddress, // directoryName [4] Name, // ediPartyName [5] EDIPartyName, // uniformResourceIdentifier [6] IA5String, // iPAddress [7] OCTET STRING, // registeredID [8] OBJECT IDENTIFIER } var GeneralName = asn1.define('GeneralName', function() { this.choice({ otherName: this.implicit(0).use(AnotherName), rfc822Name: this.implicit(1).ia5str(), dNSName: this.implicit(2).ia5str(), directoryName: this.explicit(4).use(Name), ediPartyName: this.implicit(5).use(EDIPartyName), uniformResourceIdentifier: this.implicit(6).ia5str(), iPAddress: this.implicit(7).octstr(), registeredID: this.implicit(8).objid() }); }); rfc5280.GeneralName = GeneralName; // GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName var GeneralNames = asn1.define('GeneralNames', function() { this.seqof(GeneralName); }); rfc5280.GeneralNames = GeneralNames; // AnotherName ::= SEQUENCE { // type-id OBJECT IDENTIFIER, // value [0] EXPLICIT ANY DEFINED BY type-id } var AnotherName = asn1.define('AnotherName', function() { this.seq().obj( this.key('type-id').objid(), this.key('value').explicit(0).any() ); }); rfc5280.AnotherName = AnotherName; // EDIPartyName ::= SEQUENCE { // nameAssigner [0] DirectoryString OPTIONAL, // partyName [1] DirectoryString } var EDIPartyName = asn1.define('EDIPartyName', function() { this.seq().obj( this.key('nameAssigner').implicit(0).optional().use(DirectoryString), this.key('partyName').implicit(1).use(DirectoryString) ); }); rfc5280.EDIPartyName = EDIPartyName; // RDNSequence ::= SEQUENCE OF RelativeDistinguishedName var RDNSequence = asn1.define('RDNSequence', function() { this.seqof(RelativeDistinguishedName); }); rfc5280.RDNSequence = RDNSequence; // RelativeDistinguishedName ::= // SET SIZE (1..MAX) OF AttributeTypeAndValue var RelativeDistinguishedName = asn1.define('RelativeDistinguishedName', function() { this.setof(AttributeTypeAndValue); }); rfc5280.RelativeDistinguishedName = RelativeDistinguishedName; // AttributeTypeAndValue ::= SEQUENCE { // type AttributeType, // value AttributeValue } var AttributeTypeAndValue = asn1.define('AttributeTypeAndValue', function() { this.seq().obj( this.key('type').use(AttributeType), this.key('value').use(AttributeValue) ); }); rfc5280.AttributeTypeAndValue = AttributeTypeAndValue; // Attribute ::= SEQUENCE { // type AttributeType, // values SET OF AttributeValue } var Attribute = asn1.define('Attribute', function() { this.seq().obj( this.key('type').use(AttributeType), this.key('values').setof(AttributeValue) ); }); rfc5280.Attribute = Attribute; // AttributeType ::= OBJECT IDENTIFIER var AttributeType = asn1.define('AttributeType', function() { this.objid(); }); rfc5280.AttributeType = AttributeType; // AttributeValue ::= ANY -- DEFINED BY AttributeType var AttributeValue = asn1.define('AttributeValue', function() { this.any(); }); rfc5280.AttributeValue = AttributeValue; // DirectoryString ::= CHOICE { // teletexString TeletexString (SIZE (1..MAX)), // printableString PrintableString (SIZE (1..MAX)), // universalString UniversalString (SIZE (1..MAX)), // utf8String UTF8String (SIZE (1..MAX)), // bmpString BMPString (SIZE (1..MAX)) } var DirectoryString = asn1.define('DirectoryString', function() { this.choice({ teletexString: this.t61str(), printableString: this.printstr(), universalString: this.unistr(), utf8String: this.utf8str(), bmpString: this.bmpstr() }); }); rfc5280.DirectoryString = DirectoryString; // AuthorityKeyIdentifier ::= SEQUENCE { // keyIdentifier [0] KeyIdentifier OPTIONAL, // authorityCertIssuer [1] GeneralNames OPTIONAL, // authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL } var AuthorityKeyIdentifier = asn1.define('AuthorityKeyIdentifier', function() { this.seq().obj( this.key('keyIdentifier').implicit(0).optional().use(KeyIdentifier), this.key('authorityCertIssuer').implicit(1).optional().use(GeneralNames), this.key('authorityCertSerialNumber').implicit(2).optional() .use(CertificateSerialNumber) ); }); rfc5280.AuthorityKeyIdentifier = AuthorityKeyIdentifier; // KeyIdentifier ::= OCTET STRING var KeyIdentifier = asn1.define('KeyIdentifier', function() { this.octstr(); }); rfc5280.KeyIdentifier = KeyIdentifier; // CertificateSerialNumber ::= INTEGER var CertificateSerialNumber = asn1.define('CertificateSerialNumber', function() { this.int(); }); rfc5280.CertificateSerialNumber = CertificateSerialNumber; // ORAddress ::= SEQUENCE { // built-in-standard-attributes BuiltInStandardAttributes, // built-in-domain-defined-attributes BuiltInDomainDefinedAttributes // OPTIONAL, // extension-attributes ExtensionAttributes OPTIONAL } var ORAddress = asn1.define('ORAddress', function() { this.seq().obj( this.key('builtInStandardAttributes').use(BuiltInStandardAttributes), this.key('builtInDomainDefinedAttributes').optional() .use(BuiltInDomainDefinedAttributes), this.key('extensionAttributes').optional().use(ExtensionAttributes) ); }); rfc5280.ORAddress = ORAddress; // BuiltInStandardAttributes ::= SEQUENCE { // country-name CountryName OPTIONAL, // administration-domain-name AdministrationDomainName OPTIONAL, // network-address [0] IMPLICIT NetworkAddress OPTIONAL, // terminal-identifier [1] IMPLICIT TerminalIdentifier OPTIONAL, // private-domain-name [2] PrivateDomainName OPTIONAL, // organization-name [3] IMPLICIT OrganizationName OPTIONAL, // numeric-user-identifier [4] IMPLICIT NumericUserIdentifier OPTIONAL, // personal-name [5] IMPLICIT PersonalName OPTIONAL, // organizational-unit-names [6] IMPLICIT OrganizationalUnitNames OPTIONAL } var BuiltInStandardAttributes = asn1.define('BuiltInStandardAttributes', function() { this.seq().obj( this.key('countryName').optional().use(CountryName), this.key('administrationDomainName').optional() .use(AdministrationDomainName), this.key('networkAddress').implicit(0).optional().use(NetworkAddress), this.key('terminalIdentifier').implicit(1).optional() .use(TerminalIdentifier), this.key('privateDomainName').explicit(2).optional().use(PrivateDomainName), this.key('organizationName').implicit(3).optional().use(OrganizationName), this.key('numericUserIdentifier').implicit(4).optional() .use(NumericUserIdentifier), this.key('personalName').implicit(5).optional().use(PersonalName), this.key('organizationalUnitNames').implicit(6).optional() .use(OrganizationalUnitNames) ); }); rfc5280.BuiltInStandardAttributes = BuiltInStandardAttributes; // CountryName ::= CHOICE { // x121-dcc-code NumericString, // iso-3166-alpha2-code PrintableString } var CountryName = asn1.define('CountryName', function() { this.choice({ x121DccCode: this.numstr(), iso3166Alpha2Code: this.printstr() }); }); rfc5280.CountryName = CountryName; // AdministrationDomainName ::= CHOICE { // numeric NumericString, // printable PrintableString } var AdministrationDomainName = asn1.define('AdministrationDomainName', function() { this.choice({ numeric: this.numstr(), printable: this.printstr() }); }); rfc5280.AdministrationDomainName = AdministrationDomainName; // NetworkAddress ::= X121Address var NetworkAddress = asn1.define('NetworkAddress', function() { this.use(X121Address); }); rfc5280.NetworkAddress = NetworkAddress; // X121Address ::= NumericString var X121Address = asn1.define('X121Address', function() { this.numstr(); }); rfc5280.X121Address = X121Address; // TerminalIdentifier ::= PrintableString var TerminalIdentifier = asn1.define('TerminalIdentifier', function() { this.printstr(); }); rfc5280.TerminalIdentifier = TerminalIdentifier; // PrivateDomainName ::= CHOICE { // numeric NumericString, // printable PrintableString } var PrivateDomainName = asn1.define('PrivateDomainName', function() { this.choice({ numeric: this.numstr(), printable: this.printstr() }); }); rfc5280.PrivateDomainName = PrivateDomainName; // OrganizationName ::= PrintableString var OrganizationName = asn1.define('OrganizationName', function() { this.printstr(); }); rfc5280.OrganizationName = OrganizationName; // NumericUserIdentifier ::= NumericString var NumericUserIdentifier = asn1.define('NumericUserIdentifier', function() { this.numstr(); }); rfc5280.NumericUserIdentifier = NumericUserIdentifier; // PersonalName ::= SET { // surname [0] IMPLICIT PrintableString, // given-name [1] IMPLICIT PrintableString OPTIONAL, // initials [2] IMPLICIT PrintableString OPTIONAL, // generation-qualifier [3] IMPLICIT PrintableString OPTIONAL } var PersonalName = asn1.define('PersonalName', function() { this.set().obj( this.key('surname').implicit(0).printstr(), this.key('givenName').implicit(1).printstr(), this.key('initials').implicit(2).printstr(), this.key('generationQualifier').implicit(3).printstr() ); }); rfc5280.PersonalName = PersonalName; // OrganizationalUnitNames ::= SEQUENCE SIZE (1..ub-organizational-units) // OF OrganizationalUnitName var OrganizationalUnitNames = asn1.define('OrganizationalUnitNames', function() { this.seqof(OrganizationalUnitName); }); rfc5280.OrganizationalUnitNames = OrganizationalUnitNames; // OrganizationalUnitName ::= PrintableString (SIZE // (1..ub-organizational-unit-name-length)) var OrganizationalUnitName = asn1.define('OrganizationalUnitName', function() { this.printstr(); }); rfc5280.OrganizationalUnitName = OrganizationalUnitName; // uiltInDomainDefinedAttributes ::= SEQUENCE SIZE // (1..ub-domain-defined-attributes) // OF BuiltInDomainDefinedAttribute var BuiltInDomainDefinedAttributes = asn1.define( 'BuiltInDomainDefinedAttributes', function() { this.seqof(BuiltInDomainDefinedAttribute); }); rfc5280.BuiltInDomainDefinedAttributes = BuiltInDomainDefinedAttributes; // BuiltInDomainDefinedAttribute ::= SEQUENCE { // type PrintableString (SIZE (1..ub-domain-defined-attribute-type-length)), // value PrintableString (SIZE (1..ub-domain-defined-attribute-value-length)) //} var BuiltInDomainDefinedAttribute = asn1.define('BuiltInDomainDefinedAttribute', function() { this.seq().obj( this.key('type').printstr(), this.key('value').printstr() ); }); rfc5280.BuiltInDomainDefinedAttribute = BuiltInDomainDefinedAttribute; // ExtensionAttributes ::= SET SIZE (1..ub-extension-attributes) OF // ExtensionAttribute var ExtensionAttributes = asn1.define('ExtensionAttributes', function() { this.seqof(ExtensionAttribute); }); rfc5280.ExtensionAttributes = ExtensionAttributes; // ExtensionAttribute ::= SEQUENCE { // extension-attribute-type [0] IMPLICIT INTEGER, // extension-attribute-value [1] ANY DEFINED BY extension-attribute-type } var ExtensionAttribute = asn1.define('ExtensionAttribute', function() { this.seq().obj( this.key('extensionAttributeType').implicit(0).int(), this.key('extensionAttributeValue').any().explicit(1).int() ); }); rfc5280.ExtensionAttribute = ExtensionAttribute; // SubjectKeyIdentifier ::= KeyIdentifier var SubjectKeyIdentifier = asn1.define('SubjectKeyIdentifier', function() { this.use(KeyIdentifier); }); rfc5280.SubjectKeyIdentifier = SubjectKeyIdentifier; // KeyUsage ::= BIT STRING { // digitalSignature (0), // nonRepudiation (1), -- recent editions of X.509 have // -- renamed this bit to contentCommitment // keyEncipherment (2), // dataEncipherment (3), // keyAgreement (4), // keyCertSign (5), // cRLSign (6), // encipherOnly (7), // decipherOnly (8) } var KeyUsage = asn1.define('KeyUsage', function() { this.bitstr(); }); rfc5280.KeyUsage = KeyUsage; // CertificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation var CertificatePolicies = asn1.define('CertificatePolicies', function() { this.seqof(PolicyInformation); }); rfc5280.CertificatePolicies = CertificatePolicies; // PolicyInformation ::= SEQUENCE { // policyIdentifier CertPolicyId, // policyQualifiers SEQUENCE SIZE (1..MAX) OF PolicyQualifierInfo // OPTIONAL } var PolicyInformation = asn1.define('PolicyInformation', function() { this.seq().obj( this.key('policyIdentifier').use(CertPolicyId), this.key('policyQualifiers').optional().use(PolicyQualifiers) ); }); rfc5280.PolicyInformation = PolicyInformation; // CertPolicyId ::= OBJECT IDENTIFIER var CertPolicyId = asn1.define('CertPolicyId', function() { this.objid(); }); rfc5280.CertPolicyId = CertPolicyId; var PolicyQualifiers = asn1.define('PolicyQualifiers', function() { this.seqof(PolicyQualifierInfo); }); rfc5280.PolicyQualifiers = PolicyQualifiers; // PolicyQualifierInfo ::= SEQUENCE { // policyQualifierId PolicyQualifierId, // qualifier ANY DEFINED BY policyQualifierId } var PolicyQualifierInfo = asn1.define('PolicyQualifierInfo', function() { this.seq().obj( this.key('policyQualifierId').use(PolicyQualifierId), this.key('qualifier').any() ); }); rfc5280.PolicyQualifierInfo = PolicyQualifierInfo; // PolicyQualifierId ::= OBJECT IDENTIFIER var PolicyQualifierId = asn1.define('PolicyQualifierId', function() { this.objid(); }); rfc5280.PolicyQualifierId = PolicyQualifierId; // PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE { // issuerDomainPolicy CertPolicyId, // subjectDomainPolicy CertPolicyId } var PolicyMappings = asn1.define('PolicyMappings', function() { this.seqof(PolicyMapping); }); rfc5280.PolicyMappings = PolicyMappings; var PolicyMapping = asn1.define('PolicyMapping', function() { this.seq().obj( this.key('issuerDomainPolicy').use(CertPolicyId), this.key('subjectDomainPolicy').use(CertPolicyId) ); }); rfc5280.PolicyMapping = PolicyMapping; // SubjectAltName ::= GeneralNames var SubjectAlternativeName = asn1.define('SubjectAlternativeName', function() { this.use(GeneralNames); }); rfc5280.SubjectAlternativeName = SubjectAlternativeName; // IssuerAltName ::= GeneralNames var IssuerAlternativeName = asn1.define('IssuerAlternativeName', function() { this.use(GeneralNames); }); rfc5280.IssuerAlternativeName = IssuerAlternativeName; // SubjectDirectoryAttributes ::= SEQUENCE SIZE (1..MAX) OF Attribute var SubjectDirectoryAttributes = asn1.define('SubjectDirectoryAttributes', function() { this.seqof(Attribute); }); rfc5280.SubjectDirectoryAttributes = SubjectDirectoryAttributes; // BasicConstraints ::= SEQUENCE { // cA BOOLEAN DEFAULT FALSE, // pathLenConstraint INTEGER (0..MAX) OPTIONAL } var BasicConstraints = asn1.define('BasicConstraints', function() { this.seq().obj( this.key('cA').bool().def(false), this.key('pathLenConstraint').optional().int() ); }); rfc5280.BasicConstraints = BasicConstraints; // NameConstraints ::= SEQUENCE { // permittedSubtrees [0] GeneralSubtrees OPTIONAL, // excludedSubtrees [1] GeneralSubtrees OPTIONAL } var NameConstraints = asn1.define('NameConstraints', function() { this.seq().obj( this.key('permittedSubtrees').implicit(0).optional().use(GeneralSubtrees), this.key('excludedSubtrees').implicit(1).optional().use(GeneralSubtrees) ); }); rfc5280.NameConstraints = NameConstraints; // GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree var GeneralSubtrees = asn1.define('GeneralSubtrees', function() { this.seqof(GeneralSubtree); }); rfc5280.GeneralSubtrees = GeneralSubtrees; // GeneralSubtree ::= SEQUENCE { // base GeneralName, // minimum [0] BaseDistance DEFAULT 0, // maximum [1] BaseDistance OPTIONAL } var GeneralSubtree = asn1.define('GeneralSubtree', function() { this.seq().obj( this.key('base').use(GeneralName), this.key('minimum').implicit(0).def(0).use(BaseDistance), this.key('maximum').implicit(0).optional().use(BaseDistance) ); }); rfc5280.GeneralSubtree = GeneralSubtree; // BaseDistance ::= INTEGER var BaseDistance = asn1.define('BaseDistance', function() { this.int(); }); rfc5280.BaseDistance = BaseDistance; // PolicyConstraints ::= SEQUENCE { // requireExplicitPolicy [0] SkipCerts OPTIONAL, // inhibitPolicyMapping [1] SkipCerts OPTIONAL } var PolicyConstraints = asn1.define('PolicyConstraints', function() { this.seq().obj( this.key('requireExplicitPolicy').implicit(0).optional().use(SkipCerts), this.key('inhibitPolicyMapping').implicit(1).optional().use(SkipCerts) ); }); rfc5280.PolicyConstraints = PolicyConstraints; // SkipCerts ::= INTEGER var SkipCerts = asn1.define('SkipCerts', function() { this.int(); }); rfc5280.SkipCerts = SkipCerts; // ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId var ExtendedKeyUsage = asn1.define('ExtendedKeyUsage', function() { this.seqof(KeyPurposeId); }); rfc5280.ExtendedKeyUsage = ExtendedKeyUsage; // KeyPurposeId ::= OBJECT IDENTIFIER var KeyPurposeId = asn1.define('KeyPurposeId', function() { this.objid(); }); rfc5280.KeyPurposeId = KeyPurposeId; // RLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint var CRLDistributionPoints = asn1.define('CRLDistributionPoints', function() { this.seqof(DistributionPoint); }); rfc5280.CRLDistributionPoints = CRLDistributionPoints; // DistributionPoint ::= SEQUENCE { // distributionPoint [0] DistributionPointName OPTIONAL, // reasons [1] ReasonFlags OPTIONAL, // cRLIssuer [2] GeneralNames OPTIONAL } var DistributionPoint = asn1.define('DistributionPoint', function() { this.seq().obj( this.key('distributionPoint').optional().explicit(0) .use(DistributionPointName), this.key('reasons').optional().implicit(1).use(ReasonFlags), this.key('cRLIssuer').optional().implicit(2).use(GeneralNames) ); }); rfc5280.DistributionPoint = DistributionPoint; // DistributionPointName ::= CHOICE { // fullName [0] GeneralNames, // nameRelativeToCRLIssuer [1] RelativeDistinguishedName } var DistributionPointName = asn1.define('DistributionPointName', function() { this.choice({ fullName: this.implicit(0).use(GeneralNames), nameRelativeToCRLIssuer: this.implicit(1).use(RelativeDistinguishedName) }); }); rfc5280.DistributionPointName = DistributionPointName; // ReasonFlags ::= BIT STRING { // unused (0), // keyCompromise (1), // cACompromise (2), // affiliationChanged (3), // superseded (4), // cessationOfOperation (5), // certificateHold (6), // privilegeWithdrawn (7), // aACompromise (8) } var ReasonFlags = asn1.define('ReasonFlags', function() { this.bitstr(); }); rfc5280.ReasonFlags = ReasonFlags; // InhibitAnyPolicy ::= SkipCerts var InhibitAnyPolicy = asn1.define('InhibitAnyPolicy', function() { this.use(SkipCerts); }); rfc5280.InhibitAnyPolicy = InhibitAnyPolicy; // FreshestCRL ::= CRLDistributionPoints var FreshestCRL = asn1.define('FreshestCRL', function() { this.use(CRLDistributionPoints); }); rfc5280.FreshestCRL = FreshestCRL; // AuthorityInfoAccessSyntax ::= // SEQUENCE SIZE (1..MAX) OF AccessDescription var AuthorityInfoAccessSyntax = asn1.define('AuthorityInfoAccessSyntax', function() { this.seqof(AccessDescription); }); rfc5280.AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax; // AccessDescription ::= SEQUENCE { // accessMethod OBJECT IDENTIFIER, // accessLocation GeneralName } var AccessDescription = asn1.define('AccessDescription', function() { this.seq().obj( this.key('accessMethod').objid(), this.key('accessLocation').use(GeneralName) ); }); rfc5280.AccessDescription = AccessDescription; // SubjectInfoAccessSyntax ::= // SEQUENCE SIZE (1..MAX) OF AccessDescription var SubjectInformationAccess = asn1.define('SubjectInformationAccess', function() { this.seqof(AccessDescription); }); rfc5280.SubjectInformationAccess = SubjectInformationAccess; /** * CRL Extensions */ // CRLNumber ::= INTEGER var CRLNumber = asn1.define('CRLNumber', function() { this.int(); }); rfc5280.CRLNumber = CRLNumber; var DeltaCRLIndicator = asn1.define('DeltaCRLIndicator', function() { this.use(CRLNumber); }); rfc5280.DeltaCRLIndicator = DeltaCRLIndicator; // IssuingDistributionPoint ::= SEQUENCE { // distributionPoint [0] DistributionPointName OPTIONAL, // onlyContainsUserCerts [1] BOOLEAN DEFAULT FALSE, // onlyContainsCACerts [2] BOOLEAN DEFAULT FALSE, // onlySomeReasons [3] ReasonFlags OPTIONAL, // indirectCRL [4] BOOLEAN DEFAULT FALSE, // onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE } var IssuingDistributionPoint = asn1.define('IssuingDistributionPoint', function() { this.seq().obj( this.key('distributionPoint').explicit(0).optional() .use(DistributionPointName), this.key('onlyContainsUserCerts').implicit(1).def(false).bool(), this.key('onlyContainsCACerts').implicit(2).def(false).bool(), this.key('onlySomeReasons').implicit(3).optional().use(ReasonFlags), this.key('indirectCRL').implicit(4).def(false).bool(), this.key('onlyContainsAttributeCerts').implicit(5).def(false).bool() ); }); rfc5280.IssuingDistributionPoint = IssuingDistributionPoint; // CRLReason ::= ENUMERATED { // unspecified (0), // keyCompromise (1), // cACompromise (2), // affiliationChanged (3), // superseded (4), // cessationOfOperation (5), // certificateHold (6), // -- value 7 is not used // removeFromCRL (8), // privilegeWithdrawn (9), // aACompromise (10) } var ReasonCode = asn1.define('ReasonCode', function() { this.enum({ 0: 'unspecified', 1: 'keyCompromise', 2: 'cACompromise', 3: 'affiliationChanged', 4: 'superseded', 5: 'cessationOfOperation', 6: 'certificateHold', 8: 'removeFromCRL', 9: 'privilegeWithdrawn', 10: 'aACompromise' }); }); rfc5280.ReasonCode = ReasonCode; // InvalidityDate ::= GeneralizedTime var InvalidityDate = asn1.define('InvalidityDate', function() { this.gentime(); }); rfc5280.InvalidityDate = InvalidityDate; // CertificateIssuer ::= GeneralNames var CertificateIssuer = asn1.define('CertificateIssuer', function() { this.use(GeneralNames); }); rfc5280.CertificateIssuer = CertificateIssuer; // OID label to extension model mapping var x509Extensions = { subjectDirectoryAttributes: SubjectDirectoryAttributes, subjectKeyIdentifier: SubjectKeyIdentifier, keyUsage: KeyUsage, subjectAlternativeName: SubjectAlternativeName, issuerAlternativeName: IssuerAlternativeName, basicConstraints: BasicConstraints, cRLNumber: CRLNumber, reasonCode: ReasonCode, invalidityDate: InvalidityDate, deltaCRLIndicator: DeltaCRLIndicator, issuingDistributionPoint: IssuingDistributionPoint, certificateIssuer: CertificateIssuer, nameConstraints: NameConstraints, cRLDistributionPoints: CRLDistributionPoints, certificatePolicies: CertificatePolicies, policyMappings: PolicyMappings, authorityKeyIdentifier: AuthorityKeyIdentifier, policyConstraints: PolicyConstraints, extendedKeyUsage: ExtendedKeyUsage, freshestCRL: FreshestCRL, inhibitAnyPolicy: InhibitAnyPolicy, authorityInformationAccess: AuthorityInfoAccessSyntax, subjectInformationAccess: SubjectInformationAccess }; },{"../..":1,"asn1.js":15}],15:[function(require,module,exports){ var asn1 = exports; asn1.bignum = require('bn.js'); asn1.define = require('./asn1/api').define; asn1.base = require('./asn1/base'); asn1.constants = require('./asn1/constants'); asn1.decoders = require('./asn1/decoders'); asn1.encoders = require('./asn1/encoders'); },{"./asn1/api":16,"./asn1/base":18,"./asn1/constants":22,"./asn1/decoders":24,"./asn1/encoders":27,"bn.js":41}],16:[function(require,module,exports){ var asn1 = require('../asn1'); var inherits = require('inherits'); var api = exports; api.define = function define(name, body) { return new Entity(name, body); }; function Entity(name, body) { this.name = name; this.body = body; this.decoders = {}; this.encoders = {}; }; Entity.prototype._createNamed = function createNamed(base) { var named; try { named = require('vm').runInThisContext( '(function ' + this.name + '(entity) {\n' + ' this._initNamed(entity);\n' + '})' ); } catch (e) { named = function (entity) { this._initNamed(entity); }; } inherits(named, base); named.prototype._initNamed = function initnamed(entity) { base.call(this, entity); }; return new named(this); }; Entity.prototype._getDecoder = function _getDecoder(enc) { enc = enc || 'der'; // Lazily create decoder if (!this.decoders.hasOwnProperty(enc)) this.decoders[enc] = this._createNamed(asn1.decoders[enc]); return this.decoders[enc]; }; Entity.prototype.decode = function decode(data, enc, options) { return this._getDecoder(enc).decode(data, options); }; Entity.prototype._getEncoder = function _getEncoder(enc) { enc = enc || 'der'; // Lazily create encoder if (!this.encoders.hasOwnProperty(enc)) this.encoders[enc] = this._createNamed(asn1.encoders[enc]); return this.encoders[enc]; }; Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) { return this._getEncoder(enc).encode(data, reporter); }; },{"../asn1":15,"inherits":203,"vm":293}],17:[function(require,module,exports){ var inherits = require('inherits'); var Reporter = require('../base').Reporter; var Buffer = require('buffer').Buffer; function DecoderBuffer(base, options) { Reporter.call(this, options); if (!Buffer.isBuffer(base)) { this.error('Input not Buffer'); return; } this.base = base; this.offset = 0; this.length = base.length; } inherits(DecoderBuffer, Reporter); exports.DecoderBuffer = DecoderBuffer; DecoderBuffer.prototype.save = function save() { return { offset: this.offset, reporter: Reporter.prototype.save.call(this) }; }; DecoderBuffer.prototype.restore = function restore(save) { // Return skipped data var res = new DecoderBuffer(this.base); res.offset = save.offset; res.length = this.offset; this.offset = save.offset; Reporter.prototype.restore.call(this, save.reporter); return res; }; DecoderBuffer.prototype.isEmpty = function isEmpty() { return this.offset === this.length; }; DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) { if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true); else return this.error(fail || 'DecoderBuffer overrun'); } DecoderBuffer.prototype.skip = function skip(bytes, fail) { if (!(this.offset + bytes <= this.length)) return this.error(fail || 'DecoderBuffer overrun'); var res = new DecoderBuffer(this.base); // Share reporter state res._reporterState = this._reporterState; res.offset = this.offset; res.length = this.offset + bytes; this.offset += bytes; return res; } DecoderBuffer.prototype.raw = function raw(save) { return this.base.slice(save ? save.offset : this.offset, this.length); } function EncoderBuffer(value, reporter) { if (Array.isArray(value)) { this.length = 0; this.value = value.map(function(item) { if (!(item instanceof EncoderBuffer)) item = new EncoderBuffer(item, reporter); this.length += item.length; return item; }, this); } else if (typeof value === 'number') { if (!(0 <= value && value <= 0xff)) return reporter.error('non-byte EncoderBuffer value'); this.value = value; this.length = 1; } else if (typeof value === 'string') { this.value = value; this.length = Buffer.byteLength(value); } else if (Buffer.isBuffer(value)) { this.value = value; this.length = value.length; } else { return reporter.error('Unsupported type: ' + typeof value); } } exports.EncoderBuffer = EncoderBuffer; EncoderBuffer.prototype.join = function join(out, offset) { if (!out) out = new Buffer(this.length); if (!offset) offset = 0; if (this.length === 0) return out; if (Array.isArray(this.value)) { this.value.forEach(function(item) { item.join(out, offset); offset += item.length; }); } else { if (typeof this.value === 'number') out[offset] = this.value; else if (typeof this.value === 'string') out.write(this.value, offset); else if (Buffer.isBuffer(this.value)) this.value.copy(out, offset); offset += this.length; } return out; }; },{"../base":18,"buffer":75,"inherits":203}],18:[function(require,module,exports){ var base = exports; base.Reporter = require('./reporter').Reporter; base.DecoderBuffer = require('./buffer').DecoderBuffer; base.EncoderBuffer = require('./buffer').EncoderBuffer; base.Node = require('./node'); },{"./buffer":17,"./node":19,"./reporter":20}],19:[function(require,module,exports){ var Reporter = require('../base').Reporter; var EncoderBuffer = require('../base').EncoderBuffer; var DecoderBuffer = require('../base').DecoderBuffer; var assert = require('minimalistic-assert'); // Supported tags var tags = [ 'seq', 'seqof', 'set', 'setof', 'objid', 'bool', 'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc', 'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str', 'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr' ]; // Public methods list var methods = [ 'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice', 'any', 'contains' ].concat(tags); // Overrided methods list var overrided = [ '_peekTag', '_decodeTag', '_use', '_decodeStr', '_decodeObjid', '_decodeTime', '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList', '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime', '_encodeNull', '_encodeInt', '_encodeBool' ]; function Node(enc, parent) { var state = {}; this._baseState = state; state.enc = enc; state.parent = parent || null; state.children = null; // State state.tag = null; state.args = null; state.reverseArgs = null; state.choice = null; state.optional = false; state.any = false; state.obj = false; state.use = null; state.useDecoder = null; state.key = null; state['default'] = null; state.explicit = null; state.implicit = null; state.contains = null; // Should create new instance on each method if (!state.parent) { state.children = []; this._wrap(); } } module.exports = Node; var stateProps = [ 'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice', 'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit', 'implicit', 'contains' ]; Node.prototype.clone = function clone() { var state = this._baseState; var cstate = {}; stateProps.forEach(function(prop) { cstate[prop] = state[prop]; }); var res = new this.constructor(cstate.parent); res._baseState = cstate; return res; }; Node.prototype._wrap = function wrap() { var state = this._baseState; methods.forEach(function(method) { this[method] = function _wrappedMethod() { var clone = new this.constructor(this); state.children.push(clone); return clone[method].apply(clone, arguments); }; }, this); }; Node.prototype._init = function init(body) { var state = this._baseState; assert(state.parent === null); body.call(this); // Filter children state.children = state.children.filter(function(child) { return child._baseState.parent === this; }, this); assert.equal(state.children.length, 1, 'Root node can have only one child'); }; Node.prototype._useArgs = function useArgs(args) { var state = this._baseState; // Filter children and args var children = args.filter(function(arg) { return arg instanceof this.constructor; }, this); args = args.filter(function(arg) { return !(arg instanceof this.constructor); }, this); if (children.length !== 0) { assert(state.children === null); state.children = children; // Replace parent to maintain backward link children.forEach(function(child) { child._baseState.parent = this; }, this); } if (args.length !== 0) { assert(state.args === null); state.args = args; state.reverseArgs = args.map(function(arg) { if (typeof arg !== 'object' || arg.constructor !== Object) return arg; var res = {}; Object.keys(arg).forEach(function(key) { if (key == (key | 0)) key |= 0; var value = arg[key]; res[value] = key; }); return res; }); } }; // // Overrided methods // overrided.forEach(function(method) { Node.prototype[method] = function _overrided() { var state = this._baseState; throw new Error(method + ' not implemented for encoding: ' + state.enc); }; }); // // Public methods // tags.forEach(function(tag) { Node.prototype[tag] = function _tagMethod() { var state = this._baseState; var args = Array.prototype.slice.call(arguments); assert(state.tag === null); state.tag = tag; this._useArgs(args); return this; }; }); Node.prototype.use = function use(item) { assert(item); var state = this._baseState; assert(state.use === null); state.use = item; return this; }; Node.prototype.optional = function optional() { var state = this._baseState; state.optional = true; return this; }; Node.prototype.def = function def(val) { var state = this._baseState; assert(state['default'] === null); state['default'] = val; state.optional = true; return this; }; Node.prototype.explicit = function explicit(num) { var state = this._baseState; assert(state.explicit === null && state.implicit === null); state.explicit = num; return this; }; Node.prototype.implicit = function implicit(num) { var state = this._baseState; assert(state.explicit === null && state.implicit === null); state.implicit = num; return this; }; Node.prototype.obj = function obj() { var state = this._baseState; var args = Array.prototype.slice.call(arguments); state.obj = true; if (args.length !== 0) this._useArgs(args); return this; }; Node.prototype.key = function key(newKey) { var state = this._baseState; assert(state.key === null); state.key = newKey; return this; }; Node.prototype.any = function any() { var state = this._baseState; state.any = true; return this; }; Node.prototype.choice = function choice(obj) { var state = this._baseState; assert(state.choice === null); state.choice = obj; this._useArgs(Object.keys(obj).map(function(key) { return obj[key]; })); return this; }; Node.prototype.contains = function contains(item) { var state = this._baseState; assert(state.use === null); state.contains = item; return this; }; // // Decoding // Node.prototype._decode = function decode(input, options) { var state = this._baseState; // Decode root node if (state.parent === null) return input.wrapResult(state.children[0]._decode(input, options)); var result = state['default']; var present = true; var prevKey = null; if (state.key !== null) prevKey = input.enterKey(state.key); // Check if tag is there if (state.optional) { var tag = null; if (state.explicit !== null) tag = state.explicit; else if (state.implicit !== null) tag = state.implicit; else if (state.tag !== null) tag = state.tag; if (tag === null && !state.any) { // Trial and Error var save = input.save(); try { if (state.choice === null) this._decodeGeneric(state.tag, input, options); else this._decodeChoice(input, options); present = true; } catch (e) { present = false; } input.restore(save); } else { present = this._peekTag(input, tag, state.any); if (input.isError(present)) return present; } } // Push object on stack var prevObj; if (state.obj && present) prevObj = input.enterObject(); if (present) { // Unwrap explicit values if (state.explicit !== null) { var explicit = this._decodeTag(input, state.explicit); if (input.isError(explicit)) return explicit; input = explicit; } var start = input.offset; // Unwrap implicit and normal values if (state.use === null && state.choice === null) { if (state.any) var save = input.save(); var body = this._decodeTag( input, state.implicit !== null ? state.implicit : state.tag, state.any ); if (input.isError(body)) return body; if (state.any) result = input.raw(save); else input = body; } if (options && options.track && state.tag !== null) options.track(input.path(), start, input.length, 'tagged'); if (options && options.track && state.tag !== null) options.track(input.path(), input.offset, input.length, 'content'); // Select proper method for tag if (state.any) result = result; else if (state.choice === null) result = this._decodeGeneric(state.tag, input, options); else result = this._decodeChoice(input, options); if (input.isError(result)) return result; // Decode children if (!state.any && state.choice === null && state.children !== null) { state.children.forEach(function decodeChildren(child) { // NOTE: We are ignoring errors here, to let parser continue with other // parts of encoded data child._decode(input, options); }); } // Decode contained/encoded by schema, only in bit or octet strings if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) { var data = new DecoderBuffer(result); result = this._getUse(state.contains, input._reporterState.obj) ._decode(data, options); } } // Pop object if (state.obj && present) result = input.leaveObject(prevObj); // Set key if (state.key !== null && (result !== null || present === true)) input.leaveKey(prevKey, state.key, result); else if (prevKey !== null) input.exitKey(prevKey); return result; }; Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) { var state = this._baseState; if (tag === 'seq' || tag === 'set') return null; if (tag === 'seqof' || tag === 'setof') return this._decodeList(input, tag, state.args[0], options); else if (/str$/.test(tag)) return this._decodeStr(input, tag, options); else if (tag === 'objid' && state.args) return this._decodeObjid(input, state.args[0], state.args[1], options); else if (tag === 'objid') return this._decodeObjid(input, null, null, options); else if (tag === 'gentime' || tag === 'utctime') return this._decodeTime(input, tag, options); else if (tag === 'null_') return this._decodeNull(input, options); else if (tag === 'bool') return this._decodeBool(input, options); else if (tag === 'objDesc') return this._decodeStr(input, tag, options); else if (tag === 'int' || tag === 'enum') return this._decodeInt(input, state.args && state.args[0], options); if (state.use !== null) { return this._getUse(state.use, input._reporterState.obj) ._decode(input, options); } else { return input.error('unknown tag: ' + tag); } }; Node.prototype._getUse = function _getUse(entity, obj) { var state = this._baseState; // Create altered use decoder if implicit is set state.useDecoder = this._use(entity, obj); assert(state.useDecoder._baseState.parent === null); state.useDecoder = state.useDecoder._baseState.children[0]; if (state.implicit !== state.useDecoder._baseState.implicit) { state.useDecoder = state.useDecoder.clone(); state.useDecoder._baseState.implicit = state.implicit; } return state.useDecoder; }; Node.prototype._decodeChoice = function decodeChoice(input, options) { var state = this._baseState; var result = null; var match = false; Object.keys(state.choice).some(function(key) { var save = input.save(); var node = state.choice[key]; try { var value = node._decode(input, options); if (input.isError(value)) return false; result = { type: key, value: value }; match = true; } catch (e) { input.restore(save); return false; } return true; }, this); if (!match) return input.error('Choice not matched'); return result; }; // // Encoding // Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) { return new EncoderBuffer(data, this.reporter); }; Node.prototype._encode = function encode(data, reporter, parent) { var state = this._baseState; if (state['default'] !== null && state['default'] === data) return; var result = this._encodeValue(data, reporter, parent); if (result === undefined) return; if (this._skipDefault(result, reporter, parent)) return; return result; }; Node.prototype._encodeValue = function encode(data, reporter, parent) { var state = this._baseState; // Decode root node if (state.parent === null) return state.children[0]._encode(data, reporter || new Reporter()); var result = null; // Set reporter to share it with a child class this.reporter = reporter; // Check if data is there if (state.optional && data === undefined) { if (state['default'] !== null) data = state['default'] else return; } // Encode children first var content = null; var primitive = false; if (state.any) { // Anything that was given is translated to buffer result = this._createEncoderBuffer(data); } else if (state.choice) { result = this._encodeChoice(data, reporter); } else if (state.contains) { content = this._getUse(state.contains, parent)._encode(data, reporter); primitive = true; } else if (state.children) { content = state.children.map(function(child) { if (child._baseState.tag === 'null_') return child._encode(null, reporter, data); if (child._baseState.key === null) return reporter.error('Child should have a key'); var prevKey = reporter.enterKey(child._baseState.key); if (typeof data !== 'object') return reporter.error('Child expected, but input is not object'); var res = child._encode(data[child._baseState.key], reporter, data); reporter.leaveKey(prevKey); return res; }, this).filter(function(child) { return child; }); content = this._createEncoderBuffer(content); } else { if (state.tag === 'seqof' || state.tag === 'setof') { // TODO(indutny): this should be thrown on DSL level if (!(state.args && state.args.length === 1)) return reporter.error('Too many args for : ' + state.tag); if (!Array.isArray(data)) return reporter.error('seqof/setof, but data is not Array'); var child = this.clone(); child._baseState.implicit = null; content = this._createEncoderBuffer(data.map(function(item) { var state = this._baseState; return this._getUse(state.args[0], data)._encode(item, reporter); }, child)); } else if (state.use !== null) { result = this._getUse(state.use, parent)._encode(data, reporter); } else { content = this._encodePrimitive(state.tag, data); primitive = true; } } // Encode data itself var result; if (!state.any && state.choice === null) { var tag = state.implicit !== null ? state.implicit : state.tag; var cls = state.implicit === null ? 'universal' : 'context'; if (tag === null) { if (state.use === null) reporter.error('Tag could be ommited only for .use()'); } else { if (state.use === null) result = this._encodeComposite(tag, primitive, cls, content); } } // Wrap in explicit if (state.explicit !== null) result = this._encodeComposite(state.explicit, false, 'context', result); return result; }; Node.prototype._encodeChoice = function encodeChoice(data, reporter) { var state = this._baseState; var node = state.choice[data.type]; if (!node) { assert( false, data.type + ' not found in ' + JSON.stringify(Object.keys(state.choice))); } return node._encode(data.value, reporter); }; Node.prototype._encodePrimitive = function encodePrimitive(tag, data) { var state = this._baseState; if (/str$/.test(tag)) return this._encodeStr(data, tag); else if (tag === 'objid' && state.args) return this._encodeObjid(data, state.reverseArgs[0], state.args[1]); else if (tag === 'objid') return this._encodeObjid(data, null, null); else if (tag === 'gentime' || tag === 'utctime') return this._encodeTime(data, tag); else if (tag === 'null_') return this._encodeNull(); else if (tag === 'int' || tag === 'enum') return this._encodeInt(data, state.args && state.reverseArgs[0]); else if (tag === 'bool') return this._encodeBool(data); else if (tag === 'objDesc') return this._encodeStr(data, tag); else throw new Error('Unsupported tag: ' + tag); }; Node.prototype._isNumstr = function isNumstr(str) { return /^[0-9 ]*$/.test(str); }; Node.prototype._isPrintstr = function isPrintstr(str) { return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str); }; },{"../base":18,"minimalistic-assert":215}],20:[function(require,module,exports){ var inherits = require('inherits'); function Reporter(options) { this._reporterState = { obj: null, path: [], options: options || {}, errors: [] }; } exports.Reporter = Reporter; Reporter.prototype.isError = function isError(obj) { return obj instanceof ReporterError; }; Reporter.prototype.save = function save() { var state = this._reporterState; return { obj: state.obj, pathLen: state.path.length }; }; Reporter.prototype.restore = function restore(data) { var state = this._reporterState; state.obj = data.obj; state.path = state.path.slice(0, data.pathLen); }; Reporter.prototype.enterKey = function enterKey(key) { return this._reporterState.path.push(key); }; Reporter.prototype.exitKey = function exitKey(index) { var state = this._reporterState; state.path = state.path.slice(0, index - 1); }; Reporter.prototype.leaveKey = function leaveKey(index, key, value) { var state = this._reporterState; this.exitKey(index); if (state.obj !== null) state.obj[key] = value; }; Reporter.prototype.path = function path() { return this._reporterState.path.join('/'); }; Reporter.prototype.enterObject = function enterObject() { var state = this._reporterState; var prev = state.obj; state.obj = {}; return prev; }; Reporter.prototype.leaveObject = function leaveObject(prev) { var state = this._reporterState; var now = state.obj; state.obj = prev; return now; }; Reporter.prototype.error = function error(msg) { var err; var state = this._reporterState; var inherited = msg instanceof ReporterError; if (inherited) { err = msg; } else { err = new ReporterError(state.path.map(function(elem) { return '[' + JSON.stringify(elem) + ']'; }).join(''), msg.message || msg, msg.stack); } if (!state.options.partial) throw err; if (!inherited) state.errors.push(err); return err; }; Reporter.prototype.wrapResult = function wrapResult(result) { var state = this._reporterState; if (!state.options.partial) return result; return { result: this.isError(result) ? null : result, errors: state.errors }; }; function ReporterError(path, msg) { this.path = path; this.rethrow(msg); }; inherits(ReporterError, Error); ReporterError.prototype.rethrow = function rethrow(msg) { this.message = msg + ' at: ' + (this.path || '(shallow)'); if (Error.captureStackTrace) Error.captureStackTrace(this, ReporterError); if (!this.stack) { try { // IE only adds stack when thrown throw new Error(this.message); } catch (e) { this.stack = e.stack; } } return this; }; },{"inherits":203}],21:[function(require,module,exports){ var constants = require('../constants'); exports.tagClass = { 0: 'universal', 1: 'application', 2: 'context', 3: 'private' }; exports.tagClassByName = constants._reverse(exports.tagClass); exports.tag = { 0x00: 'end', 0x01: 'bool', 0x02: 'int', 0x03: 'bitstr', 0x04: 'octstr', 0x05: 'null_', 0x06: 'objid', 0x07: 'objDesc', 0x08: 'external', 0x09: 'real', 0x0a: 'enum', 0x0b: 'embed', 0x0c: 'utf8str', 0x0d: 'relativeOid', 0x10: 'seq', 0x11: 'set', 0x12: 'numstr', 0x13: 'printstr', 0x14: 't61str', 0x15: 'videostr', 0x16: 'ia5str', 0x17: 'utctime', 0x18: 'gentime', 0x19: 'graphstr', 0x1a: 'iso646str', 0x1b: 'genstr', 0x1c: 'unistr', 0x1d: 'charstr', 0x1e: 'bmpstr' }; exports.tagByName = constants._reverse(exports.tag); },{"../constants":22}],22:[function(require,module,exports){ var constants = exports; // Helper constants._reverse = function reverse(map) { var res = {}; Object.keys(map).forEach(function(key) { // Convert key to integer if it is stringified if ((key | 0) == key) key = key | 0; var value = map[key]; res[value] = key; }); return res; }; constants.der = require('./der'); },{"./der":21}],23:[function(require,module,exports){ var inherits = require('inherits'); var asn1 = require('../../asn1'); var base = asn1.base; var bignum = asn1.bignum; // Import DER constants var der = asn1.constants.der; function DERDecoder(entity) { this.enc = 'der'; this.name = entity.name; this.entity = entity; // Construct base tree this.tree = new DERNode(); this.tree._init(entity.body); }; module.exports = DERDecoder; DERDecoder.prototype.decode = function decode(data, options) { if (!(data instanceof base.DecoderBuffer)) data = new base.DecoderBuffer(data, options); return this.tree._decode(data, options); }; // Tree methods function DERNode(parent) { base.Node.call(this, 'der', parent); } inherits(DERNode, base.Node); DERNode.prototype._peekTag = function peekTag(buffer, tag, any) { if (buffer.isEmpty()) return false; var state = buffer.save(); var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"'); if (buffer.isError(decodedTag)) return decodedTag; buffer.restore(state); return decodedTag.tag === tag || decodedTag.tagStr === tag || (decodedTag.tagStr + 'of') === tag || any; }; DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) { var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"'); if (buffer.isError(decodedTag)) return decodedTag; var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"'); // Failure if (buffer.isError(len)) return len; if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + 'of' !== tag) { return buffer.error('Failed to match tag: "' + tag + '"'); } if (decodedTag.primitive || len !== null) return buffer.skip(len, 'Failed to match body of: "' + tag + '"'); // Indefinite length... find END tag var state = buffer.save(); var res = this._skipUntilEnd( buffer, 'Failed to skip indefinite length body: "' + this.tag + '"'); if (buffer.isError(res)) return res; len = buffer.offset - state.offset; buffer.restore(state); return buffer.skip(len, 'Failed to match body of: "' + tag + '"'); }; DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) { while (true) { var tag = derDecodeTag(buffer, fail); if (buffer.isError(tag)) return tag; var len = derDecodeLen(buffer, tag.primitive, fail); if (buffer.isError(len)) return len; var res; if (tag.primitive || len !== null) res = buffer.skip(len) else res = this._skipUntilEnd(buffer, fail); // Failure if (buffer.isError(res)) return res; if (tag.tagStr === 'end') break; } }; DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) { var result = []; while (!buffer.isEmpty()) { var possibleEnd = this._peekTag(buffer, 'end'); if (buffer.isError(possibleEnd)) return possibleEnd; var res = decoder.decode(buffer, 'der', options); if (buffer.isError(res) && possibleEnd) break; result.push(res); } return result; }; DERNode.prototype._decodeStr = function decodeStr(buffer, tag) { if (tag === 'bitstr') { var unused = buffer.readUInt8(); if (buffer.isError(unused)) return unused; return { unused: unused, data: buffer.raw() }; } else if (tag === 'bmpstr') { var raw = buffer.raw(); if (raw.length % 2 === 1) return buffer.error('Decoding of string type: bmpstr length mismatch'); var str = ''; for (var i = 0; i < raw.length / 2; i++) { str += String.fromCharCode(raw.readUInt16BE(i * 2)); } return str; } else if (tag === 'numstr') { var numstr = buffer.raw().toString('ascii'); if (!this._isNumstr(numstr)) { return buffer.error('Decoding of string type: ' + 'numstr unsupported characters'); } return numstr; } else if (tag === 'octstr') { return buffer.raw(); } else if (tag === 'objDesc') { return buffer.raw(); } else if (tag === 'printstr') { var printstr = buffer.raw().toString('ascii'); if (!this._isPrintstr(printstr)) { return buffer.error('Decoding of string type: ' + 'printstr unsupported characters'); } return printstr; } else if (/str$/.test(tag)) { return buffer.raw().toString(); } else { return buffer.error('Decoding of string type: ' + tag + ' unsupported'); } }; DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) { var result; var identifiers = []; var ident = 0; while (!buffer.isEmpty()) { var subident = buffer.readUInt8(); ident <<= 7; ident |= subident & 0x7f; if ((subident & 0x80) === 0) { identifiers.push(ident); ident = 0; } } if (subident & 0x80) identifiers.push(ident); var first = (identifiers[0] / 40) | 0; var second = identifiers[0] % 40; if (relative) result = identifiers; else result = [first, second].concat(identifiers.slice(1)); if (values) { var tmp = values[result.join(' ')]; if (tmp === undefined) tmp = values[result.join('.')]; if (tmp !== undefined) result = tmp; } return result; }; DERNode.prototype._decodeTime = function decodeTime(buffer, tag) { var str = buffer.raw().toString(); if (tag === 'gentime') { var year = str.slice(0, 4) | 0; var mon = str.slice(4, 6) | 0; var day = str.slice(6, 8) | 0; var hour = str.slice(8, 10) | 0; var min = str.slice(10, 12) | 0; var sec = str.slice(12, 14) | 0; } else if (tag === 'utctime') { var year = str.slice(0, 2) | 0; var mon = str.slice(2, 4) | 0; var day = str.slice(4, 6) | 0; var hour = str.slice(6, 8) | 0; var min = str.slice(8, 10) | 0; var sec = str.slice(10, 12) | 0; if (year < 70) year = 2000 + year; else year = 1900 + year; } else { return buffer.error('Decoding ' + tag + ' time is not supported yet'); } return Date.UTC(year, mon - 1, day, hour, min, sec, 0); }; DERNode.prototype._decodeNull = function decodeNull(buffer) { return null; }; DERNode.prototype._decodeBool = function decodeBool(buffer) { var res = buffer.readUInt8(); if (buffer.isError(res)) return res; else return res !== 0; }; DERNode.prototype._decodeInt = function decodeInt(buffer, values) { // Bigint, return as it is (assume big endian) var raw = buffer.raw(); var res = new bignum(raw); if (values) res = values[res.toString(10)] || res; return res; }; DERNode.prototype._use = function use(entity, obj) { if (typeof entity === 'function') entity = entity(obj); return entity._getDecoder('der').tree; }; // Utility methods function derDecodeTag(buf, fail) { var tag = buf.readUInt8(fail); if (buf.isError(tag)) return tag; var cls = der.tagClass[tag >> 6]; var primitive = (tag & 0x20) === 0; // Multi-octet tag - load if ((tag & 0x1f) === 0x1f) { var oct = tag; tag = 0; while ((oct & 0x80) === 0x80) { oct = buf.readUInt8(fail); if (buf.isError(oct)) return oct; tag <<= 7; tag |= oct & 0x7f; } } else { tag &= 0x1f; } var tagStr = der.tag[tag]; return { cls: cls, primitive: primitive, tag: tag, tagStr: tagStr }; } function derDecodeLen(buf, primitive, fail) { var len = buf.readUInt8(fail); if (buf.isError(len)) return len; // Indefinite form if (!primitive && len === 0x80) return null; // Definite form if ((len & 0x80) === 0) { // Short form return len; } // Long form var num = len & 0x7f; if (num > 4) return buf.error('length octect is too long'); len = 0; for (var i = 0; i < num; i++) { len <<= 8; var j = buf.readUInt8(fail); if (buf.isError(j)) return j; len |= j; } return len; } },{"../../asn1":15,"inherits":203}],24:[function(require,module,exports){ var decoders = exports; decoders.der = require('./der'); decoders.pem = require('./pem'); },{"./der":23,"./pem":25}],25:[function(require,module,exports){ var inherits = require('inherits'); var Buffer = require('buffer').Buffer; var DERDecoder = require('./der'); function PEMDecoder(entity) { DERDecoder.call(this, entity); this.enc = 'pem'; }; inherits(PEMDecoder, DERDecoder); module.exports = PEMDecoder; PEMDecoder.prototype.decode = function decode(data, options) { var lines = data.toString().split(/[\r\n]+/g); var label = options.label.toUpperCase(); var re = /^-----(BEGIN|END) ([^-]+)-----$/; var start = -1; var end = -1; for (var i = 0; i < lines.length; i++) { var match = lines[i].match(re); if (match === null) continue; if (match[2] !== label) continue; if (start === -1) { if (match[1] !== 'BEGIN') break; start = i; } else { if (match[1] !== 'END') break; end = i; break; } } if (start === -1 || end === -1) throw new Error('PEM section not found for: ' + label); var base64 = lines.slice(start + 1, end).join(''); // Remove excessive symbols base64.replace(/[^a-z0-9\+\/=]+/gi, ''); var input = new Buffer(base64, 'base64'); return DERDecoder.prototype.decode.call(this, input, options); }; },{"./der":23,"buffer":75,"inherits":203}],26:[function(require,module,exports){ var inherits = require('inherits'); var Buffer = require('buffer').Buffer; var asn1 = require('../../asn1'); var base = asn1.base; // Import DER constants var der = asn1.constants.der; function DEREncoder(entity) { this.enc = 'der'; this.name = entity.name; this.entity = entity; // Construct base tree this.tree = new DERNode(); this.tree._init(entity.body); }; module.exports = DEREncoder; DEREncoder.prototype.encode = function encode(data, reporter) { return this.tree._encode(data, reporter).join(); }; // Tree methods function DERNode(parent) { base.Node.call(this, 'der', parent); } inherits(DERNode, base.Node); DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) { var encodedTag = encodeTag(tag, primitive, cls, this.reporter); // Short form if (content.length < 0x80) { var header = new Buffer(2); header[0] = encodedTag; header[1] = content.length; return this._createEncoderBuffer([ header, content ]); } // Long form // Count octets required to store length var lenOctets = 1; for (var i = content.length; i >= 0x100; i >>= 8) lenOctets++; var header = new Buffer(1 + 1 + lenOctets); header[0] = encodedTag; header[1] = 0x80 | lenOctets; for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8) header[i] = j & 0xff; return this._createEncoderBuffer([ header, content ]); }; DERNode.prototype._encodeStr = function encodeStr(str, tag) { if (tag === 'bitstr') { return this._createEncoderBuffer([ str.unused | 0, str.data ]); } else if (tag === 'bmpstr') { var buf = new Buffer(str.length * 2); for (var i = 0; i < str.length; i++) { buf.writeUInt16BE(str.charCodeAt(i), i * 2); } return this._createEncoderBuffer(buf); } else if (tag === 'numstr') { if (!this._isNumstr(str)) { return this.reporter.error('Encoding of string type: numstr supports ' + 'only digits and space'); } return this._createEncoderBuffer(str); } else if (tag === 'printstr') { if (!this._isPrintstr(str)) { return this.reporter.error('Encoding of string type: printstr supports ' + 'only latin upper and lower case letters, ' + 'digits, space, apostrophe, left and rigth ' + 'parenthesis, plus sign, comma, hyphen, ' + 'dot, slash, colon, equal sign, ' + 'question mark'); } return this._createEncoderBuffer(str); } else if (/str$/.test(tag)) { return this._createEncoderBuffer(str); } else if (tag === 'objDesc') { return this._createEncoderBuffer(str); } else { return this.reporter.error('Encoding of string type: ' + tag + ' unsupported'); } }; DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) { if (typeof id === 'string') { if (!values) return this.reporter.error('string objid given, but no values map found'); if (!values.hasOwnProperty(id)) return this.reporter.error('objid not found in values map'); id = values[id].split(/[\s\.]+/g); for (var i = 0; i < id.length; i++) id[i] |= 0; } else if (Array.isArray(id)) { id = id.slice(); for (var i = 0; i < id.length; i++) id[i] |= 0; } if (!Array.isArray(id)) { return this.reporter.error('objid() should be either array or string, ' + 'got: ' + JSON.stringify(id)); } if (!relative) { if (id[1] >= 40) return this.reporter.error('Second objid identifier OOB'); id.splice(0, 2, id[0] * 40 + id[1]); } // Count number of octets var size = 0; for (var i = 0; i < id.length; i++) { var ident = id[i]; for (size++; ident >= 0x80; ident >>= 7) size++; } var objid = new Buffer(size); var offset = objid.length - 1; for (var i = id.length - 1; i >= 0; i--) { var ident = id[i]; objid[offset--] = ident & 0x7f; while ((ident >>= 7) > 0) objid[offset--] = 0x80 | (ident & 0x7f); } return this._createEncoderBuffer(objid); }; function two(num) { if (num < 10) return '0' + num; else return num; } DERNode.prototype._encodeTime = function encodeTime(time, tag) { var str; var date = new Date(time); if (tag === 'gentime') { str = [ two(date.getFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z' ].join(''); } else if (tag === 'utctime') { str = [ two(date.getFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z' ].join(''); } else { this.reporter.error('Encoding ' + tag + ' time is not supported yet'); } return this._encodeStr(str, 'octstr'); }; DERNode.prototype._encodeNull = function encodeNull() { return this._createEncoderBuffer(''); }; DERNode.prototype._encodeInt = function encodeInt(num, values) { if (typeof num === 'string') { if (!values) return this.reporter.error('String int or enum given, but no values map'); if (!values.hasOwnProperty(num)) { return this.reporter.error('Values map doesn\'t contain: ' + JSON.stringify(num)); } num = values[num]; } // Bignum, assume big endian if (typeof num !== 'number' && !Buffer.isBuffer(num)) { var numArray = num.toArray(); if (!num.sign && numArray[0] & 0x80) { numArray.unshift(0); } num = new Buffer(numArray); } if (Buffer.isBuffer(num)) { var size = num.length; if (num.length === 0) size++; var out = new Buffer(size); num.copy(out); if (num.length === 0) out[0] = 0 return this._createEncoderBuffer(out); } if (num < 0x80) return this._createEncoderBuffer(num); if (num < 0x100) return this._createEncoderBuffer([0, num]); var size = 1; for (var i = num; i >= 0x100; i >>= 8) size++; var out = new Array(size); for (var i = out.length - 1; i >= 0; i--) { out[i] = num & 0xff; num >>= 8; } if(out[0] & 0x80) { out.unshift(0); } return this._createEncoderBuffer(new Buffer(out)); }; DERNode.prototype._encodeBool = function encodeBool(value) { return this._createEncoderBuffer(value ? 0xff : 0); }; DERNode.prototype._use = function use(entity, obj) { if (typeof entity === 'function') entity = entity(obj); return entity._getEncoder('der').tree; }; DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) { var state = this._baseState; var i; if (state['default'] === null) return false; var data = dataBuffer.join(); if (state.defaultBuffer === undefined) state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join(); if (data.length !== state.defaultBuffer.length) return false; for (i=0; i < data.length; i++) if (data[i] !== state.defaultBuffer[i]) return false; return true; }; // Utility methods function encodeTag(tag, primitive, cls, reporter) { var res; if (tag === 'seqof') tag = 'seq'; else if (tag === 'setof') tag = 'set'; if (der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag]; else if (typeof tag === 'number' && (tag | 0) === tag) res = tag; else return reporter.error('Unknown tag: ' + tag); if (res >= 0x1f) return reporter.error('Multi-octet tag encoding unsupported'); if (!primitive) res |= 0x20; res |= (der.tagClassByName[cls || 'universal'] << 6); return res; } },{"../../asn1":15,"buffer":75,"inherits":203}],27:[function(require,module,exports){ var encoders = exports; encoders.der = require('./der'); encoders.pem = require('./pem'); },{"./der":26,"./pem":28}],28:[function(require,module,exports){ var inherits = require('inherits'); var DEREncoder = require('./der'); function PEMEncoder(entity) { DEREncoder.call(this, entity); this.enc = 'pem'; }; inherits(PEMEncoder, DEREncoder); module.exports = PEMEncoder; PEMEncoder.prototype.encode = function encode(data, options) { var buf = DEREncoder.prototype.encode.call(this, data); var p = buf.toString('base64'); var out = [ '-----BEGIN ' + options.label + '-----' ]; for (var i = 0; i < p.length; i += 64) out.push(p.slice(i, i + 64)); out.push('-----END ' + options.label + '-----'); return out.join('\n'); }; },{"./der":26,"inherits":203}],29:[function(require,module,exports){ (function (global){ 'use strict'; var objectAssign = require('object-assign'); // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js // original notice: /*! * The buffer module from node.js, for the browser. * * @author Feross Aboukhadijeh <feross@feross.org> <http://feross.org> * @license MIT */ function compare(a, b) { if (a === b) { return 0; } var x = a.length; var y = b.length; for (var i = 0, len = Math.min(x, y); i < len; ++i) { if (a[i] !== b[i]) { x = a[i]; y = b[i]; break; } } if (x < y) { return -1; } if (y < x) { return 1; } return 0; } function isBuffer(b) { if (global.Buffer && typeof global.Buffer.isBuffer === 'function') { return global.Buffer.isBuffer(b); } return !!(b != null && b._isBuffer); } // based on node assert, original notice: // NB: The URL to the CommonJS spec is kept just for tradition. // node-assert has evolved a lot since then, both in API and behavior. // http://wiki.commonjs.org/wiki/Unit_Testing/1.0 // // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8! // // Originally from narwhal.js (http://narwhaljs.org) // Copyright (c) 2009 Thomas Robinson <280north.com> // // Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the 'Software'), to // deal in the Software without restriction, including without limitation the // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or // sell copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions: // // The above copyright notice and this permission notice shall be included in // all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. var util = require('util/'); var hasOwn = Object.prototype.hasOwnProperty; var pSlice = Array.prototype.slice; var functionsHaveNames = (function () { return function foo() {}.name === 'foo'; }()); function pToString (obj) { return Object.prototype.toString.call(obj); } function isView(arrbuf) { if (isBuffer(arrbuf)) { return false; } if (typeof global.ArrayBuffer !== 'function') { return false; } if (typeof ArrayBuffer.isView === 'function') { return ArrayBuffer.isView(arrbuf); } if (!arrbuf) { return false; } if (arrbuf instanceof DataView) { return true; } if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) { return true; } return false; } // 1. The assert module provides functions that throw // AssertionError's when particular conditions are not met. The // assert module must conform to the following interface. var assert = module.exports = ok; // 2. The AssertionError is defined in assert. // new assert.AssertionError({ message: message, // actual: actual, // expected: expected }) var regex = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js function getName(func) { if (!util.isFunction(func)) { return; } if (functionsHaveNames) { return func.name; } var str = func.toString(); var match = str.match(regex); return match && match[1]; } assert.AssertionError = function AssertionError(options) { this.name = 'AssertionError'; this.actual = options.actual; this.expected = options.expected; this.operator = options.operator; if (options.message) { this.message = options.message; this.generatedMessage = false; } else { this.message = getMessage(this); this.generatedMessage = true; } var stackStartFunction = options.stackStartFunction || fail; if (Error.captureStackTrace) { Error.captureStackTrace(this, stackStartFunction); } else { // non v8 browsers so we can have a stacktrace var err = new Error(); if (err.stack) { var out = err.stack; // try to strip useless frames var fn_name = getName(stackStartFunction); var idx = out.indexOf('\n' + fn_name); if (idx >= 0) { // once we have located the function frame // we need to strip out everything before it (and its line) var next_line = out.indexOf('\n', idx + 1); out = out.substring(next_line + 1); } this.stack = out; } } }; // assert.AssertionError instanceof Error util.inherits(assert.AssertionError, Error); function truncate(s, n) { if (typeof s === 'string') { return s.length < n ? s : s.slice(0, n); } else { return s; } } function inspect(something) { if (functionsHaveNames || !util.isFunction(something)) { return util.inspect(something); } var rawname = getName(something); var name = rawname ? ': ' + rawname : ''; return '[Function' + name + ']'; } function getMessage(self) { return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128); } // At present only the three keys mentioned above are used and // understood by the spec. Implementations or sub modules can pass // other keys to the AssertionError's constructor - they will be // ignored. // 3. All of the following functions must throw an AssertionError // when a corresponding condition is not met, with a message that // may be undefined if not provided. All assertion methods provide // both the actual and expected values to the assertion error for // display purposes. function fail(actual, expected, message, operator, stackStartFunction) { throw new assert.AssertionError({ message: message, actual: actual, expected: expected, operator: operator, stackStartFunction: stackStartFunction }); } // EXTENSION! allows for well behaved errors defined elsewhere. assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined // by !!guard. // assert.ok(guard, message_opt); // This statement is equivalent to assert.equal(true, !!guard, // message_opt);. To test strictly for the value true, use // assert.strictEqual(true, guard, message_opt);. function ok(value, message) { if (!value) fail(value, true, message, '==', assert.ok); } assert.ok = ok; // 5. The equality assertion tests shallow, coercive equality with // ==. // assert.equal(actual, expected, message_opt); assert.equal = function equal(actual, expected, message) { if (actual != expected) fail(actual, expected, message, '==', assert.equal); }; // 6. The non-equality assertion tests for whether two objects are not equal // with != assert.notEqual(actual, expected, message_opt); assert.notEqual = function notEqual(actual, expected, message) { if (actual == expected) { fail(actual, expected, message, '!=', assert.notEqual); } }; // 7. The equivalence assertion tests a deep equality relation. // assert.deepEqual(actual, expected, message_opt); assert.deepEqual = function deepEqual(actual, expected, message) { if (!_deepEqual(actual, expected, false)) { fail(actual, expected, message, 'deepEqual', assert.deepEqual); } }; assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) { if (!_deepEqual(actual, expected, true)) { fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual); } }; function _deepEqual(actual, expected, strict, memos) { // 7.1. All identical values are equivalent, as determined by ===. if (actual === expected) { return true; } else if (isBuffer(actual) && isBuffer(expected)) { return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is // equivalent if it is also a Date object that refers to the same time. } else if (util.isDate(actual) && util.isDate(expected)) { return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is // equivalent if it is also a RegExp object with the same source and // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`). } else if (util.isRegExp(actual) && util.isRegExp(expected)) { return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object', // equivalence is determined by ==. } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) { return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying // ArrayBuffers in a Buffer each to increase performance // This optimization requires the arrays to have the same type as checked by // Object.prototype.toString (aka pToString). Never perform binary // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their // bit patterns are not identical. } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) { return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is // determined by having the same number of owned properties (as verified // with Object.prototype.hasOwnProperty.call), the same set of keys // (although not necessarily the same order), equivalent values for every // corresponding key, and an identical 'prototype' property. Note: this // accounts for both named and indexed properties on Arrays. } else if (isBuffer(actual) !== isBuffer(expected)) { return false; } else { memos = memos || {actual: [], expected: []}; var actualIndex = memos.actual.indexOf(actual); if (actualIndex !== -1) { if (actualIndex === memos.expected.indexOf(expected)) { return true; } } memos.actual.push(actual); memos.expected.push(expected); return objEquiv(actual, expected, strict, memos); } } function isArguments(object) { return Object.prototype.toString.call(object) == '[object Arguments]'; } function objEquiv(a, b, strict, actualVisitedObjects) { if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b; if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false; var aIsArgs = isArguments(a); var bIsArgs = isArguments(b); if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs)) return false; if (aIsArgs) { a = pSlice.call(a); b = pSlice.call(b); return _deepEqual(a, b, strict); } var ka = objectKeys(a); var kb = objectKeys(b); var key, i; // having the same number of owned properties (keys incorporates // hasOwnProperty) if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order), ka.sort(); kb.sort(); //~~~cheap key test for (i = ka.length - 1; i >= 0; i--) { if (ka[i] !== kb[i]) return false; } //equivalent values for every corresponding key, and //~~~possibly expensive deep test for (i = ka.length - 1; i >= 0; i--) { key = ka[i]; if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false; } return true; } // 8. The non-equivalence assertion tests for any deep inequality. // assert.notDeepEqual(actual, expected, message_opt); assert.notDeepEqual = function notDeepEqual(actual, expected, message) { if (_deepEqual(actual, expected, false)) { fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual); } }; assert.notDeepStrictEqual = notDeepStrictEqual; function notDeepStrictEqual(actual, expected, message) { if (_deepEqual(actual, expected, true)) { fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual); } } // 9. The strict equality assertion tests strict equality, as determined by ===. // assert.strictEqual(actual, expected, message_opt); assert.strictEqual = function strictEqual(actual, expected, message) { if (actual !== expected) { fail(actual, expected, message, '===', assert.strictEqual); } }; // 10. The strict non-equality assertion tests for strict inequality, as // determined by !==. assert.notStrictEqual(actual, expected, message_opt); assert.notStrictEqual = function notStrictEqual(actual, expected, message) { if (actual === expected) { fail(actual, expected, message, '!==', assert.notStrictEqual); } }; function expectedException(actual, expected) { if (!actual || !expected) { return false; } if (Object.prototype.toString.call(expected) == '[object RegExp]') { return expected.test(actual); } try { if (actual instanceof expected) { return true; } } catch (e) { // Ignore. The instanceof check doesn't work for arrow functions. } if (Error.isPrototypeOf(expected)) { return false; } return expected.call({}, actual) === true; } function _tryBlock(block) { var error; try { block(); } catch (e) { error = e; } return error; } function _throws(shouldThrow, block, expected, message) { var actual; if (typeof block !== 'function') { throw new TypeError('"block" argument must be a function'); } if (typeof expected === 'string') { message = expected; expected = null; } actual = _tryBlock(block); message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.'); if (shouldThrow && !actual) { fail(actual, expected, 'Missing expected exception' + message); } var userProvidedMessage = typeof message === 'string'; var isUnwantedException = !shouldThrow && util.isError(actual); var isUnexpectedException = !shouldThrow && actual && !expected; if ((isUnwantedException && userProvidedMessage && expectedException(actual, expected)) || isUnexpectedException) { fail(actual, expected, 'Got unwanted exception' + message); } if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) { throw actual; } } // 11. Expected to throw an error: // assert.throws(block, Error_opt, message_opt); assert.throws = function(block, /*optional*/error, /*optional*/message) { _throws(true, block, error, message); }; // EXTENSION! This is annoying to write outside this module. assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) { _throws(false, block, error, message); }; assert.ifError = function(err) { if (err) throw err; }; // Expose a strict only variant of assert function strict(value, message) { if (!value) fail(value, true, message, '==', strict); } assert.strict = objectAssign(strict, assert, { equal: assert.strictEqual, deepEqual: assert.deepStrictEqual, notEqual: assert.notStrictEqual, notDeepEqual: assert.notDeepStrictEqual }); assert.strict.strict = assert.strict; var objectKeys = Object.keys || function (obj) { var keys = []; for (var key in obj) { if (hasOwn.call(obj, key)) keys.push(key); } return keys; }; }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}) },{"object-assign":217,"util/":32}],30:[function(require,module,exports){ if (typeof Object.create === 'function') { // implementation from standard node.js 'util' module module.exports = function inherits(ctor, superCtor) { ctor.super_ = superCtor ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } }); }; } else { // old school shim for old browsers module.exports = function inherits(ctor, superCtor) { ctor.super_ = superCtor var TempCtor = function () {} TempCtor.prototype = superCtor.prototype ctor.prototype = new TempCtor() ctor.prototype.constructor = ctor } } },{}],31:[function(require,module,exports){ module.exports = function isBuffer(arg) { return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function'; } },{}],32:[function(require,module,exports){ (function (process,global){ // Copyright Joyent, Inc. and other Node contributors. // // Permission is hereby granted, free of charge, to any person obtaining a // copy of this software and associated documentation files (the // "Software"), to deal in the Software without restriction, including // without limitation the rights to use, copy, modify, merge, publish, // distribute, sublicense, and/or sell copies of the Software, and to permit // persons to whom the Software is furnished to do so, subject to the // following conditions: // // The above copyright notice and this permission notice shall be included // in all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE // USE OR OTHER DEALINGS IN THE SOFTWARE. var formatRegExp = /%[sdj%]/g; exports.format = function(f) { if (!isString(f)) { var objects = []; for (var i = 0; i < arguments.length; i++) { objects.push(inspect(arguments[i])); } return objects.join(' '); } var i = 1; var args = arguments; var len = args.length; var str = String(f).replace(formatRegExp, function(x) { if (x === '%%') return '%'; if (i >= len) return x; switch (x) { case '%s': return String(args[i++]); case '%d': return Number(args[i++]); case '%j': try { return JSON.stringify(args[i++]); } catch (_) { return '[Circular]'; } default: return x; } }); for (var x = args[i]; i < len; x = args[++i]) { if (isNull(x) || !isObject(x)) { str += ' ' + x; } else { str += ' ' + inspect(x); } } return str; }; // Mark that a method should not be used. // Returns a modified function which warns once by default. // If --no-deprecation is set, then it is a no-op. exports.deprecate = function(fn, msg) { // Allow for deprecating things in the process of starting up. if (isUndefined(global.process)) { return function() { return exports.deprecate(fn, msg).apply(this, arguments); }; } if (process.noDeprecation === true) { return fn; } var warned = false; function deprecated() { if (!warned) { if (process.throwDeprecation) { throw new Error(msg); } else if (process.traceDeprecation) { console.trace(msg); } else { console.error(msg); } warned = true; } return fn.apply(this, arguments); } return deprecated; }; var debugs = {}; var debugEnviron; exports.debuglog = function(set) { if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || ''; set = set.toUpperCase(); if (!debugs[set]) { if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) { var pid = process.pid; debugs[set] = function() { var msg = exports.format.apply(exports, arguments); console.error('%s %d: %s', set, pid, msg); }; } else { debugs[set] = function() {}; } } return debugs[set]; }; /** * Echos the value of a value. Trys to print the value out * in the best way possible given the different types. * * @param {Object} obj The object to print out. * @param {Object} opts Optional options object that alters the output. */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) { // default options var ctx = { seen: [], stylize: stylizeNoColor }; // legacy... if (arguments.length >= 3) ctx.depth = arguments[2]; if (arguments.length >= 4) ctx.colors = arguments[3]; if (isBoolean(opts)) { // legacy... ctx.showHidden = opts; } else if (opts) { // got an "options" object exports._extend(ctx, opts); } // set default options if (isUndefined(ctx.showHidden)) ctx.showHidden = false; if (isUndefined(ctx.depth)) ctx.depth = 2; if (isUndefined(ctx.colors)) ctx.colors = false; if (isUndefined(ctx.customInspect)) ctx.customInspect = true; if (ctx.colors) ctx.stylize = stylizeWithColor; return formatValue(ctx, obj, ctx.depth); } exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics inspect.colors = { 'bold' : [1, 22], 'italic' : [3, 23], 'underline' : [4, 24], 'inverse' : [7, 27], 'white' : [37, 39], 'grey' : [90, 39], 'black' : [30, 39], 'blue' : [34, 39], 'cyan' : [36, 39], 'green' : [32, 39], 'magenta' : [35, 39], 'red' : [31, 39], 'yellow' : [33, 39] }; // Don't use 'blue' not visible on cmd.exe inspect.styles = { 'special': 'cyan', 'number': 'yellow', 'boolean': 'yellow', 'undefined': 'grey', 'null': 'bold', 'string': 'green', 'date': 'magenta', // "name": intentionally not styling 'regexp': 'red' }; function stylizeWithColor(str, styleType) { var style = inspect.styles[styleType]; if (style) { return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm'; } else { return str; } } function stylizeNoColor(str, styleType) { return str; } function arrayToHash(array) { var hash = {}; array.forEach(function(val, idx) { hash[val] = true; }); return hash; } function formatValue(ctx, value, recurseTimes) { // Provide a hook for user-specified inspect functions. // Check that value is an object with an inspect function on it if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check. !(value.constructor && value.constructor.prototype === value)) { var ret = value.inspect(recurseTimes, ctx); if (!isString(ret)) { ret = formatValue(ctx, ret, recurseTimes); } return ret; } // Primitive types cannot have properties var primitive = formatPrimitive(ctx, value); if (primitive) { return primitive; } // Look up the keys of the object. var keys = Object.keys(value); var visibleKeys = arrayToHash(keys); if (ctx.showHidden) { keys = Object.getOwnPropertyNames(value); } // IE doesn't make error fields non-enumerable // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) { return formatError(value); } // Some type of object without properties can be shortcutted. if (keys.length === 0) { if (isFunction(value)) { var name = value.name ? ': ' + value.name : ''; return ctx.stylize('[Function' + name + ']', 'special'); } if (isRegExp(value)) { return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp'); } if (isDate(value)) { return ctx.stylize(Date.prototype.toString.call(value), 'date'); } if (isError(value)) { return formatError(value); } } var base = '', array = false, braces = ['{', '}']; // Make Array say that they are Array if (isArray(value)) { array = true; braces = ['[', ']']; } // Make functions say that they are functions if (isFunction(value)) { var n = value.name ? ': ' + value.name : ''; base = ' [Function' + n + ']'; } // Make RegExps say that they are RegExps if (isRegExp(value)) { base = ' ' + RegExp.prototype.toString.call(value); } // Make dates with properties first say the date if (isDate(value)) { base = ' ' + Date.prototype.toUTCString.call(value); } // Make error with message first say the error if (isError(value)) { base = ' ' + formatError(value); } if (keys.length === 0 && (!array || value.length == 0)) { return braces[0] + base + braces[1]; } if (recurseTimes < 0) { if (isRegExp(value)) { return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp'); } else { return ctx.stylize('[Object]', 'special'); } } ctx.seen.push(value); var output; if (array) { output = formatArray(ctx, value, recurseTimes, visibleKeys, keys); } else { output = keys.map(function(key) { return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array); }); } ctx.seen.pop(); return reduceToSingleString(output, base, braces); } function formatPrimitive(ctx, value) { if (isUndefined(value)) return ctx.stylize('undefined', 'undefined'); if (isString(value)) { var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '') .replace(/'/g, "\\'") .replace(/\\"/g, '"') + '\''; return ctx.stylize(simple, 'string'); } if (isNumber(value)) return ctx.stylize('' + value, 'number'); if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here. if (isNull(value)) return ctx.stylize('null', 'null'); } function formatError(value) { return '[' + Error.prototype.toString.call(value) + ']'; } function formatArray(ctx, value, recurseTimes, visibleKeys, keys) { var output = []; for (var i = 0, l = value.length; i < l; ++i) { if (hasOwnProperty(value, String(i))) { output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true)); } else { output.push(''); } } keys.forEach(function(key) { if (!key.match(/^\d+$/)) { output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true)); } }); return output; } function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) { var name, str, desc; desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }; if (desc.get) { if (desc.set) { str = ctx.stylize('[Getter/Setter]', 'special'); } else { str = ctx.stylize('[Getter]', 'special'); } } else { if (desc.set) { str = ctx.stylize('[Setter]', 'special'); } } if (!hasOwnProperty(visibleKeys, key)) { name = '[' + key + ']'; } if (!str) { if (ctx.seen.indexOf(desc.value) < 0) { if (isNull(recurseTimes)) { str = formatValue(ctx, desc.value, null); } else { str = formatValue(ctx, desc.value, recurseTimes - 1); } if (str.indexOf('\n') > -1) { if (array) { str = str.split('\n').map(function(line) { return ' ' + line; }).join('\n').substr(2); } else { str = '\n' + str.split('\n').map(function(line) { return ' ' + line; }).join('\n'); } } } else { str = ctx.stylize('[Circular]', 'special'); } } if (isUndefined(name)) { if (array && key.match(/^\d+$/)) { return str; } name = JSON.stringify('' + key); if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) { name = name.substr(1, name.length - 2); name = ctx.stylize(name, 'name'); } else { name = name.replace(/'/g, "\\'") .replace(/\\"/g, '"') .replace(/(^"|"$)/g, "'"); name = ctx.stylize(name, 'string'); } } return name + ': ' + str; } function reduceToSingleString(output, base, braces) { var numLinesEst = 0; var length = output.reduce(function(prev, cur) { numLinesEst++; if (cur.indexOf('\n') >= 0) numLinesEst++; return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1; }, 0); if (length > 60) { return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n ') + ' ' + braces[1]; } return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1]; } // NOTE: These type checking functions intentionally don't use `instanceof` // because it is fragile and can be easily faked with `Object.create()`. function isArray(ar) { return Array.isArray(ar); } exports.isArray = isArray; function isBoolean(arg) { return typeof arg === 'boolean'; } exports.isBoolean = isBoolean; function isNull(arg) { return arg === null; } exports.isNull = isNull; function isNullOrUndefined(arg) { return arg == null; } exports.isNullOrUndefined = isNullOrUndefined; function isNumber(arg) { return typeof arg === 'number'; } exports.isNumber = isNumber; function isString(arg) { return typeof arg === 'string'; } exports.isString = isString; function isSymbol(arg) { return typeof arg === 'symbol'; } exports.isSymbol = isSymbol; function isUndefined(arg) { return arg === void 0; } exports.isUndefined = isUndefined; function isRegExp(re) { return isObject(re) && objectToString(re) === '[object RegExp]'; } exports.isRegExp = isRegExp; function isObject(arg) { return typeof arg === 'object' && arg !== null; } exports.isObject = isObject; function isDate(d) { return isObject(d) && objectToString(d) === '[object Date]'; } exports.isDate = isDate; function isError(e) { return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error); } exports.isError = isError; function isFunction(arg) { return typeof arg === 'function'; } exports.isFunction = isFunction; function isPrimitive(arg) { return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol typeof arg === 'undefined'; } exports.isPrimitive = isPrimitive; exports.isBuffer = require('./support/isBuffer'); function objectToString(o) { return Object.prototype.toString.call(o); } function pad(n) { return n < 10 ? '0' + n.toString(10) : n.toString(10); } var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34 function timestamp() { var d = new Date(); var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':'); return [d.getDate(), months[d.getMonth()], time].join(' '); } // log is just a thin wrapper to console.log that prepends a timestamp exports.log = function() { console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments)); }; /** * Inherit the prototype methods from one constructor into another. * * The Function.prototype.inherits from lang.js rewritten as a standalone * function (not on Function.prototype). NOTE: If this file is to be loaded * during bootstrapping this function needs to be rewritten using some native * functions as prototype setup using normal JavaScript does not work as * expected during bootstrapping (see mirror.js in r114903). * * @param {function} ctor Constructor function which needs to inherit the * prototype. * @param {function} superCtor Constructor function to inherit prototype from. */ exports.inherits = require('inherits'); exports._extend = function(origin, add) { // Don't do anything if add isn't an object if (!add || !isObject(add)) return origin; var keys = Object.keys(add); var i = keys.length; while (i--) { origin[keys[i]] = add[keys[i]]; } return origin; }; function hasOwnProperty(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); } }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}) },{"./support/isBuffer":31,"_process":234,"inherits":30}],33:[function(require,module,exports){ (function (process,setImmediate){ /*! * async * https://github.com/caolan/async * * Copyright 2010-2014 Caolan McMahon * Released under the MIT license */ /*jshint onevar: false, indent:4 */ /*global setImmediate: false, setTimeout: false, console: false */ (function () { var async = {}; // global on the server, window in the browser var root, previous_async; root = this; if (root != null) { previous_async = root.async; } async.noConflict = function () { root.async = previous_async; return async; }; function only_once(fn) { var called = false; return function() { if (called) throw new Error("Callback was already called."); called = true; fn.apply(root, arguments); } } //// cross-browser compatiblity functions //// var _toString = Object.prototype.toString; var _isArray = Array.isArray || function (obj) { return _toString.call(obj) === '[object Array]'; }; var _each = function (arr, iterator) { for (var i = 0; i < arr.length; i += 1) { iterator(arr[i], i, arr); } }; var _map = function (arr, iterator) { if (arr.map) { return arr.map(iterator); } var results = []; _each(arr, function (x, i, a) { results.push(iterator(x, i, a)); }); return results; }; var _reduce = function (arr, iterator, memo) { if (arr.reduce) { return arr.reduce(iterator, memo); } _each(arr, function (x, i, a) { memo = iterator(memo, x, i, a); }); return memo; }; var _keys = function (obj) { if (Object.keys) { return Object.keys(obj); } var keys = []; for (var k in obj) { if (obj.hasOwnProperty(k)) { keys.push(k); } } return keys; }; //// exported async module functions //// //// nextTick implementation with browser-compatible fallback //// if (typeof process === 'undefined' || !(process.nextTick)) { if (typeof setImmediate === 'function') { async.nextTick = function (fn) { // not a direct alias for IE10 compatibility setImmediate(fn); }; async.setImmediate = async.nextTick; } else { async.nextTick = function (fn) { setTimeout(fn, 0); }; async.setImmediate = async.nextTick; } } else { async.nextTick = process.nextTick; if (typeof setImmediate !== 'undefined') { async.setImmediate = function (fn) { // not a direct alias for IE10 compatibility setImmediate(fn); }; } else { async.setImmediate = async.nextTick; } } async.each = function (arr, iterator, callback) { callback = callback || function () {}; if (!arr.length) { return callback(); } var completed = 0; _each(arr, function (x) { iterator(x, only_once(done) ); }); function done(err) { if (err) { callback(err); callback = function () {}; } else { completed += 1; if (completed >= arr.length) { callback(); } } } }; async.forEach = async.each; async.eachSeries = function (arr, iterator, callback) { callback = callback || function () {}; if (!arr.length) { return callback(); } var completed = 0; var iterate = function () { iterator(arr[completed], function (err) { if (err) { callback(err); callback = function () {}; } else { completed += 1; if (completed >= arr.length) { callback(); } else { iterate(); } } }); }; iterate(); }; async.forEachSeries = async.eachSeries; async.eachLimit = function (arr, limit, iterator, callback) { var fn = _eachLimit(limit); fn.apply(null, [arr, iterator, callback]); }; async.forEachLimit = async.eachLimit; var _eachLimit = function (limit) { return function (arr, iterator, callback) { callback = callback || function () {}; if (!arr.length || limit <= 0) { return callback(); } var completed = 0; var started = 0; var running = 0; (function replenish () { if (completed >= arr.length) { return callback(); } while (running < limit && started < arr.length) { started += 1; running += 1; iterator(arr[started - 1], function (err) { if (err) { callback(err); callback = function () {}; } else { completed += 1; running -= 1; if (completed >= arr.length) { callback(); } else { replenish(); } } }); } })(); }; }; var doParallel = function (fn) { return function () { var args = Array.prototype.slice.call(arguments); return fn.apply(null, [async.each].concat(args)); }; }; var doParallelLimit = function(limit, fn) { return function () { var args = Array.prototype.slice.call(arguments); return fn.apply(null, [_eachLimit(limit)].concat(args)); }; }; var doSeries = function (fn) { return function () { var args = Array.prototype.slice.call(arguments); return fn.apply(null, [async.eachSeries].concat(args)); }; }; var _asyncMap = function (eachfn, arr, iterator, callback) { arr = _map(arr, function (x, i) { return {index: i, value: x}; }); if (!callback) { eachfn(arr, function (x, callback) { iterator(x.value, function (err) { callback(err); }); }); } else { var results = []; eachfn(arr, function (x, callback) { iterator(x.value, function (err, v) { results[x.index] = v; callback(err); }); }, function (err) { callback(err, results); }); } }; async.map = doParallel(_asyncMap); async.mapSeries = doSeries(_asyncMap); async.mapLimit = function (arr, limit, iterator, callback) { return _mapLimit(limit)(arr, iterator, callback); }; var _mapLimit = function(limit) { return doParallelLimit(limit, _asyncMap); }; // reduce only has a series version, as doing reduce in parallel won't // work in many situations. async.reduce = function (arr, memo, iterator, callback) { async.eachSeries(arr, function (x, callback) { iterator(memo, x, function (err, v) { memo = v; callback(err); }); }, function (err) { callback(err, memo); }); }; // inject alias async.inject = async.reduce; // foldl alias async.foldl = async.reduce; async.reduceRight = function (arr, memo, iterator, callback) { var reversed = _map(arr, function (x) { return x; }).reverse(); async.reduce(reversed, memo, iterator, callback); }; // foldr alias async.foldr = async.reduceRight; var _filter = function (eachfn, arr, iterator, callback) { var results = []; arr = _map(arr, function (x, i) { return {index: i, value: x}; }); eachfn(arr, function (x, callback) { iterator(x.value, function (v) { if (v) { results.push(x); } callback(); }); }, function (err) { callback(_map(results.sort(function (a, b) { return a.index - b.index; }), function (x) { return x.value; })); }); }; async.filter = doParallel(_filter); async.filterSeries = doSeries(_filter); // select alias async.select = async.filter; async.selectSeries = async.filterSeries; var _reject = function (eachfn, arr, iterator, callback) { var results = []; arr = _map(arr, function (x, i) { return {index: i, value: x}; }); eachfn(arr, function (x, callback) { iterator(x.value, function (v) { if (!v) { results.push(x); } callback(); }); }, function (err) { callback(_map(results.sort(function (a, b) { return a.index - b.index; }), function (x) { return x.value; })); }); }; async.reject = doParallel(_reject); async.rejectSeries = doSeries(_reject); var _detect = function (eachfn, arr, iterator, main_callback) { eachfn(arr, function (x, callback) { iterator(x, function (result) { if (result) { main_callback(x); main_callback = function () {}; } else { callback(); } }); }, function (err) { main_callback(); }); }; async.detect = doParallel(_detect); async.detectSeries = doSeries(_detect); async.some = function (arr, iterator, main_callback) { async.each(arr, function (x, callback) { iterator(x, function (v) { if (v) { main_callback(true); main_callback = function () {}; } callback(); }); }, function (err) { main_callback(false); }); }; // any alias async.any = async.some; async.every = function (arr, iterator, main_callback) { async.each(arr, function (x, callback) { iterator(x, function (v) { if (!v) { main_callback(false); main_callback = function () {}; } callback(); }); }, function (err) { main_callback(true); }); }; // all alias async.all = async.every; async.sortBy = function (arr, iterator, callback) { async.map(arr, function (x, callback) { iterator(x, function (err, criteria) { if (err) { callback(err); } else { callback(null, {value: x, criteria: criteria}); } }); }, function (err, results) { if (err) { return callback(err); } else { var fn = function (left, right) { var a = left.criteria, b = right.criteria; return a < b ? -1 : a > b ? 1 : 0; }; callback(null, _map(results.sort(fn), function (x) { return x.value; })); } }); }; async.auto = function (tasks, callback) { callback = callback || function () {}; var keys = _keys(tasks); var remainingTasks = keys.length if (!remainingTasks) { return callback(); } var results = {}; var listeners = []; var addListener = function (fn) { listeners.unshift(fn); }; var removeListener = function (fn) { for (var i = 0; i < listeners.length; i += 1) { if (listeners[i] === fn) { listeners.splice(i, 1); return; } } }; var taskComplete = function () { remainingTasks-- _each(listeners.slice(0), function (fn) { fn(); }); }; addListener(function () { if (!remainingTasks) { var theCallback = callback; // prevent final callback from calling itself if it errors callback = function () {}; theCallback(null, results); } }); _each(keys, function (k) { var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]]; var taskCallback = function (err) { var args = Array.prototype.slice.call(arguments, 1); if (args.length <= 1) { args = args[0]; } if (err) { var safeResults = {}; _each(_keys(results), function(rkey) { safeResults[rkey] = results[rkey]; }); safeResults[k] = args; callback(err, safeResults); // stop subsequent errors hitting callback multiple times callback = function () {}; } else { results[k] = args; async.setImmediate(taskComplete); } }; var requires = task.slice(0, Math.abs(task.length - 1)) || []; var ready = function () { return _reduce(requires, function (a, x) { return (a && results.hasOwnProperty(x)); }, true) && !results.hasOwnProperty(k); }; if (ready()) { task[task.length - 1](taskCallback, results); } else { var listener = function () { if (ready()) { removeListener(listener); task[task.length - 1](taskCallback, results); } }; addListener(listener); } }); }; async.retry = function(times, task, callback) { var DEFAULT_TIMES = 5; var attempts = []; // Use defaults if times not passed if (typeof times === 'function') { callback = task; task = times; times = DEFAULT_TIMES; } // Make sure times is a number times = parseInt(times, 10) || DEFAULT_TIMES; var wrappedTask = function(wrappedCallback, wrappedResults) { var retryAttempt = function(task, finalAttempt) { return function(seriesCallback) { task(function(err, result){ seriesCallback(!err || finalAttempt, {err: err, result: result}); }, wrappedResults); }; }; while (times) { attempts.push(retryAttempt(task, !(times-=1))); } async.series(attempts, function(done, data){ data = data[data.length - 1]; (wrappedCallback || callback)(data.err, data.result); }); } // If a callback is passed, run this as a controll flow return callback ? wrappedTask() : wrappedTask }; async.waterfall = function (tasks, callback) { callback = callback || function () {}; if (!_isArray(tasks)) { var err = new Error('First argument to waterfall must be an array of functions'); return callback(err); } if (!tasks.length) { return callback(); } var wrapIterator = function (iterator) { return function (err) { if (err) { callback.apply(null, arguments); callback = function () {}; } else { var args = Array.prototype.slice.call(arguments, 1); var next = iterator.next(); if (next) { args.push(wrapIterator(next)); } else { args.push(callback); } async.setImmediate(function () { iterator.apply(null, args); }); } }; }; wrapIterator(async.iterator(tasks))(); }; var _parallel = function(eachfn, tasks, callback) { callback = callback || function () {}; if (_isArray(tasks)) { eachfn.map(tasks, function (fn, callback) { if (fn) { fn(function (err) { var args = Array.prototype.slice.call(arguments, 1); if (args.length <= 1) { args = args[0]; } callback.call(null, err, args); }); } }, callback); } else { var results = {}; eachfn.each(_keys(tasks), function (k, callback) { tasks[k](function (err) { var args = Array.prototype.slice.call(arguments, 1); if (args.length <= 1) { args = args[0]; } results[k] = args; callback(err); }); }, function (err) { callback(err, results); }); } }; async.parallel = function (tasks, callback) { _parallel({ map: async.map, each: async.each }, tasks, callback); }; async.parallelLimit = function(tasks, limit, callback) { _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback); }; async.series = function (tasks, callback) { callback = callback || function () {}; if (_isArray(tasks)) { async.mapSeries(tasks, function (fn, callback) { if (fn) { fn(function (err) { var args = Array.prototype.slice.call(arguments, 1); if (args.length <= 1) { args = args[0]; } callback.call(null, err, args); }); } }, callback); } else { var results = {}; async.eachSeries(_keys(tasks), function (k, callback) { tasks[k](function (err) { var args = Array.prototype.slice.call(arguments, 1); if (args.length <= 1) { args = args[0]; } results[k] = args; callback(err); }); }, function (err) { callback(err, results); }); } }; async.iterator = function (tasks) { var makeCallback = function (index) { var fn = function () { if (tasks.length) { tasks[index].apply(null, arguments); } return fn.next(); }; fn.next = function () { return (index < tasks.length - 1) ? makeCallback(index + 1): null; }; return fn; }; return makeCallback(0); }; async.apply = function (fn) { var args = Array.prototype.slice.call(arguments, 1); return function () { return fn.apply( null, args.concat(Array.prototype.slice.call(arguments)) ); }; }; var _concat = function (eachfn, arr, fn, callback) { var r = []; eachfn(arr, function (x, cb) { fn(x, function (err, y) { r = r.concat(y || []); cb(err); }); }, function (err) { callback(err, r); }); }; async.concat = doParallel(_concat); async.concatSeries = doSeries(_concat); async.whilst = function (test, iterator, callback) { if (test()) { iterator(function (err) { if (err) { return callback(err); } async.whilst(test, iterator, callback); }); } else { callback(); } }; async.doWhilst = function (iterator, test, callback) { iterator(function (err) { if (err) { return callback(err); } var args = Array.prototype.slice.call(arguments, 1); if (test.apply(null, args)) { async.doWhilst(iterator, test, callback); } else { callback(); } }); }; async.until = function (test, iterator, callback) { if (!test()) { iterator(function (err) { if (err) { return callback(err); } async.until(test, iterator, callback); }); } else { callback(); } }; async.doUntil = function (iterator, test, callback) { iterator(function (err) { if (err) { return callback(err); } var args = Array.prototype.slice.call(arguments, 1); if (!test.apply(null, args)) { async.doUntil(iterator, test, callback); } else { callback(); } }); }; async.queue = function (worker, concurrency) { if (concurrency === undefined) { concurrency = 1; } function _insert(q, data, pos, callback) { if (!q.started){ q.started = true; } if (!_isArray(data)) { data = [data]; } if(data.length == 0) { // call drain immediately if there are no tasks return async.setImmediate(function() { if (q.drain) { q.drain(); } }); } _each(data, function(task) { var item = { data: task, callback: typeof callback === 'function' ? callback : null }; if (pos) { q.tasks.unshift(item); } else { q.tasks.push(item); } if (q.saturated && q.tasks.length === q.concurrency) { q.saturated(); } async.setImmediate(q.process); }); } var workers = 0; var q = { tasks: [], concurrency: concurrency, saturated: null, empty: null, drain: null, started: false, paused: false, push: function (data, callback) { _insert(q, data, false, callback); }, kill: function () { q.drain = null; q.tasks = []; }, unshift: function (data, callback) { _insert(q, data, true, callback); }, process: function () { if (!q.paused && workers < q.concurrency && q.tasks.length) { var task = q.tasks.shift(); if (q.empty && q.tasks.length === 0) { q.empty(); } workers += 1; var next = function () { workers -= 1; if (task.callback) { task.callback.apply(task, arguments); } if (q.drain && q.tasks.length + workers === 0) { q.drain(); } q.process(); }; var cb = only_once(next); worker(task.data, cb); } }, length: function () { return q.tasks.length; }, running: function () { return workers; }, idle: function() { return q.tasks.length + workers === 0; }, pause: function () { if (q.paused === true) { return; } q.paused = true; }, resume: function () { if (q.paused === false) { return; } q.paused = false; // Need to call q.process once per concurrent // worker to preserve full concurrency after pause for (var w = 1; w <= q.concurrency; w++) { async.setImmediate(q.process); } } }; return q; }; async.priorityQueue = function (worker, concurrency) { function _compareTasks(a, b){ return a.priority - b.priority; }; function _binarySearch(sequence, item, compare) { var beg = -1, end = sequence.length - 1; while (beg < end) { var mid = beg + ((end - beg + 1) >>> 1); if (compare(item, sequence[mid]) >= 0) { beg = mid; } else { end = mid - 1; } } return beg; } function _insert(q, data, priority, callback) { if (!q.started){ q.started = true; } if (!_isArray(data)) { data = [data]; } if(data.length == 0) { // call drain immediately if there are no tasks return async.setImmediate(function() { if (q.drain) { q.drain(); } }); } _each(data, function(task) { var item = { data: task, priority: priority, callback: typeof callback === 'function' ? callback : null }; q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item); if (q.saturated && q.tasks.length === q.concurrency) { q.saturated(); } async.setImmediate(q.process); }); } // Start with a normal queue var q = async.queue(worker, concurrency); // Override push to accept second parameter representing priority q.push = function (data, priority, callback) { _insert(q, data, priority, callback); }; // Remove unshift function delete q.unshift; return q; }; async.cargo = function (worker, payload) { var working = false, tasks = []; var cargo = { tasks: tasks, payload: payload, saturated: null, empty: null, drain: null, drained: true, push: function (data, callback) { if (!_isArray(data)) { data = [data]; } _each(data, function(task) { tasks.push({ data: task, callback: typeof callback === 'function' ? callback : null }); cargo.drained = false; if (cargo.saturated && tasks.length === payload) { cargo.saturated(); } }); async.setImmediate(cargo.process); }, process: function process() { if (working) return; if (tasks.length === 0) { if(cargo.drain && !cargo.drained) cargo.drain(); cargo.drained = true; return; } var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0, tasks.length); var ds = _map(ts, function (task) { return task.data; }); if(cargo.empty) cargo.empty(); working = true; worker(ds, function () { working = false; var args = arguments; _each(ts, function (data) { if (data.callback) { data.callback.apply(null, args); } }); process(); }); }, length: function () { return tasks.length; }, running: function () { return working; } }; return cargo; }; var _console_fn = function (name) { return function (fn) { var args = Array.prototype.slice.call(arguments, 1); fn.apply(null, args.concat([function (err) { var args = Array.prototype.slice.call(arguments, 1); if (typeof console !== 'undefined') { if (err) { if (console.error) { console.error(err); } } else if (console[name]) { _each(args, function (x) { console[name](x); }); } } }])); }; }; async.log = _console_fn('log'); async.dir = _console_fn('dir'); /*async.info = _console_fn('info'); async.warn = _console_fn('warn'); async.error = _console_fn('error');*/ async.memoize = function (fn, hasher) { var memo = {}; var queues = {}; hasher = hasher || function (x) { return x; }; var memoized = function () { var args = Array.prototype.slice.call(arguments); var callback = args.pop(); var key = hasher.apply(null, args); if (key in memo) { async.nextTick(function () { callback.apply(null, memo[key]); }); } else if (key in queues) { queues[key].push(callback); } else { queues[key] = [callback]; fn.apply(null, args.concat([function () { memo[key] = arguments; var q = queues[key]; delete queues[key]; for (var i = 0, l = q.length; i < l; i++) { q[i].apply(null, arguments); } }])); } }; memoized.memo = memo; memoized.unmemoized = fn; return memoized; }; async.unmemoize = function (fn) { return function () { return (fn.unmemoized || fn).apply(null, arguments); }; }; async.times = function (count, iterator, callback) { var counter = []; for (var i = 0; i < count; i++) { counter.push(i); } return async.map(counter, iterator, callback); }; async.timesSeries = function (count, iterator, callback) { var counter = []; for (var i = 0; i < count; i++) { counter.push(i); } return async.mapSeries(counter, iterator, callback); }; async.seq = function (/* functions... */) { var fns = arguments; return function () { var that = this; var args = Array.prototype.slice.call(arguments); var callback = args.pop(); async.reduce(fns, args, function (newargs, fn, cb) { fn.apply(that, newargs.concat([function () { var err = arguments[0]; var nextargs = Array.prototype.slice.call(arguments, 1); cb(err, nextargs); }])) }, function (err, results) { callback.apply(that, [err].concat(results)); }); }; }; async.compose = function (/* functions... */) { return async.seq.apply(null, Array.prototype.reverse.call(arguments)); }; var _applyEach = function (eachfn, fns /*args...*/) { var go = function () { var that = this; var args = Array.prototype.slice.call(arguments); var callback = args.pop(); return eachfn(fns, function (fn, cb) { fn.apply(that, args.concat([cb])); }, callback); }; if (arguments.length > 2) { var args = Array.prototype.slice.call(arguments, 2); return go.apply(this, args); } else { return go; } }; async.applyEach = doParallel(_applyEach); async.applyEachSeries = doSeries(_applyEach); async.forever = function (fn, callback) { function next(err) { if (err) { if (callback) { return callback(err); } throw err; } fn(next); } next(); }; // Node.js if (typeof module !== 'undefined' && module.exports) { module.exports = async; } // AMD / RequireJS else if (typeof define !== 'undefined' && define.amd) { define([], function () { return async; }); } // included directly via <script> tag else { root.async = async; } }()); }).call(this,require('_process'),require("timers").setImmediate) },{"_process":234,"timers":285}],34:[function(require,module,exports){ // base-x encoding / decoding // Copyright (c) 2018 base-x contributors // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp) // Distributed under the MIT software license, see the accompanying // file LICENSE or http://www.opensource.org/licenses/mit-license.php. const Buffer = require('safe-buffer').Buffer module.exports = function base (ALPHABET) { if (ALPHABET.length >= 255) throw new TypeError('Alphabet too long') const BASE_MAP = new Uint8Array(256) BASE_MAP.fill(255) for (let i = 0; i < ALPHABET.length; i++) { const x = ALPHABET.charAt(i) const xc = x.charCodeAt(0) if (BASE_MAP[xc] !== 255) throw new TypeError(x + ' is ambiguous') BASE_MAP[xc] = i } const BASE = ALPHABET.length const LEADER = ALPHABET.charAt(0) const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up function encode (source) { if (!Buffer.isBuffer(source)) throw new TypeError('Expected Buffer') if (source.length === 0) return '' // Skip & count leading zeroes. let zeroes = 0 let length = 0 let pbegin = 0 const pend = source.length while (pbegin !== pend && source[pbegin] === 0) { pbegin++ zeroes++ } // Allocate enough space in big-endian base58 representation. const size = ((pend - pbegin) * iFACTOR + 1) >>> 0 const b58 = new Uint8Array(size) // Process the bytes. while (pbegin !== pend) { let carry = source[pbegin] // Apply "b58 = b58 * 256 + ch". let i = 0 for (let it = size - 1; (carry !== 0 || i < length) && (it !== -1); it--, i++) { carry += (256 * b58[it]) >>> 0 b58[it] = (carry % BASE) >>> 0 carry = (carry / BASE) >>> 0 } if (carry !== 0) throw new Error('Non-zero carry') length = i pbegin++ } // Skip leading zeroes in base58 result. let it = size - length while (it !== size && b58[it] === 0) { it++ } // Translate the result into a string. let str = LEADER.repeat(zeroes) for (; it < size; ++it) str += ALPHABET.charAt(b58[it]) return str } function decodeUnsafe (source) { if (typeof source !== 'string') throw new TypeError('Expected String') if (source.length === 0) return Buffer.alloc(0) let psz = 0 // Skip leading spaces. if (source[psz] === ' ') return // Skip and count leading '1's. let zeroes = 0 let length = 0 while (source[psz] === LEADER) { zeroes++ psz++ } // Allocate enough space in big-endian base256 representation. const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up. const b256 = new Uint8Array(size) // Process the characters. while (source[psz]) { // Decode character let carry = BASE_MAP[source.charCodeAt(psz)] // Invalid character if (carry === 255) return let i = 0 for (let it = size - 1; (carry !== 0 || i < length) && (it !== -1); it--, i++) { carry += (BASE * b256[it]) >>> 0 b256[it] = (carry % 256) >>> 0 carry = (carry / 256) >>> 0 } if (carry !== 0) throw new Error('Non-zero carry') length = i psz++ } // Skip trailing spaces. if (source[psz] === ' ') return // Skip leading zeroes in b256. let it = size - length while (it !== size && b256[it] === 0) { it++ } const vch = Buffer.allocUnsafe(zeroes + (size - it)) vch.fill(0x00, 0, zeroes) let j = zeroes while (it !== size) { vch[j++] = b256[it++] } return vch } function decode (string) { const buffer = decodeUnsafe(string) if (buffer) return buffer throw new Error('Non-base' + BASE + ' character') } return { encode: encode, decodeUnsafe: decodeUnsafe, decode: decode } } },{"safe-buffer":262}],35:[function(require,module,exports){ 'use strict' exports.byteLength = byteLength exports.toByteArray = toByteArray exports.fromByteArray = fromByteArray var lookup = [] var revLookup = [] var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' for (var i = 0, len = code.length; i < len; ++i) { lookup[i] = code[i] revLookup[code.charCodeAt(i)] = i } // Support decoding URL-safe base64 strings, as Node.js does. // See: https://en.wikipedia.org/wiki/Base64#URL_applications revLookup['-'.charCodeAt(0)] = 62 revLookup['_'.charCodeAt(0)] = 63 function getLens (b64) { var len = b64.length if (len % 4 > 0) { throw new Error('Invalid string. Length must be a multiple of 4') } // Trim off extra bytes after placeholder bytes are found // See: https://github.com/beatgammit/base64-js/issues/42 var validLen = b64.indexOf('=') if (validLen === -1) validLen = len var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4) return [validLen, placeHoldersLen] } // base64 is 4/3 + up to two characters of the original data function byteLength (b64) { var lens = getLens(b64) var validLen = lens[0] var placeHoldersLen = lens[1] return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen } function _byteLength (b64, validLen, placeHoldersLen) { return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen } function toByteArray (b64) { var tmp var lens = getLens(b64) var validLen = lens[0] var placeHoldersLen = lens[1] var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen)) var curByte = 0 // if there are placeholders, only get up to the last complete 4 chars var len = placeHoldersLen > 0 ? validLen - 4 : validLen for (var i = 0; i < len; i += 4) { tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)] arr[curByte++] = (tmp >> 16) & 0xFF arr[curByte++] = (tmp >> 8) & 0xFF arr[curByte++] = tmp & 0xFF } if (placeHoldersLen === 2) { tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4) arr[curByte++] = tmp & 0xFF } if (placeHoldersLen === 1) { tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2) arr[curByte++] = (tmp >> 8) & 0xFF arr[curByte++] = tmp & 0xFF } return arr } function tripletToBase64 (num) { return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F] } function encodeChunk (uint8, start, end) { var tmp var output = [] for (var i = start; i < end; i += 3) { tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF) output.push(tripletToBase64(tmp)) } return output.join('') } function fromByteArray (uint8) { var tmp var len = uint8.length var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes var parts = [] var maxChunkLength = 16383 // must be multiple of 3 // go through the array every three bytes, we'll deal with trailing stuff later for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) { parts.push(encodeChunk( uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength) )) } // pad the end with zeros, but make sure to not forget the extra bytes if (extraBytes === 1) { tmp = uint8[len - 1] parts.push( lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3F] + '==' ) } else if (extraBytes === 2) { tmp = (uint8[len - 2] << 8) + uint8[len - 1] parts.push( lookup[tmp >> 10] + lookup[(tmp >> 4) & 0x3F] + lookup[(tmp << 2) & 0x3F] + '=' ) } return parts.join('') } },{}],36:[function(require,module,exports){ // (public) Constructor function BigInteger(a, b, c) { if (!(this instanceof BigInteger)) return new BigInteger(a, b, c) if (a != null) { if ("number" == typeof a) this.fromNumber(a, b, c) else if (b == null && "string" != typeof a) this.fromString(a, 256) else this.fromString(a, b) } } var proto = BigInteger.prototype // duck-typed isBigInteger proto.__bigi = require('../package.json').version BigInteger.isBigInteger = function (obj, check_ver) { return obj && obj.__bigi && (!check_ver || obj.__bigi === proto.__bigi) } // Bits per digit var dbits // am: Compute w_j += (x*this_i), propagate carries, // c is initial carry, returns final carry. // c < 3*dvalue, x < 2*dvalue, this_i < dvalue // We need to select the fastest one that works in this environment. // am1: use a single mult and divide to get the high bits, // max digit bits should be 26 because // max internal value = 2*dvalue^2-2*dvalue (< 2^53) function am1(i, x, w, j, c, n) { while (--n >= 0) { var v = x * this[i++] + w[j] + c c = Math.floor(v / 0x4000000) w[j++] = v & 0x3ffffff } return c } // am2 avoids a big mult-and-extract completely. // Max digit bits should be <= 30 because we do bitwise ops // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31) function am2(i, x, w, j, c, n) { var xl = x & 0x7fff, xh = x >> 15 while (--n >= 0) { var l = this[i] & 0x7fff var h = this[i++] >> 15 var m = xh * l + h * xl l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff) c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30) w[j++] = l & 0x3fffffff } return c } // Alternately, set max digit bits to 28 since some // browsers slow down when dealing with 32-bit numbers. function am3(i, x, w, j, c, n) { var xl = x & 0x3fff, xh = x >> 14 while (--n >= 0) { var l = this[i] & 0x3fff var h = this[i++] >> 14 var m = xh * l + h * xl l = xl * l + ((m & 0x3fff) << 14) + w[j] + c c = (l >> 28) + (m >> 14) + xh * h w[j++] = l & 0xfffffff } return c } // wtf? BigInteger.prototype.am = am1 dbits = 26 BigInteger.prototype.DB = dbits BigInteger.prototype.DM = ((1 << dbits) - 1) var DV = BigInteger.prototype.DV = (1 << dbits) var BI_FP = 52 BigInteger.prototype.FV = Math.pow(2, BI_FP) BigInteger.prototype.F1 = BI_FP - dbits BigInteger.prototype.F2 = 2 * dbits - BI_FP // Digit conversions var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz" var BI_RC = new Array() var rr, vv rr = "0".charCodeAt(0) for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv rr = "a".charCodeAt(0) for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv rr = "A".charCodeAt(0) for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv function int2char(n) { return BI_RM.charAt(n) } function intAt(s, i) { var c = BI_RC[s.charCodeAt(i)] return (c == null) ? -1 : c } // (protected) copy this to r function bnpCopyTo(r) { for (var i = this.t - 1; i >= 0; --i) r[i] = this[i] r.t = this.t r.s = this.s } // (protected) set from integer value x, -DV <= x < DV function bnpFromInt(x) { this.t = 1 this.s = (x < 0) ? -1 : 0 if (x > 0) this[0] = x else if (x < -1) this[0] = x + DV else this.t = 0 } // return bigint initialized to value function nbv(i) { var r = new BigInteger() r.fromInt(i) return r } // (protected) set from string and radix function bnpFromString(s, b) { var self = this var k if (b == 16) k = 4 else if (b == 8) k = 3 else if (b == 256) k = 8; // byte array else if (b == 2) k = 1 else if (b == 32) k = 5 else if (b == 4) k = 2 else { self.fromRadix(s, b) return } self.t = 0 self.s = 0 var i = s.length, mi = false, sh = 0 while (--i >= 0) { var x = (k == 8) ? s[i] & 0xff : intAt(s, i) if (x < 0) { if (s.charAt(i) == "-") mi = true continue } mi = false if (sh == 0) self[self.t++] = x else if (sh + k > self.DB) { self[self.t - 1] |= (x & ((1 << (self.DB - sh)) - 1)) << sh self[self.t++] = (x >> (self.DB - sh)) } else self[self.t - 1] |= x << sh sh += k if (sh >= self.DB) sh -= self.DB } if (k == 8 && (s[0] & 0x80) != 0) { self.s = -1 if (sh > 0) self[self.t - 1] |= ((1 << (self.DB - sh)) - 1) << sh } self.clamp() if (mi) BigInteger.ZERO.subTo(self, self) } // (protected) clamp off excess high words function bnpClamp() { var c = this.s & this.DM while (this.t > 0 && this[this.t - 1] == c)--this.t } // (public) return string representation in given radix function bnToString(b) { var self = this if (self.s < 0) return "-" + self.negate() .toString(b) var k if (b == 16) k = 4 else if (b == 8) k = 3 else if (b == 2) k = 1 else if (b == 32) k = 5 else if (b == 4) k = 2 else return self.toRadix(b) var km = (1 << k) - 1, d, m = false, r = "", i = self.t var p = self.DB - (i * self.DB) % k if (i-- > 0) { if (p < self.DB && (d = self[i] >> p) > 0) { m = true r = int2char(d) } while (i >= 0) { if (p < k) { d = (self[i] & ((1 << p) - 1)) << (k - p) d |= self[--i] >> (p += self.DB - k) } else { d = (self[i] >> (p -= k)) & km if (p <= 0) { p += self.DB --i } } if (d > 0) m = true if (m) r += int2char(d) } } return m ? r : "0" } // (public) -this function bnNegate() { var r = new BigInteger() BigInteger.ZERO.subTo(this, r) return r } // (public) |this| function bnAbs() { return (this.s < 0) ? this.negate() : this } // (public) return + if this > a, - if this < a, 0 if equal function bnCompareTo(a) { var r = this.s - a.s if (r != 0) return r var i = this.t r = i - a.t if (r != 0) return (this.s < 0) ? -r : r while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r return 0 } // returns bit length of the integer x function nbits(x) { var r = 1, t if ((t = x >>> 16) != 0) { x = t r += 16 } if ((t = x >> 8) != 0) { x = t r += 8 } if ((t = x >> 4) != 0) { x = t r += 4 } if ((t = x >> 2) != 0) { x = t r += 2 } if ((t = x >> 1) != 0) { x = t r += 1 } return r } // (public) return the number of bits in "this" function bnBitLength() { if (this.t <= 0) return 0 return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM)) } // (public) return the number of bytes in "this" function bnByteLength() { return this.bitLength() >> 3 } // (protected) r = this << n*DB function bnpDLShiftTo(n, r) { var i for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i] for (i = n - 1; i >= 0; --i) r[i] = 0 r.t = this.t + n r.s = this.s } // (protected) r = this >> n*DB function bnpDRShiftTo(n, r) { for (var i = n; i < this.t; ++i) r[i - n] = this[i] r.t = Math.max(this.t - n, 0) r.s = this.s } // (protected) r = this << n function bnpLShiftTo(n, r) { var self = this var bs = n % self.DB var cbs = self.DB - bs var bm = (1 << cbs) - 1 var ds = Math.floor(n / self.DB), c = (self.s << bs) & self.DM, i for (i = self.t - 1; i >= 0; --i) { r[i + ds + 1] = (self[i] >> cbs) | c c = (self[i] & bm) << bs } for (i = ds - 1; i >= 0; --i) r[i] = 0 r[ds] = c r.t = self.t + ds + 1 r.s = self.s r.clamp() } // (protected) r = this >> n function bnpRShiftTo(n, r) { var self = this r.s = self.s var ds = Math.floor(n / self.DB) if (ds >= self.t) { r.t = 0 return } var bs = n % self.DB var cbs = self.DB - bs var bm = (1 << bs) - 1 r[0] = self[ds] >> bs for (var i = ds + 1; i < self.t; ++i) { r[i - ds - 1] |= (self[i] & bm) << cbs r[i - ds] = self[i] >> bs } if (bs > 0) r[self.t - ds - 1] |= (self.s & bm) << cbs r.t = self.t - ds r.clamp() } // (protected) r = this - a function bnpSubTo(a, r) { var self = this var i = 0, c = 0, m = Math.min(a.t, self.t) while (i < m) { c += self[i] - a[i] r[i++] = c & self.DM c >>= self.DB } if (a.t < self.t) { c -= a.s while (i < self.t) { c += self[i] r[i++] = c & self.DM c >>= self.DB } c += self.s } else { c += self.s while (i < a.t) { c -= a[i] r[i++] = c & self.DM c >>= self.DB } c -= a.s } r.s = (c < 0) ? -1 : 0 if (c < -1) r[i++] = self.DV + c else if (c > 0) r[i++] = c r.t = i r.clamp() } // (protected) r = this * a, r != this,a (HAC 14.12) // "this" should be the larger one if appropriate. function bnpMultiplyTo(a, r) { var x = this.abs(), y = a.abs() var i = x.t r.t = i + y.t while (--i >= 0) r[i] = 0 for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t) r.s = 0 r.clamp() if (this.s != a.s) BigInteger.ZERO.subTo(r, r) } // (protected) r = this^2, r != this (HAC 14.16) function bnpSquareTo(r) { var x = this.abs() var i = r.t = 2 * x.t while (--i >= 0) r[i] = 0 for (i = 0; i < x.t - 1; ++i) { var c = x.am(i, x[i], r, 2 * i, 0, 1) if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) { r[i + x.t] -= x.DV r[i + x.t + 1] = 1 } } if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1) r.s = 0 r.clamp() } // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20) // r != q, this != m. q or r may be null. function bnpDivRemTo(m, q, r) { var self = this var pm = m.abs() if (pm.t <= 0) return var pt = self.abs() if (pt.t < pm.t) { if (q != null) q.fromInt(0) if (r != null) self.copyTo(r) return } if (r == null) r = new BigInteger() var y = new BigInteger(), ts = self.s, ms = m.s var nsh = self.DB - nbits(pm[pm.t - 1]); // normalize modulus if (nsh > 0) { pm.lShiftTo(nsh, y) pt.lShiftTo(nsh, r) } else { pm.copyTo(y) pt.copyTo(r) } var ys = y.t var y0 = y[ys - 1] if (y0 == 0) return var yt = y0 * (1 << self.F1) + ((ys > 1) ? y[ys - 2] >> self.F2 : 0) var d1 = self.FV / yt, d2 = (1 << self.F1) / yt, e = 1 << self.F2 var i = r.t, j = i - ys, t = (q == null) ? new BigInteger() : q y.dlShiftTo(j, t) if (r.compareTo(t) >= 0) { r[r.t++] = 1 r.subTo(t, r) } BigInteger.ONE.dlShiftTo(ys, t) t.subTo(y, y); // "negative" y so we can replace sub with am later while (y.t < ys) y[y.t++] = 0 while (--j >= 0) { // Estimate quotient digit var qd = (r[--i] == y0) ? self.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2) if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out y.dlShiftTo(j, t) r.subTo(t, r) while (r[i] < --qd) r.subTo(t, r) } } if (q != null) { r.drShiftTo(ys, q) if (ts != ms) BigInteger.ZERO.subTo(q, q) } r.t = ys r.clamp() if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder if (ts < 0) BigInteger.ZERO.subTo(r, r) } // (public) this mod a function bnMod(a) { var r = new BigInteger() this.abs() .divRemTo(a, null, r) if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r) return r } // Modular reduction using "classic" algorithm function Classic(m) { this.m = m } function cConvert(x) { if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m) else return x } function cRevert(x) { return x } function cReduce(x) { x.divRemTo(this.m, null, x) } function cMulTo(x, y, r) { x.multiplyTo(y, r) this.reduce(r) } function cSqrTo(x, r) { x.squareTo(r) this.reduce(r) } Classic.prototype.convert = cConvert Classic.prototype.revert = cRevert Classic.prototype.reduce = cReduce Classic.prototype.mulTo = cMulTo Classic.prototype.sqrTo = cSqrTo // (protected) return "-1/this % 2^DB"; useful for Mont. reduction // justification: // xy == 1 (mod m) // xy = 1+km // xy(2-xy) = (1+km)(1-km) // x[y(2-xy)] = 1-k^2m^2 // x[y(2-xy)] == 1 (mod m^2) // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2 // should reduce x and y(2-xy) by m^2 at each step to keep size bounded. // JS multiply "overflows" differently from C/C++, so care is needed here. function bnpInvDigit() { if (this.t < 1) return 0 var x = this[0] if ((x & 1) == 0) return 0 var y = x & 3; // y == 1/x mod 2^2 y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4 y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8 y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16 // last step - calculate inverse mod DV directly // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits // we really want the negative inverse, and -DV < y < DV return (y > 0) ? this.DV - y : -y } // Montgomery reduction function Montgomery(m) { this.m = m this.mp = m.invDigit() this.mpl = this.mp & 0x7fff this.mph = this.mp >> 15 this.um = (1 << (m.DB - 15)) - 1 this.mt2 = 2 * m.t } // xR mod m function montConvert(x) { var r = new BigInteger() x.abs() .dlShiftTo(this.m.t, r) r.divRemTo(this.m, null, r) if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r) return r } // x/R mod m function montRevert(x) { var r = new BigInteger() x.copyTo(r) this.reduce(r) return r } // x = x/R mod m (HAC 14.32) function montReduce(x) { while (x.t <= this.mt2) // pad x so am has enough room later x[x.t++] = 0 for (var i = 0; i < this.m.t; ++i) { // faster way of calculating u0 = x[i]*mp mod DV var j = x[i] & 0x7fff var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM // use am to combine the multiply-shift-add into one call j = i + this.m.t x[j] += this.m.am(0, u0, x, i, 0, this.m.t) // propagate carry while (x[j] >= x.DV) { x[j] -= x.DV x[++j]++ } } x.clamp() x.drShiftTo(this.m.t, x) if (x.compareTo(this.m) >= 0) x.subTo(this.m, x) } // r = "x^2/R mod m"; x != r function montSqrTo(x, r) { x.squareTo(r) this.reduce(r) } // r = "xy/R mod m"; x,y != r function montMulTo(x, y, r) { x.multiplyTo(y, r) this.reduce(r) } Montgomery.prototype.convert = montConvert Montgomery.prototype.revert = montRevert Montgomery.prototype.reduce = montReduce Montgomery.prototype.mulTo = montMulTo Montgomery.prototype.sqrTo = montSqrTo // (protected) true iff this is even function bnpIsEven() { return ((this.t > 0) ? (this[0] & 1) : this.s) == 0 } // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79) function bnpExp(e, z) { if (e > 0xffffffff || e < 1) return BigInteger.ONE var r = new BigInteger(), r2 = new BigInteger(), g = z.convert(this), i = nbits(e) - 1 g.copyTo(r) while (--i >= 0) { z.sqrTo(r, r2) if ((e & (1 << i)) > 0) z.mulTo(r2, g, r) else { var t = r r = r2 r2 = t } } return z.revert(r) } // (public) this^e % m, 0 <= e < 2^32 function bnModPowInt(e, m) { var z if (e < 256 || m.isEven()) z = new Classic(m) else z = new Montgomery(m) return this.exp(e, z) } // protected proto.copyTo = bnpCopyTo proto.fromInt = bnpFromInt proto.fromString = bnpFromString proto.clamp = bnpClamp proto.dlShiftTo = bnpDLShiftTo proto.drShiftTo = bnpDRShiftTo proto.lShiftTo = bnpLShiftTo proto.rShiftTo = bnpRShiftTo proto.subTo = bnpSubTo proto.multiplyTo = bnpMultiplyTo proto.squareTo = bnpSquareTo proto.divRemTo = bnpDivRemTo proto.invDigit = bnpInvDigit proto.isEven = bnpIsEven proto.exp = bnpExp // public proto.toString = bnToString proto.negate = bnNegate proto.abs = bnAbs proto.compareTo = bnCompareTo proto.bitLength = bnBitLength proto.byteLength = bnByteLength proto.mod = bnMod proto.modPowInt = bnModPowInt // (public) function bnClone() { var r = new BigInteger() this.copyTo(r) return r } // (public) return value as integer function bnIntValue() { if (this.s < 0) { if (this.t == 1) return this[0] - this.DV else if (this.t == 0) return -1 } else if (this.t == 1) return this[0] else if (this.t == 0) return 0 // assumes 16 < DB < 32 return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0] } // (public) return value as byte function bnByteValue() { return (this.t == 0) ? this.s : (this[0] << 24) >> 24 } // (public) return value as short (assumes DB>=16) function bnShortValue() { return (this.t == 0) ? this.s : (this[0] << 16) >> 16 } // (protected) return x s.t. r^x < DV function bnpChunkSize(r) { return Math.floor(Math.LN2 * this.DB / Math.log(r)) } // (public) 0 if this == 0, 1 if this > 0 function bnSigNum() { if (this.s < 0) return -1 else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0 else return 1 } // (protected) convert to radix string function bnpToRadix(b) { if (b == null) b = 10 if (this.signum() == 0 || b < 2 || b > 36) return "0" var cs = this.chunkSize(b) var a = Math.pow(b, cs) var d = nbv(a), y = new BigInteger(), z = new BigInteger(), r = "" this.divRemTo(d, y, z) while (y.signum() > 0) { r = (a + z.intValue()) .toString(b) .substr(1) + r y.divRemTo(d, y, z) } return z.intValue() .toString(b) + r } // (protected) convert from radix string function bnpFromRadix(s, b) { var self = this self.fromInt(0) if (b == null) b = 10 var cs = self.chunkSize(b) var d = Math.pow(b, cs), mi = false, j = 0, w = 0 for (var i = 0; i < s.length; ++i) { var x = intAt(s, i) if (x < 0) { if (s.charAt(i) == "-" && self.signum() == 0) mi = true continue } w = b * w + x if (++j >= cs) { self.dMultiply(d) self.dAddOffset(w, 0) j = 0 w = 0 } } if (j > 0) { self.dMultiply(Math.pow(b, j)) self.dAddOffset(w, 0) } if (mi) BigInteger.ZERO.subTo(self, self) } // (protected) alternate constructor function bnpFromNumber(a, b, c) { var self = this if ("number" == typeof b) { // new BigInteger(int,int,RNG) if (a < 2) self.fromInt(1) else { self.fromNumber(a, c) if (!self.testBit(a - 1)) // force MSB set self.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, self) if (self.isEven()) self.dAddOffset(1, 0); // force odd while (!self.isProbablePrime(b)) { self.dAddOffset(2, 0) if (self.bitLength() > a) self.subTo(BigInteger.ONE.shiftLeft(a - 1), self) } } } else { // new BigInteger(int,RNG) var x = new Array(), t = a & 7 x.length = (a >> 3) + 1 b.nextBytes(x) if (t > 0) x[0] &= ((1 << t) - 1) else x[0] = 0 self.fromString(x, 256) } } // (public) convert to bigendian byte array function bnToByteArray() { var self = this var i = self.t, r = new Array() r[0] = self.s var p = self.DB - (i * self.DB) % 8, d, k = 0 if (i-- > 0) { if (p < self.DB && (d = self[i] >> p) != (self.s & self.DM) >> p) r[k++] = d | (self.s << (self.DB - p)) while (i >= 0) { if (p < 8) { d = (self[i] & ((1 << p) - 1)) << (8 - p) d |= self[--i] >> (p += self.DB - 8) } else { d = (self[i] >> (p -= 8)) & 0xff if (p <= 0) { p += self.DB --i } } if ((d & 0x80) != 0) d |= -256 if (k === 0 && (self.s & 0x80) != (d & 0x80))++k if (k > 0 || d != self.s) r[k++] = d } } return r } function bnEquals(a) { return (this.compareTo(a) == 0) } function bnMin(a) { return (this.compareTo(a) < 0) ? this : a } function bnMax(a) { return (this.compareTo(a) > 0) ? this : a } // (protected) r = this op a (bitwise) function bnpBitwiseTo(a, op, r) { var self = this var i, f, m = Math.min(a.t, self.t) for (i = 0; i < m; ++i) r[i] = op(self[i], a[i]) if (a.t < self.t) { f = a.s & self.DM for (i = m; i < self.t; ++i) r[i] = op(self[i], f) r.t = self.t } else { f = self.s & self.DM for (i = m; i < a.t; ++i) r[i] = op(f, a[i]) r.t = a.t } r.s = op(self.s, a.s) r.clamp() } // (public) this & a function op_and(x, y) { return x & y } function bnAnd(a) { var r = new BigInteger() this.bitwiseTo(a, op_and, r) return r } // (public) this | a function op_or(x, y) { return x | y } function bnOr(a) { var r = new BigInteger() this.bitwiseTo(a, op_or, r) return r } // (public) this ^ a function op_xor(x, y) { return x ^ y } function bnXor(a) { var r = new BigInteger() this.bitwiseTo(a, op_xor, r) return r } // (public) this & ~a function op_andnot(x, y) { return x & ~y } function bnAndNot(a) { var r = new BigInteger() this.bitwiseTo(a, op_andnot, r) return r } // (public) ~this function bnNot() { var r = new BigInteger() for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i] r.t = this.t r.s = ~this.s return r } // (public) this << n function bnShiftLeft(n) { var r = new BigInteger() if (n < 0) this.rShiftTo(-n, r) else this.lShiftTo(n, r) return r } // (public) this >> n function bnShiftRight(n) { var r = new BigInteger() if (n < 0) this.lShiftTo(-n, r) else this.rShiftTo(n, r) return r } // return index of lowest 1-bit in x, x < 2^31 function lbit(x) { if (x == 0) return -1 var r = 0 if ((x & 0xffff) == 0) { x >>= 16 r += 16 } if ((x & 0xff) == 0) { x >>= 8 r += 8 } if ((x & 0xf) == 0) { x >>= 4 r += 4 } if ((x & 3) == 0) { x >>= 2 r += 2 } if ((x & 1) == 0)++r return r } // (public) returns index of lowest 1-bit (or -1 if none) function bnGetLowestSetBit() { for (var i = 0; i < this.t; ++i) if (this[i] != 0) return i * this.DB + lbit(this[i]) if (this.s < 0) return this.t * this.DB return -1 } // return number of 1 bits in x function cbit(x) { var r = 0 while (x != 0) { x &= x - 1 ++r } return r } // (public) return number of set bits function bnBitCount() { var r = 0, x = this.s & this.DM for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x) return r } // (public) true iff nth bit is set function bnTestBit(n) { var j = Math.floor(n / this.DB) if (j >= this.t) return (this.s != 0) return ((this[j] & (1 << (n % this.DB))) != 0) } // (protected) this op (1<<n) function bnpChangeBit(n, op) { var r = BigInteger.ONE.shiftLeft(n) this.bitwiseTo(r, op, r) return r } // (public) this | (1<<n) function bnSetBit(n) { return this.changeBit(n, op_or) } // (public) this & ~(1<<n) function bnClearBit(n) { return this.changeBit(n, op_andnot) } // (public) this ^ (1<<n) function bnFlipBit(n) { return this.changeBit(n, op_xor) } // (protected) r = this + a function bnpAddTo(a, r) { var self = this var i = 0, c = 0, m = Math.min(a.t, self.t) while (i < m) { c += self[i] + a[i] r[i++] = c & self.DM c >>= self.DB } if (a.t < self.t) { c += a.s while (i < self.t) { c += self[i] r[i++] = c & self.DM c >>= self.DB } c += self.s } else { c += self.s while (i < a.t) { c += a[i] r[i++] = c & self.DM c >>= self.DB } c += a.s } r.s = (c < 0) ? -1 : 0 if (c > 0) r[i++] = c else if (c < -1) r[i++] = self.DV + c r.t = i r.clamp() } // (public) this + a function bnAdd(a) { var r = new BigInteger() this.addTo(a, r) return r } // (public) this - a function bnSubtract(a) { var r = new BigInteger() this.subTo(a, r) return r } // (public) this * a function bnMultiply(a) { var r = new BigInteger() this.multiplyTo(a, r) return r } // (public) this^2 function bnSquare() { var r = new BigInteger() this.squareTo(r) return r } // (public) this / a function bnDivide(a) { var r = new BigInteger() this.divRemTo(a, r, null) return r } // (public) this % a function bnRemainder(a) { var r = new BigInteger() this.divRemTo(a, null, r) return r } // (public) [this/a,this%a] function bnDivideAndRemainder(a) { var q = new BigInteger(), r = new BigInteger() this.divRemTo(a, q, r) return new Array(q, r) } // (protected) this *= n, this >= 0, 1 < n < DV function bnpDMultiply(n) { this[this.t] = this.am(0, n - 1, this, 0, 0, this.t) ++this.t this.clamp() } // (protected) this += n << w words, this >= 0 function bnpDAddOffset(n, w) { if (n == 0) return while (this.t <= w) this[this.t++] = 0 this[w] += n while (this[w] >= this.DV) { this[w] -= this.DV if (++w >= this.t) this[this.t++] = 0 ++this[w] } } // A "null" reducer function NullExp() {} function nNop(x) { return x } function nMulTo(x, y, r) { x.multiplyTo(y, r) } function nSqrTo(x, r) { x.squareTo(r) } NullExp.prototype.convert = nNop NullExp.prototype.revert = nNop NullExp.prototype.mulTo = nMulTo NullExp.prototype.sqrTo = nSqrTo // (public) this^e function bnPow(e) { return this.exp(e, new NullExp()) } // (protected) r = lower n words of "this * a", a.t <= n // "this" should be the larger one if appropriate. function bnpMultiplyLowerTo(a, n, r) { var i = Math.min(this.t + a.t, n) r.s = 0; // assumes a,this >= 0 r.t = i while (i > 0) r[--i] = 0 var j for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t) for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i) r.clamp() } // (protected) r = "this * a" without lower n words, n > 0 // "this" should be the larger one if appropriate. function bnpMultiplyUpperTo(a, n, r) { --n var i = r.t = this.t + a.t - n r.s = 0; // assumes a,this >= 0 while (--i >= 0) r[i] = 0 for (i = Math.max(n - this.t, 0); i < a.t; ++i) r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n) r.clamp() r.drShiftTo(1, r) } // Barrett modular reduction function Barrett(m) { // setup Barrett this.r2 = new BigInteger() this.q3 = new BigInteger() BigInteger.ONE.dlShiftTo(2 * m.t, this.r2) this.mu = this.r2.divide(m) this.m = m } function barrettConvert(x) { if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m) else if (x.compareTo(this.m) < 0) return x else { var r = new BigInteger() x.copyTo(r) this.reduce(r) return r } } function barrettRevert(x) { return x } // x = x mod m (HAC 14.42) function barrettReduce(x) { var self = this x.drShiftTo(self.m.t - 1, self.r2) if (x.t > self.m.t + 1) { x.t = self.m.t + 1 x.clamp() } self.mu.multiplyUpperTo(self.r2, self.m.t + 1, self.q3) self.m.multiplyLowerTo(self.q3, self.m.t + 1, self.r2) while (x.compareTo(self.r2) < 0) x.dAddOffset(1, self.m.t + 1) x.subTo(self.r2, x) while (x.compareTo(self.m) >= 0) x.subTo(self.m, x) } // r = x^2 mod m; x != r function barrettSqrTo(x, r) { x.squareTo(r) this.reduce(r) } // r = x*y mod m; x,y != r function barrettMulTo(x, y, r) { x.multiplyTo(y, r) this.reduce(r) } Barrett.prototype.convert = barrettConvert Barrett.prototype.revert = barrettRevert Barrett.prototype.reduce = barrettReduce Barrett.prototype.mulTo = barrettMulTo Barrett.prototype.sqrTo = barrettSqrTo // (public) this^e % m (HAC 14.85) function bnModPow(e, m) { var i = e.bitLength(), k, r = nbv(1), z if (i <= 0) return r else if (i < 18) k = 1 else if (i < 48) k = 3 else if (i < 144) k = 4 else if (i < 768) k = 5 else k = 6 if (i < 8) z = new Classic(m) else if (m.isEven()) z = new Barrett(m) else z = new Montgomery(m) // precomputation var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1 g[1] = z.convert(this) if (k > 1) { var g2 = new BigInteger() z.sqrTo(g[1], g2) while (n <= km) { g[n] = new BigInteger() z.mulTo(g2, g[n - 2], g[n]) n += 2 } } var j = e.t - 1, w, is1 = true, r2 = new BigInteger(), t i = nbits(e[j]) - 1 while (j >= 0) { if (i >= k1) w = (e[j] >> (i - k1)) & km else { w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i) if (j > 0) w |= e[j - 1] >> (this.DB + i - k1) } n = k while ((w & 1) == 0) { w >>= 1 --n } if ((i -= n) < 0) { i += this.DB --j } if (is1) { // ret == 1, don't bother squaring or multiplying it g[w].copyTo(r) is1 = false } else { while (n > 1) { z.sqrTo(r, r2) z.sqrTo(r2, r) n -= 2 } if (n > 0) z.sqrTo(r, r2) else { t = r r = r2 r2 = t } z.mulTo(r2, g[w], r) } while (j >= 0 && (e[j] & (1 << i)) == 0) { z.sqrTo(r, r2) t = r r = r2 r2 = t if (--i < 0) { i = this.DB - 1 --j } } } return z.revert(r) } // (public) gcd(this,a) (HAC 14.54) function bnGCD(a) { var x = (this.s < 0) ? this.negate() : this.clone() var y = (a.s < 0) ? a.negate() : a.clone() if (x.compareTo(y) < 0) { var t = x x = y y = t } var i = x.getLowestSetBit(), g = y.getLowestSetBit() if (g < 0) return x if (i < g) g = i if (g > 0) { x.rShiftTo(g, x) y.rShiftTo(g, y) } while (x.signum() > 0) { if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x) if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y) if (x.compareTo(y) >= 0) { x.subTo(y, x) x.rShiftTo(1, x) } else { y.subTo(x, y) y.rShiftTo(1, y) } } if (g > 0) y.lShiftTo(g, y) return y } // (protected) this % n, n < 2^26 function bnpModInt(n) { if (n <= 0) return 0 var d = this.DV % n, r = (this.s < 0) ? n - 1 : 0 if (this.t > 0) if (d == 0) r = this[0] % n else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n return r } // (public) 1/this % m (HAC 14.61) function bnModInverse(m) { var ac = m.isEven() if (this.signum() === 0) throw new Error('division by zero') if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO var u = m.clone(), v = this.clone() var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1) while (u.signum() != 0) { while (u.isEven()) { u.rShiftTo(1, u) if (ac) { if (!a.isEven() || !b.isEven()) { a.addTo(this, a) b.subTo(m, b) } a.rShiftTo(1, a) } else if (!b.isEven()) b.subTo(m, b) b.rShiftTo(1, b) } while (v.isEven()) { v.rShiftTo(1, v) if (ac) { if (!c.isEven() || !d.isEven()) { c.addTo(this, c) d.subTo(m, d) } c.rShiftTo(1, c) } else if (!d.isEven()) d.subTo(m, d) d.rShiftTo(1, d) } if (u.compareTo(v) >= 0) { u.subTo(v, u) if (ac) a.subTo(c, a) b.subTo(d, b) } else { v.subTo(u, v) if (ac) c.subTo(a, c) d.subTo(b, d) } } if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO while (d.compareTo(m) >= 0) d.subTo(m, d) while (d.signum() < 0) d.addTo(m, d) return d } var lowprimes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997 ] var lplim = (1 << 26) / lowprimes[lowprimes.length - 1] // (public) test primality with certainty >= 1-.5^t function bnIsProbablePrime(t) { var i, x = this.abs() if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) { for (i = 0; i < lowprimes.length; ++i) if (x[0] == lowprimes[i]) return true return false } if (x.isEven()) return false i = 1 while (i < lowprimes.length) { var m = lowprimes[i], j = i + 1 while (j < lowprimes.length && m < lplim) m *= lowprimes[j++] m = x.modInt(m) while (i < j) if (m % lowprimes[i++] == 0) return false } return x.millerRabin(t) } // (protected) true if probably prime (HAC 4.24, Miller-Rabin) function bnpMillerRabin(t) { var n1 = this.subtract(BigInteger.ONE) var k = n1.getLowestSetBit() if (k <= 0) return false var r = n1.shiftRight(k) t = (t + 1) >> 1 if (t > lowprimes.length) t = lowprimes.length var a = new BigInteger(null) var j, bases = [] for (var i = 0; i < t; ++i) { for (;;) { j = lowprimes[Math.floor(Math.random() * lowprimes.length)] if (bases.indexOf(j) == -1) break } bases.push(j) a.fromInt(j) var y = a.modPow(r, this) if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) { var j = 1 while (j++ < k && y.compareTo(n1) != 0) { y = y.modPowInt(2, this) if (y.compareTo(BigInteger.ONE) == 0) return false } if (y.compareTo(n1) != 0) return false } } return true } // protected proto.chunkSize = bnpChunkSize proto.toRadix = bnpToRadix proto.fromRadix = bnpFromRadix proto.fromNumber = bnpFromNumber proto.bitwiseTo = bnpBitwiseTo proto.changeBit = bnpChangeBit proto.addTo = bnpAddTo proto.dMultiply = bnpDMultiply proto.dAddOffset = bnpDAddOffset proto.multiplyLowerTo = bnpMultiplyLowerTo proto.multiplyUpperTo = bnpMultiplyUpperTo proto.modInt = bnpModInt proto.millerRabin = bnpMillerRabin // public proto.clone = bnClone proto.intValue = bnIntValue proto.byteValue = bnByteValue proto.shortValue = bnShortValue proto.signum = bnSigNum proto.toByteArray = bnToByteArray proto.equals = bnEquals proto.min = bnMin proto.max = bnMax proto.and = bnAnd proto.or = bnOr proto.xor = bnXor proto.andNot = bnAndNot proto.not = bnNot proto.shiftLeft = bnShiftLeft proto.shiftRight = bnShiftRight proto.getLowestSetBit = bnGetLowestSetBit proto.bitCount = bnBitCount proto.testBit = bnTestBit proto.setBit = bnSetBit proto.clearBit = bnClearBit proto.flipBit = bnFlipBit proto.add = bnAdd proto.subtract = bnSubtract proto.multiply = bnMultiply proto.divide = bnDivide proto.remainder = bnRemainder proto.divideAndRemainder = bnDivideAndRemainder proto.modPow = bnModPow proto.modInverse = bnModInverse proto.pow = bnPow proto.gcd = bnGCD proto.isProbablePrime = bnIsProbablePrime // JSBN-specific extension proto.square = bnSquare // constants BigInteger.ZERO = nbv(0) BigInteger.ONE = nbv(1) BigInteger.valueOf = nbv module.exports = BigInteger },{"../package.json":39}],37:[function(require,module,exports){ (function (Buffer){ // FIXME: Kind of a weird way to throw exceptions, consider removing var assert = require('assert') var BigInteger = require('./bigi') /** * Turns a byte array into a big integer. * * This function will interpret a byte array as a big integer in big * endian notation. */ BigInteger.fromByteArrayUnsigned = function(byteArray) { // BigInteger expects a DER integer conformant byte array if (byteArray[0] & 0x80) { return new BigInteger([0].concat(byteArray)) } return new BigInteger(byteArray) } /** * Returns a byte array representation of the big integer. * * This returns the absolute of the contained value in big endian * form. A value of zero results in an empty array. */ BigInteger.prototype.toByteArrayUnsigned = function() { var byteArray = this.toByteArray() return byteArray[0] === 0 ? byteArray.slice(1) : byteArray } BigInteger.fromDERInteger = function(byteArray) { return new BigInteger(byteArray) } /* * Converts BigInteger to a DER integer representation. * * The format for this value uses the most significant bit as a sign * bit. If the most significant bit is already set and the integer is * positive, a 0x00 is prepended. * * Examples: * * 0 => 0x00 * 1 => 0x01 * -1 => 0xff * 127 => 0x7f * -127 => 0x81 * 128 => 0x0080 * -128 => 0x80 * 255 => 0x00ff * -255 => 0xff01 * 16300 => 0x3fac * -16300 => 0xc054 * 62300 => 0x00f35c * -62300 => 0xff0ca4 */ BigInteger.prototype.toDERInteger = BigInteger.prototype.toByteArray BigInteger.fromBuffer = function(buffer) { // BigInteger expects a DER integer conformant byte array if (buffer[0] & 0x80) { var byteArray = Array.prototype.slice.call(buffer) return new BigInteger([0].concat(byteArray)) } return new BigInteger(buffer) } BigInteger.fromHex = function(hex) { if (hex === '') return BigInteger.ZERO assert.equal(hex, hex.match(/^[A-Fa-f0-9]+/), 'Invalid hex string') assert.equal(hex.length % 2, 0, 'Incomplete hex') return new BigInteger(hex, 16) } BigInteger.prototype.toBuffer = function(size) { var byteArray = this.toByteArrayUnsigned() var zeros = [] var padding = size - byteArray.length while (zeros.length < padding) zeros.push(0) return new Buffer(zeros.concat(byteArray)) } BigInteger.prototype.toHex = function(size) { return this.toBuffer(size).toString('hex') } }).call(this,require("buffer").Buffer) },{"./bigi":36,"assert":29,"buffer":75}],38:[function(require,module,exports){ var BigInteger = require('./bigi') //addons require('./convert') module.exports = BigInteger },{"./bigi":36,"./convert":37}],39:[function(require,module,exports){ module.exports={ "_from": "bigi@^1.2.0", "_id": "bigi@1.4.2", "_inBundle": false, "_integrity": "sha1-nGZalfiLiwj8Bc/XMfVhhZ1yWCU=", "_location": "/bigi", "_phantomChildren": {}, "_requested": { "type": "range", "registry": true, "raw": "bigi@^1.2.0", "name": "bigi", "escapedName": "bigi", "rawSpec": "^1.2.0", "saveSpec": null, "fetchSpec": "^1.2.0" }, "_requiredBy": [ "/bip38", "/ecurve" ], "_resolved": "https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz", "_shasum": "9c665a95f88b8b08fc05cfd731f561859d725825", "_spec": "bigi@^1.2.0", "_where": "/mnt/g/developer/digibyte/digiassets/digibytejs-wallet-client/node_modules/bip38", "bugs": { "url": "https://github.com/cryptocoinjs/bigi/issues" }, "bundleDependencies": false, "dependencies": {}, "deprecated": false, "description": "Big integers.", "devDependencies": { "coveralls": "^2.11.2", "istanbul": "^0.3.5", "jshint": "^2.5.1", "mocha": "^2.1.0", "mochify": "^2.1.0" }, "homepage": "https://github.com/cryptocoinjs/bigi#readme", "keywords": [ "cryptography", "math", "bitcoin", "arbitrary", "precision", "arithmetic", "big", "integer", "int", "number", "biginteger", "bigint", "bignumber", "decimal", "float" ], "main": "./lib/index.js", "name": "bigi", "repository": { "url": "git+https://github.com/cryptocoinjs/bigi.git", "type": "git" }, "scripts": { "browser-test": "mochify --wd -R spec", "coverage": "istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js", "coveralls": "npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info", "jshint": "jshint --config jshint.json lib/*.js ; true", "test": "_mocha -- test/*.js", "unit": "mocha" }, "testling": { "files": "test/*.js", "harness": "mocha", "browsers": [ "ie/9..latest", "firefox/latest", "chrome/latest", "safari/6.0..latest", "iphone/6.0..latest", "android-browser/4.2..latest" ] }, "version": "1.4.2" } },{}],40:[function(require,module,exports){ (function (Buffer){ var aes = require('browserify-aes') var assert = require('assert') var createHash = require('create-hash') var cs = require('coinstring') var scrypt = require('scryptsy') var xor = require('buffer-xor') var ecurve = require('ecurve') var curve = ecurve.getCurveByName('secp256k1') var BigInteger = require('bigi') // SHA256(SHA256(buffer)) function sha256x2 (buffer) { buffer = createHash('sha256').update(buffer).digest() return createHash('sha256').update(buffer).digest() } function Bip38 (versions) { if (!(this instanceof Bip38)) return new Bip38() // default to Bitcoin WIF versions this.versions = versions || { private: 0x80 } // BIP38 recommended this.scryptParams = { N: 16384, r: 8, p: 8 } } Bip38.prototype.encryptRaw = function (buffer, compressed, passphrase, saltAddress, progressCallback) { assert.equal(buffer.length, 32, 'Invalid private key length') var secret = new Buffer(passphrase, 'utf8') var salt = sha256x2(saltAddress).slice(0, 4) var N = this.scryptParams.N var r = this.scryptParams.r var p = this.scryptParams.p var scryptBuf = scrypt(secret, salt, N, r, p, 64, progressCallback) var derivedHalf1 = scryptBuf.slice(0, 32) var derivedHalf2 = scryptBuf.slice(32, 64) var xorBuf = xor(buffer, derivedHalf1) var cipher = aes.createCipheriv('aes-256-ecb', derivedHalf2, new Buffer(0)) cipher.setAutoPadding(false) cipher.end(xorBuf) var cipherText = cipher.read() // 0x01 + 0x42 + flagByte + salt + cipherText var flagByte = compressed ? 0xe0 : 0xc0 var prefix = new Buffer(3) prefix.writeUInt8(0x01, 0) prefix.writeUInt8(0x42, 1) prefix.writeUInt8(flagByte, 2) return Buffer.concat([prefix, salt, cipherText]) } Bip38.prototype.encrypt = function (wif, passphrase, saltAddress, progressCallback) { var d = cs.decode(wif).slice(1) var compressed = (d.length === 33) && (d[32] === 0x01) // truncate the compression flag if (compressed) { d = d.slice(0, -1) } return cs.encode(this.encryptRaw(d, compressed, passphrase, saltAddress, progressCallback)) } // some of the techniques borrowed from: https://github.com/pointbiz/bitaddress.org // todo: (optimization) init buffer in advance, and use copy instead of concat Bip38.prototype.decryptRaw = function (encData, passphrase, progressCallback) { // 39 bytes: 2 bytes prefix, 37 bytes payload assert.equal(encData.length, 39, 'Invalid BIP38 data length') // first byte is always 0x01 assert.equal(encData.readUInt8(0), 0x01, 'Invalid BIP38 prefix') // check if BIP38 EC multiply var type = encData.readUInt8(1) if (type === 0x43) { return this.decryptECMult(encData, passphrase, progressCallback) } passphrase = new Buffer(passphrase, 'utf8') assert.equal(type, 0x42, 'Invalid BIP38 type') var flagByte = encData.readUInt8(2) var compressed = flagByte === 0xe0 if (!compressed) { assert.equal(flagByte, 0xc0, 'Invalid BIP38 compression flag') } var N = this.scryptParams.N var r = this.scryptParams.r var p = this.scryptParams.p var addresshash = encData.slice(3, 7) var scryptBuf = scrypt(passphrase, addresshash, N, r, p, 64, progressCallback) var derivedHalf1 = scryptBuf.slice(0, 32) var derivedHalf2 = scryptBuf.slice(32, 64) var privKeyBuf = encData.slice(7, 7 + 32) var decipher = aes.createDecipheriv('aes-256-ecb', derivedHalf2, new Buffer(0)) decipher.setAutoPadding(false) decipher.end(privKeyBuf) var plainText = decipher.read() var privateKey = xor(plainText, derivedHalf1) return { privateKey: privateKey, compressed: compressed } } Bip38.prototype.decrypt = function (encryptedBase58, passphrase, progressCallback) { var encBuffer = cs.decode(encryptedBase58) var decrypt = this.decryptRaw(encBuffer, passphrase, progressCallback) // Convert to WIF var bufferLen = decrypt.compressed ? 34 : 33 var buffer = new Buffer(bufferLen) buffer.writeUInt8(this.versions.private, 0) decrypt.privateKey.copy(buffer, 1) if (decrypt.compressed) { buffer.writeUInt8(0x01, 33) } return cs.encode(buffer) } Bip38.prototype.decryptECMult = function (encData, passphrase, progressCallback) { passphrase = new Buffer(passphrase, 'utf8') encData = encData.slice(1) // FIXME: we can avoid this var compressed = (encData[1] & 0x20) !== 0 var hasLotSeq = (encData[1] & 0x04) !== 0 assert.equal((encData[1] & 0x24), encData[1], 'Invalid private key.') var addresshash = encData.slice(2, 6) var ownerEntropy = encData.slice(6, 14) var ownerSalt // 4 bytes ownerSalt if 4 bytes lot/sequence if (hasLotSeq) { ownerSalt = ownerEntropy.slice(0, 4) // else, 8 bytes ownerSalt } else { ownerSalt = ownerEntropy } var encryptedPart1 = encData.slice(14, 22) // First 8 bytes var encryptedPart2 = encData.slice(22, 38) // 16 bytes var N = this.scryptParams.N var r = this.scryptParams.r var p = this.scryptParams.p var preFactor = scrypt(passphrase, ownerSalt, N, r, p, 32, progressCallback) var passFactor if (hasLotSeq) { var hashTarget = Buffer.concat([preFactor, ownerEntropy]) passFactor = sha256x2(hashTarget) } else { passFactor = preFactor } var passInt = BigInteger.fromBuffer(passFactor) var passPoint = curve.G.multiply(passInt).getEncoded(true) var seedBPass = scrypt(passPoint, Buffer.concat([addresshash, ownerEntropy]), 1024, 1, 1, 64) var derivedHalf1 = seedBPass.slice(0, 32) var derivedHalf2 = seedBPass.slice(32, 64) var decipher = aes.createDecipheriv('aes-256-ecb', derivedHalf2, new Buffer(0)) decipher.setAutoPadding(false) decipher.end(encryptedPart2) var decryptedPart2 = decipher.read() var tmp = xor(decryptedPart2, derivedHalf1.slice(16, 32)) var seedBPart2 = tmp.slice(8, 16) var decipher2 = aes.createDecipheriv('aes-256-ecb', derivedHalf2, new Buffer(0)) decipher2.setAutoPadding(false) decipher2.write(encryptedPart1) // first 8 bytes decipher2.end(tmp.slice(0, 8)) // last 8 bytes var seedBPart1 = xor(decipher2.read(), derivedHalf1.slice(0, 16)) var seedB = Buffer.concat([seedBPart1, seedBPart2], 24) var factorB = sha256x2(seedB) // d = passFactor * factorB (mod n) var d = passInt.multiply(BigInteger.fromBuffer(factorB)).mod(curve.n) return { privateKey: d.toBuffer(32), compressed: compressed } } Bip38.prototype.verify = function (encryptedBase58) { var decoded try { decoded = cs.decode(encryptedBase58) } catch (e) { return false } if (decoded.length !== 39) return false if (decoded.readUInt8(0) !== 0x01) return false var type = decoded.readUInt8(1) var flag = decoded.readUInt8(2) // encrypted WIF if (type === 0x42) { if (flag !== 0xc0 && flag !== 0xe0) return false // EC mult } else if (type === 0x43) { if ((flag & ~0x24)) return false } else { return false } return true } module.exports = Bip38 }).call(this,require("buffer").Buffer) },{"assert":29,"bigi":38,"browserify-aes":46,"buffer":75,"buffer-xor":74,"coinstring":79,"create-hash":83,"ecurve":165,"scryptsy":263}],41:[function(require,module,exports){ (function (module, exports) { 'use strict'; // Utils function assert (val, msg) { if (!val) throw new Error(msg || 'Assertion failed'); } // Could use `inherits` module, but don't want to move from single file // architecture yet. function inherits (ctor, superCtor) { ctor.super_ = superCtor; var TempCtor = function () {}; TempCtor.prototype = superCtor.prototype; ctor.prototype = new TempCtor(); ctor.prototype.constructor = ctor; } // BN function BN (number, base, endian) { if (BN.isBN(number)) { return number; } this.negative = 0; this.words = null; this.length = 0; // Reduction context this.red = null; if (number !== null) { if (base === 'le' || base === 'be') { endian = base; base = 10; } this._init(number || 0, base || 10, endian || 'be'); } } if (typeof module === 'object') { module.exports = BN; } else { exports.BN = BN; } BN.BN = BN; BN.wordSize = 26; var Buffer; try { Buffer = require('buffer').Buffer; } catch (e) { } BN.isBN = function isBN (num) { if (num instanceof BN) { return true; } return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words); }; BN.max = function max (left, right) { if (left.cmp(right) > 0) return left; return right; }; BN.min = function min (left, right) { if (left.cmp(right) < 0) return left; return right; }; BN.prototype._init = function init (number, base, endian) { if (typeof number === 'number') { return this._initNumber(number, base, endian); } if (typeof number === 'object') { return this._initArray(number, base, endian); } if (base === 'hex') { base = 16; } assert(base === (base | 0) && base >= 2 && base <= 36); number = number.toString().replace(/\s+/g, ''); var start = 0; if (number[0] === '-') { start++; } if (base === 16) { this._parseHex(number, start); } else { this._parseBase(number, base, start); } if (number[0] === '-') { this.negative = 1; } this.strip(); if (endian !== 'le') return; this._initArray(this.toArray(), base, endian); }; BN.prototype._initNumber = function _initNumber (number, base, endian) { if (number < 0) { this.negative = 1; number = -number; } if (number < 0x4000000) { this.words = [ number & 0x3ffffff ]; this.length = 1; } else if (number < 0x10000000000000) { this.words = [ number & 0x3ffffff, (number / 0x4000000) & 0x3ffffff ]; this.length = 2; } else { assert(number < 0x20000000000000); // 2 ^ 53 (unsafe) this.words = [ number & 0x3ffffff, (number / 0x4000000) & 0x3ffffff, 1 ]; this.length = 3; } if (endian !== 'le') return; // Reverse the bytes this._initArray(this.toArray(), base, endian); }; BN.prototype._initArray = function _initArray (number, base, endian) { // Perhaps a Uint8Array assert(typeof number.length === 'number'); if (number.length <= 0) { this.words = [ 0 ]; this.length = 1; return this; } this.length = Math.ceil(number.length / 3); this.words = new Array(this.length); for (var i = 0; i < this.length; i++) { this.words[i] = 0; } var j, w; var off = 0; if (endian === 'be') { for (i = number.length - 1, j = 0; i >= 0; i -= 3) { w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16); this.words[j] |= (w << off) & 0x3ffffff; this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff; off += 24; if (off >= 26) { off -= 26; j++; } } } else if (endian === 'le') { for (i = 0, j = 0; i < number.length; i += 3) { w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16); this.words[j] |= (w << off) & 0x3ffffff; this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff; off += 24; if (off >= 26) { off -= 26; j++; } } } return this.strip(); }; function parseHex (str, start, end) { var r = 0; var len = Math.min(str.length, end); for (var i = start; i < len; i++) { var c = str.charCodeAt(i) - 48; r <<= 4; // 'a' - 'f' if (c >= 49 && c <= 54) { r |= c - 49 + 0xa; // 'A' - 'F' } else if (c >= 17 && c <= 22) { r |= c - 17 + 0xa; // '0' - '9' } else { r |= c & 0xf; } } return r; } BN.prototype._parseHex = function _parseHex (number, start) { // Create possibly bigger array to ensure that it fits the number this.length = Math.ceil((number.length - start) / 6); this.words = new Array(this.length); for (var i = 0; i < this.length; i++) { this.words[i] = 0; } var j, w; // Scan 24-bit chunks and add them to the number var off = 0; for (i = number.length - 6, j = 0; i >= start; i -= 6) { w = parseHex(number, i, i + 6); this.words[j] |= (w << off) & 0x3ffffff; // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb this.words[j + 1] |= w >>> (26 - off) & 0x3fffff; off += 24; if (off >= 26) { off -= 26; j++; } } if (i + 6 !== start) { w = parseHex(number, start, i + 6); this.words[j] |= (w << off) & 0x3ffffff; this.words[j + 1] |= w >>> (26 - off) & 0x3fffff; } this.strip(); }; function parseBase (str, start, end, mul) { var r = 0; var len = Math.min(str.length, end); for (var i = start; i < len; i++) { var c = str.charCodeAt(i) - 48; r *= mul; // 'a' if (c >= 49) { r += c - 49 + 0xa; // 'A' } else if (c >= 17) { r += c - 17 + 0xa; // '0' - '9' } else { r += c; } } return r; } BN.prototype._parseBase = function _parseBase (number, base, start) { // Initialize as zero this.words = [ 0 ]; this.length = 1; // Find length of limb in base for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) { limbLen++; } limbLen--; limbPow = (limbPow / base) | 0; var total = number.length - start; var mod = total % limbLen; var end = Math.min(total, total - mod) + start; var word = 0; for (var i = start; i < end; i += limbLen) { word = parseBase(number, i, i + limbLen, base); this.imuln(limbPow); if (this.words[0] + word < 0x4000000) { this.words[0] += word; } else { this._iaddn(word); } } if (mod !== 0) { var pow = 1; word = parseBase(number, i, number.length, base); for (i = 0; i < mod; i++) { pow *= base; } this.imuln(pow); if (this.words[0] + word < 0x4000000) { this.words[0] += word; } else { this._iaddn(word); } } }; BN.prototype.copy = function copy (dest) { dest.words = new Array(this.length); for (var i = 0; i < this.length; i++) { dest.words[i] = this.words[i]; } dest.length = this.length; dest.negative = this.negative; dest.red = this.red; }; BN.prototype.clone = function clone () { var r = new BN(null); this.copy(r); return r; }; BN.prototype._expand = function _expand (size) { while (this.length < size) { this.words[this.length++] = 0; } return this; }; // Remove leading `0` from `this` BN.prototype.strip = function strip () { while (this.length > 1 && this.words[this.length - 1] === 0) { this.length--; } return this._normSign(); }; BN.prototype._normSign = function _normSign () { // -0 = 0 if (this.length === 1 && this.words[0] === 0) { this.negative = 0; } return this; }; BN.prototype.inspect = function inspect () { return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>'; }; /* var zeros = []; var groupSizes = []; var groupBases = []; var s = ''; var i = -1; while (++i < BN.wordSize) { zeros[i] = s; s += '0'; } groupSizes[0] = 0; groupSizes[1] = 0; groupBases[0] = 0; groupBases[1] = 0; var base = 2 - 1; while (++base < 36 + 1) { var groupSize = 0; var groupBase = 1; while (groupBase < (1 << BN.wordSize) / base) { groupBase *= base; groupSize += 1; } groupSizes[base] = groupSize; groupBases[base] = groupBase; } */ var zeros = [ '', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000' ]; var groupSizes = [ 0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 ]; var groupBases = [ 0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176 ]; BN.prototype.toString = function toString (base, padding) { base = base || 10; padding = padding | 0 || 1; var out; if (base === 16 || base === 'hex') { out = ''; var off = 0; var carry = 0; for (var i = 0; i < this.length; i++) { var w = this.words[i]; var word = (((w << off) | carry) & 0xffffff).toString(16); carry = (w >>> (24 - off)) & 0xffffff; if (carry !== 0 || i !== this.length - 1) { out = zeros[6 - word.length] + word + out; } else { out = word + out; } off += 2; if (off >= 26) { off -= 26; i--; } } if (carry !== 0) { out = carry.toString(16) + out; } while (out.length % padding !== 0) { out = '0' + out; } if (this.negative !== 0) { out = '-' + out; } return out; } if (base === (base | 0) && base >= 2 && base <= 36) { // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base)); var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize); var groupBase = groupBases[base]; out = ''; var c = this.clone(); c.negative = 0; while (!c.isZero()) { var r = c.modn(groupBase).toString(base); c = c.idivn(groupBase); if (!c.isZero()) { out = zeros[groupSize - r.length] + r + out; } else { out = r + out; } } if (this.isZero()) { out = '0' + out; } while (out.length % padding !== 0) { out = '0' + out; } if (this.negative !== 0) { out = '-' + out; } return out; } assert(false, 'Base should be between 2 and 36'); }; BN.prototype.toNumber = function toNumber () { var ret = this.words[0]; if (this.length === 2) { ret += this.words[1] * 0x4000000; } else if (this.length === 3 && this.words[2] === 0x01) { // NOTE: at this stage it is known that the top bit is set ret += 0x10000000000000 + (this.words[1] * 0x4000000); } else if (this.length > 2) { assert(false, 'Number can only safely store up to 53 bits'); } return (this.negative !== 0) ? -ret : ret; }; BN.prototype.toJSON = function toJSON () { return this.toString(16); }; BN.prototype.toBuffer = function toBuffer (endian, length) { assert(typeof Buffer !== 'undefined'); return this.toArrayLike(Buffer, endian, length); }; BN.prototype.toArray = function toArray (endian, length) { return this.toArrayLike(Array, endian, length); }; BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) { var byteLength = this.byteLength(); var reqLength = length || Math.max(1, byteLength); assert(byteLength <= reqLength, 'byte array longer than desired length'); assert(reqLength > 0, 'Requested array length <= 0'); this.strip(); var littleEndian = endian === 'le'; var res = new ArrayType(reqLength); var b, i; var q = this.clone(); if (!littleEndian) { // Assume big-endian for (i = 0; i < reqLength - byteLength; i++) { res[i] = 0; } for (i = 0; !q.isZero(); i++) { b = q.andln(0xff); q.iushrn(8); res[reqLength - i - 1] = b; } } else { for (i = 0; !q.isZero(); i++) { b = q.andln(0xff); q.iushrn(8); res[i] = b; } for (; i < reqLength; i++) { res[i] = 0; } } return res; }; if (Math.clz32) { BN.prototype._countBits = function _countBits (w) { return 32 - Math.clz32(w); }; } else { BN.prototype._countBits = function _countBits (w) { var t = w; var r = 0; if (t >= 0x1000) { r += 13; t >>>= 13; } if (t >= 0x40) { r += 7; t >>>= 7; } if (t >= 0x8) { r += 4; t >>>= 4; } if (t >= 0x02) { r += 2; t >>>= 2; } return r + t; }; } BN.prototype._zeroBits = function _zeroBits (w) { // Short-cut if (w === 0) return 26; var t = w; var r = 0; if ((t & 0x1fff) === 0) { r += 13; t >>>= 13; } if ((t & 0x7f) === 0) { r += 7; t >>>= 7; } if ((t & 0xf) === 0) { r += 4; t >>>= 4; } if ((t & 0x3) === 0) { r += 2; t >>>= 2; } if ((t & 0x1) === 0) { r++; } return r; }; // Return number of used bits in a BN BN.prototype.bitLength = function bitLength () { var w = this.words[this.length - 1]; var hi = this._countBits(w); return (this.length - 1) * 26 + hi; }; function toBitArray (num) { var w = new Array(num.bitLength()); for (var bit = 0; bit < w.length; bit++) { var off = (bit / 26) | 0; var wbit = bit % 26; w[bit] = (num.words[off] & (1 << wbit)) >>> wbit; } return w; } // Number of trailing zero bits BN.prototype.zeroBits = function zeroBits () { if (this.isZero()) return 0; var r = 0; for (var i = 0; i < this.length; i++) { var b = this._zeroBits(this.words[i]); r += b; if (b !== 26) break; } return r; }; BN.prototype.byteLength = function byteLength () { return Math.ceil(this.bitLength() / 8); }; BN.prototype.toTwos = function toTwos (width) { if (this.negative !== 0) { return this.abs().inotn(width).iaddn(1); } return this.clone(); }; BN.prototype.fromTwos = function fromTwos (width) { if (this.testn(width - 1)) { return this.notn(width).iaddn(1).ineg(); } return this.clone(); }; BN.prototype.isNeg = function isNeg () { return this.negative !== 0; }; // Return negative clone of `this` BN.prototype.neg = function neg () { return this.clone().ineg(); }; BN.prototype.ineg = function ineg () { if (!this.isZero()) { this.negative ^= 1; } return this; }; // Or `num` with `this` in-place BN.prototype.iuor = function iuor (num) { while (this.length < num.length) { this.words[this.length++] = 0; } for (var i = 0; i < num.length; i++) { this.words[i] = this.words[i] | num.words[i]; } return this.strip(); }; BN.prototype.ior = function ior (num) { assert((this.negative | num.negative) === 0); return this.iuor(num); }; // Or `num` with `this` BN.prototype.or = function or (num) { if (this.length > num.length) return this.clone().ior(num); return num.clone().ior(this); }; BN.prototype.uor = function uor (num) { if (this.length > num.length) return this.clone().iuor(num); return num.clone().iuor(this); }; // And `num` with `this` in-place BN.prototype.iuand = function iuand (num) { // b = min-length(num, this) var b; if (this.length > num.length) { b = num; } else { b = this; } for (var i = 0; i < b.length; i++) { this.words[i] = this.words[i] & num.words[i]; } this.length = b.length; return this.strip(); }; BN.prototype.iand = function iand (num) { assert((this.negative | num.negative) === 0); return this.iuand(num); }; // And `num` with `this` BN.prototype.and = function and (num) { if (this.length > num.length) return this.clone().iand(num); return num.clone().iand(this); }; BN.prototype.uand = function uand (num) { if (this.length > num.length) return this.clone().iuand(num); return num.clone().iuand(this); }; // Xor `num` with `this` in-place BN.prototype.iuxor = function iuxor (num) { // a.length > b.length var a; var b; if (this.length > num.length) { a = this; b = num; } else { a = num; b = this; } for (var i = 0; i < b.length; i++) { this.words[i] = a.words[i] ^ b.words[i]; } if (this !== a) { for (; i < a.length; i++) { this.words[i] = a.words[i]; } } this.length = a.length; return this.strip(); }; BN.prototype.ixor = function ixor (num) { assert((this.negative | num.negative) === 0); return this.iuxor(num); }; // Xor `num` with `this` BN.prototype.xor = function xor (num) { if (this.length > num.length) return this.clone().ixor(num); return num.clone().ixor(this); }; BN.prototype.uxor = function uxor (num) { if (this.length > num.length) return this.clone().iuxor(num); return num.clone().iuxor(this); }; // Not ``this`` with ``width`` bitwidth BN.prototype.inotn = function inotn (width) { assert(typeof width === 'number' && width >= 0); var bytesNeeded = Math.ceil(width / 26) | 0; var bitsLeft = width % 26; // Extend the buffer with leading zeroes this._expand(bytesNeeded); if (bitsLeft > 0) { bytesNeeded--; } // Handle complete words for (var i = 0; i < bytesNeeded; i++) { this.words[i] = ~this.words[i] & 0x3ffffff; } // Handle the residue if (bitsLeft > 0) { this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft)); } // And remove leading zeroes return this.strip(); }; BN.prototype.notn = function notn (width) { return this.clone().inotn(width); }; // Set `bit` of `this` BN.prototype.setn = function setn (bit, val) { assert(typeof bit === 'number' && bit >= 0); var off = (bit / 26) | 0; var wbit = bit % 26; this._expand(off + 1); if (val) { this.words[off] = this.words[off] | (1 << wbit); } else { this.words[off] = this.words[off] & ~(1 << wbit); } return this.strip(); }; // Add `num` to `this` in-place BN.prototype.iadd = function iadd (num) { var r; // negative + positive if (this.negative !== 0 && num.negative === 0) { this.negative = 0; r = this.isub(num); this.negative ^= 1; return this._normSign(); // positive + negative } else if (this.negative === 0 && num.negative !== 0) { num.negative = 0; r = this.isub(num); num.negative = 1; return r._normSign(); } // a.length > b.length var a, b; if (this.length > num.length) { a = this; b = num; } else { a = num; b = this; } var carry = 0; for (var i = 0; i < b.length; i++) { r = (a.words[i] | 0) + (b.words[i] | 0) + carry; this.words[i] = r & 0x3ffffff; carry = r >>> 26; } for (; carry !== 0 && i < a.length; i++) { r = (a.words[i] | 0) + carry; this.words[i] = r & 0x3ffffff; carry = r >>> 26; } this.length = a.length; if (carry !== 0) { this.words[this.length] = carry; this.length++; // Copy the rest of the words } else if (a !== this) { for (; i < a.length; i++) { this.words[i] = a.words[i]; } } return this; }; // Add `num` to `this` BN.prototype.add = function add (num) { var res; if (num.negative !== 0 && this.negative === 0) { num.negative = 0; res = this.sub(num); num.negative ^= 1; return res; } else if (num.negative === 0 && this.negative !== 0) { this.negative = 0; res = num.sub(this); this.negative = 1; return res; } if (this.length > num.length) return this.clone().iadd(num); return num.clone().iadd(this); }; // Subtract `num` from `this` in-place BN.prototype.isub = function isub (num) { // this - (-num) = this + num if (num.negative !== 0) { num.negative = 0; var r = this.iadd(num); num.negative = 1; return r._normSign(); // -this - num = -(this + num) } else if (this.negative !== 0) { this.negative = 0; this.iadd(num); this.negative = 1; return this._normSign(); } // At this point both numbers are positive var cmp = this.cmp(num); // Optimization - zeroify if (cmp === 0) { this.negative = 0; this.length = 1; this.words[0] = 0; return this; } // a > b var a, b; if (cmp > 0) { a = this; b = num; } else { a = num; b = this; } var carry = 0; for (var i = 0; i < b.length; i++) { r = (a.words[i] | 0) - (b.words[i] | 0) + carry; carry = r >> 26; this.words[i] = r & 0x3ffffff; } for (; carry !== 0 && i < a.length; i++) { r = (a.words[i] | 0) + carry; carry = r >> 26; this.words[i] = r & 0x3ffffff; } // Copy rest of the words if (carry === 0 && i < a.length && a !== this) { for (; i < a.length; i++) { this.words[i] = a.words[i]; } } this.length = Math.max(this.length, i); if (a !== this) { this.negative = 1; } return this.strip(); }; // Subtract `num` from `this` BN.prototype.sub = function sub (num) { return this.clone().isub(num); }; function smallMulTo (self, num, out) { out.negative = num.negative ^ self.negative; var len = (self.length + num.length) | 0; out.length = len; len = (len - 1) | 0; // Peel one iteration (compiler can't do it, because of code complexity) var a = self.words[0] | 0; var b = num.words[0] | 0; var r = a * b; var lo = r & 0x3ffffff; var carry = (r / 0x4000000) | 0; out.words[0] = lo; for (var k = 1; k < len; k++) { // Sum all words with the same `i + j = k` and accumulate `ncarry`, // note that ncarry could be >= 0x3ffffff var ncarry = carry >>> 26; var rword = carry & 0x3ffffff; var maxJ = Math.min(k, num.length - 1); for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) { var i = (k - j) | 0; a = self.words[i] | 0; b = num.words[j] | 0; r = a * b + rword; ncarry += (r / 0x4000000) | 0; rword = r & 0x3ffffff; } out.words[k] = rword | 0; carry = ncarry | 0; } if (carry !== 0) { out.words[k] = carry | 0; } else { out.length--; } return out.strip(); } // TODO(indutny): it may be reasonable to omit it for users who don't need // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit // multiplication (like elliptic secp256k1). var comb10MulTo = function comb10MulTo (self, num, out) { var a = self.words; var b = num.words; var o = out.words; var c = 0; var lo; var mid; var hi; var a0 = a[0] | 0; var al0 = a0 & 0x1fff; var ah0 = a0 >>> 13; var a1 = a[1] | 0; var al1 = a1 & 0x1fff; var ah1 = a1 >>> 13; var a2 = a[2] | 0; var al2 = a2 & 0x1fff; var ah2 = a2 >>> 13; var a3 = a[3] | 0; var al3 = a3 & 0x1fff; var ah3 = a3 >>> 13; var a4 = a[4] | 0; var al4 = a4 & 0x1fff; var ah4 = a4 >>> 13; var a5 = a[5] | 0; var al5 = a5 & 0x1fff; var ah5 = a5 >>> 13; var a6 = a[6] | 0; var al6 = a6 & 0x1fff; var ah6 = a6 >>> 13; var a7 = a[7] | 0; var al7 = a7 & 0x1fff; var ah7 = a7 >>> 13; var a8 = a[8] | 0; var al8 = a8 & 0x1fff; var ah8 = a8 >>> 13; var a9 = a[9] | 0; var al9 = a9 & 0x1fff; var ah9 = a9 >>> 13; var b0 = b[0] | 0; var bl0 = b0 & 0x1fff; var bh0 = b0 >>> 13; var b1 = b[1] | 0; var bl1 = b1 & 0x1fff; var bh1 = b1 >>> 13; var b2 = b[2] | 0; var bl2 = b2 & 0x1fff; var bh2 = b2 >>> 13; var b3 = b[3] | 0; var bl3 = b3 & 0x1fff; var bh3 = b3 >>> 13; var b4 = b[4] | 0; var bl4 = b4 & 0x1fff; var bh4 = b4 >>> 13; var b5 = b[5] | 0; var bl5 = b5 & 0x1fff; var bh5 = b5 >>> 13; var b6 = b[6] | 0; var bl6 = b6 & 0x1fff; var bh6 = b6 >>> 13; var b7 = b[7] | 0; var bl7 = b7 & 0x1fff; var bh7 = b7 >>> 13; var b8 = b[8] | 0; var bl8 = b8 & 0x1fff; var bh8 = b8 >>> 13; var b9 = b[9] | 0; var bl9 = b9 & 0x1fff; var bh9 = b9 >>> 13; out.negative = self.negative ^ num.negative; out.length = 19; /* k = 0 */ lo = Math.imul(al0, bl0); mid = Math.imul(al0, bh0); mid = (mid + Math.imul(ah0, bl0)) | 0; hi = Math.imul(ah0, bh0); var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0; w0 &= 0x3ffffff; /* k = 1 */ lo = Math.imul(al1, bl0); mid = Math.imul(al1, bh0); mid = (mid + Math.imul(ah1, bl0)) | 0; hi = Math.imul(ah1, bh0); lo = (lo + Math.imul(al0, bl1)) | 0; mid = (mid + Math.imul(al0, bh1)) | 0; mid = (mid + Math.imul(ah0, bl1)) | 0; hi = (hi + Math.imul(ah0, bh1)) | 0; var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0; w1 &= 0x3ffffff; /* k = 2 */ lo = Math.imul(al2, bl0); mid = Math.imul(al2, bh0); mid = (mid + Math.imul(ah2, bl0)) | 0; hi = Math.imul(ah2, bh0); lo = (lo + Math.imul(al1, bl1)) | 0; mid = (mid + Math.imul(al1, bh1)) | 0; mid = (mid + Math.imul(ah1, bl1)) | 0; hi = (hi + Math.imul(ah1, bh1)) | 0; lo = (lo + Math.imul(al0, bl2)) | 0; mid = (mid + Math.imul(al0, bh2)) | 0; mid = (mid + Math.imul(ah0, bl2)) | 0; hi = (hi + Math.imul(ah0, bh2)) | 0; var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0; w2 &= 0x3ffffff; /* k = 3 */ lo = Math.imul(al3, bl0); mid = Math.imul(al3, bh0); mid = (mid + Math.imul(ah3, bl0)) | 0; hi = Math.imul(ah3, bh0); lo = (lo + Math.imul(al2, bl1)) | 0; mid = (mid + Math.imul(al2, bh1)) | 0; mid = (mid + Math.imul(ah2, bl1)) | 0; hi = (hi + Math.imul(ah2, bh1)) | 0; lo = (lo + Math.imul(al1, bl2)) | 0; mid = (mid + Math.imul(al1, bh2)) | 0; mid = (mid + Math.imul(ah1, bl2)) | 0; hi = (hi + Math.imul(ah1, bh2)) | 0; lo = (lo + Math.imul(al0, bl3)) | 0; mid = (mid + Math.imul(al0, bh3)) | 0; mid = (mid + Math.imul(ah0, bl3)) | 0; hi = (hi + Math.imul(ah0, bh3)) | 0; var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0; w3 &= 0x3ffffff; /* k = 4 */ lo = Math.imul(al4, bl0); mid = Math.imul(al4, bh0); mid = (mid + Math.imul(ah4, bl0)) | 0; hi = Math.imul(ah4, bh0); lo = (lo + Math.imul(al3, bl1)) | 0; mid = (mid + Math.imul(al3, bh1)) | 0; mid = (mid + Math.imul(ah3, bl1)) | 0; hi = (hi + Math.imul(ah3, bh1)) | 0; lo = (lo + Math.imul(al2, bl2)) | 0; mid = (mid + Math.imul(al2, bh2)) | 0; mid = (mid + Math.imul(ah2, bl2)) | 0; hi = (hi + Math.imul(ah2, bh2)) | 0; lo = (lo + Math.imul(al1, bl3)) | 0; mid = (mid + Math.imul(al1, bh3)) | 0; mid = (mid + Math.imul(ah1, bl3)) | 0; hi = (hi + Math.imul(ah1, bh3)) | 0; lo = (lo + Math.imul(al0, bl4)) | 0; mid = (mid + Math.imul(al0, bh4)) | 0; mid = (mid + Math.imul(ah0, bl4)) | 0; hi = (hi + Math.imul(ah0, bh4)) | 0; var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0; w4 &= 0x3ffffff; /* k = 5 */ lo = Math.imul(al5, bl0); mid = Math.imul(al5, bh0); mid = (mid + Math.imul(ah5, bl0)) | 0; hi = Math.imul(ah5, bh0); lo = (lo + Math.imul(al4, bl1)) | 0; mid = (mid + Math.imul(al4, bh1)) | 0; mid = (mid + Math.imul(ah4, bl1)) | 0; hi = (hi + Math.imul(ah4, bh1)) | 0; lo = (lo + Math.imul(al3, bl2)) | 0; mid = (mid + Math.imul(al3, bh2)) | 0; mid = (mid + Math.imul(ah3, bl2)) | 0; hi = (hi + Math.imul(ah3, bh2)) | 0; lo = (lo + Math.imul(al2, bl3)) | 0; mid = (mid + Math.imul(al2, bh3)) | 0; mid = (mid + Math.imul(ah2, bl3)) | 0; hi = (hi + Math.imul(ah2, bh3)) | 0; lo = (lo + Math.imul(al1, bl4)) | 0; mid = (mid + Math.imul(al1, bh4)) | 0; mid = (mid + Math.imul(ah1, bl4)) | 0; hi = (hi + Math.imul(ah1, bh4)) | 0; lo = (lo + Math.imul(al0, bl5)) | 0; mid = (mid + Math.imul(al0, bh5)) | 0; mid = (mid + Math.imul(ah0, bl5)) | 0; hi = (hi + Math.imul(ah0, bh5)) | 0; var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0; w5 &= 0x3ffffff; /* k = 6 */ lo = Math.imul(al6, bl0); mid = Math.imul(al6, bh0); mid = (mid + Math.imul(ah6, bl0)) | 0; hi = Math.imul(ah6, bh0); lo = (lo + Math.imul(al5, bl1)) | 0; mid = (mid + Math.imul(al5, bh1)) | 0; mid = (mid + Math.imul(ah5, bl1)) | 0; hi = (hi + Math.imul(ah5, bh1)) | 0; lo = (lo + Math.imul(al4, bl2)) | 0; mid = (mid + Math.imul(al4, bh2)) | 0; mid = (mid + Math.imul(ah4, bl2)) | 0; hi = (hi + Math.imul(ah4, bh2)) | 0; lo = (lo + Math.imul(al3, bl3)) | 0; mid = (mid + Math.imul(al3, bh3)) | 0; mid = (mid + Math.imul(ah3, bl3)) | 0; hi = (hi + Math.imul(ah3, bh3)) | 0; lo = (lo + Math.imul(al2, bl4)) | 0; mid = (mid + Math.imul(al2, bh4)) | 0; mid = (mid + Math.imul(ah2, bl4)) | 0; hi = (hi + Math.imul(ah2, bh4)) | 0; lo = (lo + Math.imul(al1, bl5)) | 0; mid = (mid + Math.imul(al1, bh5)) | 0; mid = (mid + Math.imul(ah1, bl5)) | 0; hi = (hi + Math.imul(ah1, bh5)) | 0; lo = (lo + Math.imul(al0, bl6)) | 0; mid = (mid + Math.imul(al0, bh6)) | 0; mid = (mid + Math.imul(ah0, bl6)) | 0; hi = (hi + Math.imul(ah0, bh6)) | 0; var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0; w6 &= 0x3ffffff; /* k = 7 */ lo = Math.imul(al7, bl0); mid = Math.imul(al7, bh0); mid = (mid + Math.imul(ah7, bl0)) | 0; hi = Math.imul(ah7, bh0); lo = (lo + Math.imul(al6, bl1)) | 0; mid = (mid + Math.imul(al6, bh1)) | 0; mid = (mid + Math.imul(ah6, bl1)) | 0; hi = (hi + Math.imul(ah6, bh1)) | 0; lo = (lo + Math.imul(al5, bl2)) | 0; mid = (mid + Math.imul(al5, bh2)) | 0; mid = (mid + Math.imul(ah5, bl2)) | 0; hi = (hi + Math.imul(ah5, bh2)) | 0; lo = (lo + Math.imul(al4, bl3)) | 0; mid = (mid + Math.imul(al4, bh3)) | 0; mid = (mid + Math.imul(ah4, bl3)) | 0; hi = (hi + Math.imul(ah4, bh3)) | 0; lo = (lo + Math.imul(al3, bl4)) | 0; mid = (mid + Math.imul(al3, bh4)) | 0; mid = (mid + Math.imul(ah3, bl4)) | 0; hi = (hi + Math.imul(ah3, bh4)) | 0; lo = (lo + Math.imul(al2, bl5)) | 0; mid = (mid + Math.imul(al2, bh5)) | 0; mid = (mid + Math.imul(ah2, bl5)) | 0; hi = (hi + Math.imul(ah2, bh5)) | 0; lo = (lo + Math.imul(al1, bl6)) | 0; mid = (mid + Math.imul(al1, bh6)) | 0; mid = (mid + Math.imul(ah1, bl6)) | 0; hi = (hi + Math.imul(ah1, bh6)) | 0; lo = (lo + Math.imul(al0, bl7)) | 0; mid = (mid + Math.imul(al0, bh7)) | 0; mid = (mid + Math.imul(ah0, bl7)) | 0; hi = (hi + Math.imul(ah0, bh7)) | 0; var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0; w7 &= 0x3ffffff; /* k = 8 */ lo = Math.imul(al8, bl0); mid = Math.imul(al8, bh0); mid = (mid + Math.imul(ah8, bl0)) | 0; hi = Math.imul(ah8, bh0); lo = (lo + Math.imul(al7, bl1)) | 0; mid = (mid + Math.imul(al7, bh1)) | 0; mid = (mid + Math.imul(ah7, bl1)) | 0; hi = (hi + Math.imul(ah7, bh1)) | 0; lo = (lo + Math.imul(al6, bl2)) | 0; mid = (mid + Math.imul(al6, bh2)) | 0; mid = (mid + Math.imul(ah6, bl2)) | 0; hi = (hi + Math.imul(ah6, bh2)) | 0; lo = (lo + Math.imul(al5, bl3)) | 0; mid = (mid + Math.imul(al5, bh3)) | 0; mid = (mid + Math.imul(ah5, bl3)) | 0; hi = (hi + Math.imul(ah5, bh3)) | 0; lo = (lo + Math.imul(al4, bl4)) | 0; mid = (mid + Math.imul(al4, bh4)) | 0; mid = (mid + Math.imul(ah4, bl4)) | 0; hi = (hi + Math.imul(ah4, bh4)) | 0; lo = (lo + Math.imul(al3, bl5)) | 0; mid = (mid + Math.imul(al3, bh5)) | 0; mid = (mid + Math.imul(ah3, bl5)) | 0; hi = (hi + Math.imul(ah3, bh5)) | 0; lo = (lo + Math.imul(al2, bl6)) | 0; mid = (mid + Math.imul(al2, bh6)) | 0; mid = (mid + Math.imul(ah2, bl6)) | 0; hi = (hi + Math.imul(ah2, bh6)) | 0; lo = (lo + Math.imul(al1, bl7)) | 0; mid = (mid + Math.imul(al1, bh7)) | 0; mid = (mid + Math.imul(ah1, bl7)) | 0; hi = (hi + Math.imul(ah1, bh7)) | 0; lo = (lo + Math.imul(al0, bl8)) | 0; mid = (mid + Math.imul(al0, bh8)) | 0; mid = (mid + Math.imul(ah0, bl8)) | 0; hi = (hi + Math.imul(ah0, bh8)) | 0; var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0; w8 &= 0x3ffffff; /* k = 9 */ lo = Math.imul(al9, bl0); mid = Math.imul(al9, bh0); mid = (mid + Math.imul(ah9, bl0)) | 0; hi = Math.imul(ah9, bh0); lo = (lo + Math.imul(al8, bl1)) | 0; mid = (mid + Math.imul(al8, bh1)) | 0; mid = (mid + Math.imul(ah8, bl1)) | 0; hi = (hi + Math.imul(ah8, bh1)) | 0; lo = (lo + Math.imul(al7, bl2)) | 0; mid = (mid + Math.imul(al7, bh2)) | 0; mid = (mid + Math.imul(ah7, bl2)) | 0; hi = (hi + Math.imul(ah7, bh2)) | 0; lo = (lo + Math.imul(al6, bl3)) | 0; mid = (mid + Math.imul(al6, bh3)) | 0; mid = (mid + Math.imul(ah6, bl3)) | 0; hi = (hi + Math.imul(ah6, bh3)) | 0; lo = (lo + Math.imul(al5, bl4)) | 0; mid = (mid + Math.imul(al5, bh4)) | 0; mid = (mid + Math.imul(ah5, bl4)) | 0; hi = (hi + Math.imul(ah5, bh4)) | 0; lo = (lo + Math.imul(al4, bl5)) | 0; mid = (mid + Math.imul(al4, bh5)) | 0; mid = (mid + Math.imul(ah4, bl5)) | 0; hi = (hi + Math.imul(ah4, bh5)) | 0; lo = (lo + Math.imul(al3, bl6)) | 0; mid = (mid + Math.imul(al3, bh6)) | 0; mid = (mid + Math.imul(ah3, bl6)) | 0; hi = (hi + Math.imul(ah3, bh6)) | 0; lo = (lo + Math.imul(al2, bl7)) | 0; mid = (mid + Math.imul(al2, bh7)) | 0; mid = (mid + Math.imul(ah2, bl7)) | 0; hi = (hi + Math.imul(ah2, bh7)) | 0; lo = (lo + Math.imul(al1, bl8)) | 0; mid = (mid + Math.imul(al1, bh8)) | 0; mid = (mid + Math.imul(ah1, bl8)) | 0; hi = (hi + Math.imul(ah1, bh8)) | 0; lo = (lo + Math.imul(al0, bl9)) | 0; mid = (mid + Math.imul(al0, bh9)) | 0; mid = (mid + Math.imul(ah0, bl9)) | 0; hi = (hi + Math.imul(ah0, bh9)) | 0; var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0; w9 &= 0x3ffffff; /* k = 10 */ lo = Math.imul(al9, bl1); mid = Math.imul(al9, bh1); mid = (mid + Math.imul(ah9, bl1)) | 0; hi = Math.imul(ah9, bh1); lo = (lo + Math.imul(al8, bl2)) | 0; mid = (mid + Math.imul(al8, bh2)) | 0; mid = (mid + Math.imul(ah8, bl2)) | 0; hi = (hi + Math.imul(ah8, bh2)) | 0; lo = (lo + Math.imul(al7, bl3)) | 0; mid = (mid + Math.imul(al7, bh3)) | 0; mid = (mid + Math.imul(ah7, bl3)) | 0; hi = (hi + Math.imul(ah7, bh3)) | 0; lo = (lo + Math.imul(al6, bl4)) | 0; mid = (mid + Math.imul(al6, bh4)) | 0; mid = (mid + Math.imul(ah6, bl4)) | 0; hi = (hi + Math.imul(ah6, bh4)) | 0; lo = (lo + Math.imul(al5, bl5)) | 0; mid = (mid + Math.imul(al5, bh5)) | 0; mid = (mid + Math.imul(ah5, bl5)) | 0; hi = (hi + Math.imul(ah5, bh5)) | 0; lo = (lo + Math.imul(al4, bl6)) | 0; mid = (mid + Math.imul(al4, bh6)) | 0; mid = (mid + Math.imul(ah4, bl6)) | 0; hi = (hi + Math.imul(ah4, bh6)) | 0; lo = (lo + Math.imul(al3, bl7)) | 0; mid = (mid + Math.imul(al3, bh7)) | 0; mid = (mid + Math.imul(ah3, bl7)) | 0; hi = (hi + Math.imul(ah3, bh7)) | 0; lo = (lo + Math.imul(al2, bl8)) | 0; mid = (mid + Math.imul(al2, bh8)) | 0; mid = (mid + Math.imul(ah2, bl8)) | 0; hi = (hi + Math.imul(ah2, bh8)) | 0; lo = (lo + Math.imul(al1, bl9)) | 0; mid = (mid + Math.imul(al1, bh9)) | 0; mid = (mid + Math.imul(ah1, bl9)) | 0; hi = (hi + Math.imul(ah1, bh9)) | 0; var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0; w10 &= 0x3ffffff; /* k = 11 */ lo = Math.imul(al9, bl2); mid = Math.imul(al9, bh2); mid = (mid + Math.imul(ah9, bl2)) | 0; hi = Math.imul(ah9, bh2); lo = (lo + Math.imul(al8, bl3)) | 0; mid = (mid + Math.imul(al8, bh3)) | 0; mid = (mid + Math.imul(ah8, bl3)) | 0; hi = (hi + Math.imul(ah8, bh3)) | 0; lo = (lo + Math.imul(al7, bl4)) | 0; mid = (mid + Math.imul(al7, bh4)) | 0; mid = (mid + Math.imul(ah7, bl4)) | 0; hi = (hi + Math.imul(ah7, bh4)) | 0; lo = (lo + Math.imul(al6, bl5)) | 0; mid = (mid + Math.imul(al6, bh5)) | 0; mid = (mid + Math.imul(ah6, bl5)) | 0; hi = (hi + Math.imul(ah6, bh5)) | 0; lo = (lo + Math.imul(al5, bl6)) | 0; mid = (mid + Math.imul(al5, bh6)) | 0; mid = (mid + Math.imul(ah5, bl6)) | 0; hi = (hi + Math.imul(ah5, bh6)) | 0; lo = (lo + Math.imul(al4, bl7)) | 0; mid = (mid + Math.imul(al4, bh7)) | 0; mid = (mid + Math.imul(ah4, bl7)) | 0; hi = (hi + Math.imul(ah4, bh7)) | 0; lo = (lo + Math.imul(al3, bl8)) | 0; mid = (mid + Math.imul(al3, bh8)) | 0; mid = (mid + Math.imul(ah3, bl8)) | 0; hi = (hi + Math.imul(ah3, bh8)) | 0; lo = (lo + Math.imul(al2, bl9)) | 0; mid = (mid + Math.imul(al2, bh9)) | 0; mid = (mid + Math.imul(ah2, bl9)) | 0; hi = (hi + Math.imul(ah2, bh9)) | 0; var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0; w11 &= 0x3ffffff; /* k = 12 */ lo = Math.imul(al9, bl3); mid = Math.imul(al9, bh3); mid = (mid + Math.imul(ah9, bl3)) | 0; hi = Math.imul(ah9, bh3); lo = (lo + Math.imul(al8, bl4)) | 0; mid = (mid + Math.imul(al8, bh4)) | 0; mid = (mid + Math.imul(ah8, bl4)) | 0; hi = (hi + Math.imul(ah8, bh4)) | 0; lo = (lo + Math.imul(al7, bl5)) | 0; mid = (mid + Math.imul(al7, bh5)) | 0; mid = (mid + Math.imul(ah7, bl5)) | 0; hi = (hi + Math.imul(ah7, bh5)) | 0; lo = (lo + Math.imul(al6, bl6)) | 0; mid = (mid + Math.imul(al6, bh6)) | 0; mid = (mid + Math.imul(ah6, bl6)) | 0; hi = (hi + Math.imul(ah6, bh6)) | 0; lo = (lo + Math.imul(al5, bl7)) | 0; mid = (mid + Math.imul(al5, bh7)) | 0; mid = (mid + Math.imul(ah5, bl7)) | 0; hi = (hi + Math.imul(ah5, bh7)) | 0; lo = (lo + Math.imul(al4, bl8)) | 0; mid = (mid + Math.imul(al4, bh8)) | 0; mid = (mid + Math.imul(ah4, bl8)) | 0; hi = (hi + Math.imul(ah4, bh8)) | 0; lo = (lo + Math.imul(al3, bl9)) | 0; mid = (mid + Math.imul(al3, bh9)) | 0; mid = (mid + Math.imul(ah3, bl9)) | 0; hi = (hi + Math.imul(ah3, bh9)) | 0; var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0; w12 &= 0x3ffffff; /* k = 13 */ lo = Math.imul(al9, bl4); mid = Math.imul(al9, bh4); mid = (mid + Math.imul(ah9, bl4)) | 0; hi = Math.imul(ah9, bh4); lo = (lo + Math.imul(al8, bl5)) | 0; mid = (mid + Math.imul(al8, bh5)) | 0; mid = (mid + Math.imul(ah8, bl5)) | 0; hi = (hi + Math.imul(ah8, bh5)) | 0; lo = (lo + Math.imul(al7, bl6)) | 0; mid = (mid + Math.imul(al7, bh6)) | 0; mid = (mid + Math.imul(ah7, bl6)) | 0; hi = (hi + Math.imul(ah7, bh6)) | 0; lo = (lo + Math.imul(al6, bl7)) | 0; mid = (mid + Math.imul(al6, bh7)) | 0; mid = (mid + Math.imul(ah6, bl7)) | 0; hi = (hi + Math.imul(ah6, bh7)) | 0; lo = (lo + Math.imul(al5, bl8)) | 0; mid = (mid + Math.imul(al5, bh8)) | 0; mid = (mid + Math.imul(ah5, bl8)) | 0; hi = (hi + Math.imul(ah5, bh8)) | 0; lo = (lo + Math.imul(al4, bl9)) | 0; mid = (mid + Math.imul(al4, bh9)) | 0; mid = (mid + Math.imul(ah4, bl9)) | 0; hi = (hi + Math.imul(ah4, bh9)) | 0; var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0; w13 &= 0x3ffffff; /* k = 14 */ lo = Math.imul(al9, bl5); mid = Math.imul(al9, bh5); mid = (mid + Math.imul(ah9, bl5)) | 0; hi = Math.imul(ah9, bh5); lo = (lo + Math.imul(al8, bl6)) | 0; mid = (mid + Math.imul(al8, bh6)) | 0; mid = (mid + Math.imul(ah8, bl6)) | 0; hi = (hi + Math.imul(ah8, bh6)) | 0; lo = (lo + Math.imul(al7, bl7)) | 0; mid = (mid + Math.imul(al7, bh7)) | 0; mid = (mid + Math.imul(ah7, bl7)) | 0; hi = (hi + Math.imul(ah7, bh7)) | 0; lo = (lo + Math.imul(al6, bl8)) | 0; mid = (mid + Math.imul(al6, bh8)) | 0; mid = (mid + Math.imul(ah6, bl8)) | 0; hi = (hi + Math.imul(ah6, bh8)) | 0; lo = (lo + Math.imul(al5, bl9)) | 0; mid = (mid + Math.imul(al5, bh9)) | 0; mid = (mid + Math.imul(ah5, bl9)) | 0; hi = (hi + Math.imul(ah5, bh9)) | 0; var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0; w14 &= 0x3ffffff; /* k = 15 */ lo = Math.imul(al9, bl6); mid = Math.imul(al9, bh6); mid = (mid + Math.imul(ah9, bl6)) | 0; hi = Math.imul(ah9, bh6); lo = (lo + Math.imul(al8, bl7)) | 0; mid = (mid + Math.imul(al8, bh7)) | 0; mid = (mid + Math.imul(ah8, bl7)) | 0; hi = (hi + Math.imul(ah8, bh7)) | 0; lo = (lo + Math.imul(al7, bl8)) | 0; mid = (mid + Math.imul(al7, bh8)) | 0; mid = (mid + Math.imul(ah7, bl8)) | 0; hi = (hi + Math.imul(ah7, bh8)) | 0; lo = (lo + Math.imul(al6, bl9)) | 0; mid = (mid + Math.imul(al6, bh9)) | 0; mid = (mid + Math.imul(ah6, bl9)) | 0; hi = (hi + Math.imul(ah6, bh9)) | 0; var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0; w15 &= 0x3ffffff; /* k = 16 */ lo = Math.imul(al9, bl7); mid = Math.imul(al9, bh7); mid = (mid + Math.imul(ah9, bl7)) | 0; hi = Math.imul(ah9, bh7); lo = (lo + Math.imul(al8, bl8)) | 0; mid = (mid + Math.imul(al8, bh8)) | 0; mid = (mid + Math.imul(ah8, bl8)) | 0; hi = (hi + Math.imul(ah8, bh8)) | 0; lo = (lo + Math.imul(al7, bl9)) | 0; mid = (mid + Math.imul(al7, bh9)) | 0; mid = (mid + Math.imul(ah7, bl9)) | 0; hi = (hi + Math.imul(ah7, bh9)) | 0; var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0; w16 &= 0x3ffffff; /* k = 17 */ lo = Math.imul(al9, bl8); mid = Math.imul(al9, bh8); mid = (mid + Math.imul(ah9, bl8)) | 0; hi = Math.imul(ah9, bh8); lo = (lo + Math.imul(al8, bl9)) | 0; mid = (mid + Math.imul(al8, bh9)) | 0; mid = (mid + Math.imul(ah8, bl9)) | 0; hi = (hi + Math.imul(ah8, bh9)) | 0; var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0; w17 &= 0x3ffffff; /* k = 18 */ lo = Math.imul(al9, bl9); mid = Math.imul(al9, bh9); mid = (mid + Math.imul(ah9, bl9)) | 0; hi = Math.imul(ah9, bh9); var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0; c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0; w18 &= 0x3ffffff; o[0] = w0; o[1] = w1; o[2] = w2; o[3] = w3; o[4] = w4; o[5] = w5; o[6] = w6; o[7] = w7; o[8] = w8; o[9] = w9; o[10] = w10; o[11] = w11; o[12] = w12; o[13] = w13; o[14] = w14; o[15] = w15; o[16] = w16; o[17] = w17; o[18] = w18; if (c !== 0) { o[19] = c; out.length++; } return out; }; // Polyfill comb if (!Math.imul) { comb10MulTo = smallMulTo; } function bigMulTo (self, num, out) { out.negative = num.negative ^ self.negative; out.length = self.length + num.length; var carry = 0; var hncarry = 0; for (var k = 0; k < out.length - 1; k++) { // Sum all words with the same `i + j = k` and accumulate `ncarry`, // note that ncarry could be >= 0x3ffffff var ncarry = hncarry; hncarry = 0; var rword = carry & 0x3ffffff; var maxJ = Math.min(k, num.length - 1); for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) { var i = k - j; var a = self.words[i] | 0; var b = num.words[j] | 0; var r = a * b; var lo = r & 0x3ffffff; ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0; lo = (lo + rword) | 0; rword = lo & 0x3ffffff; ncarry = (ncarry + (lo >>> 26)) | 0; hncarry += ncarry >>> 26; ncarry &= 0x3ffffff; } out.words[k] = rword; carry = ncarry; ncarry = hncarry; } if (carry !== 0) { out.words[k] = carry; } else { out.length--; } return out.strip(); } function jumboMulTo (self, num, out) { var fftm = new FFTM(); return fftm.mulp(self, num, out); } BN.prototype.mulTo = function mulTo (num, out) { var res; var len = this.length + num.length; if (this.length === 10 && num.length === 10) { res = comb10MulTo(this, num, out); } else if (len < 63) { res = smallMulTo(this, num, out); } else if (len < 1024) { res = bigMulTo(this, num, out); } else { res = jumboMulTo(this, num, out); } return res; }; // Cooley-Tukey algorithm for FFT // slightly revisited to rely on looping instead of recursion function FFTM (x, y) { this.x = x; this.y = y; } FFTM.prototype.makeRBT = function makeRBT (N) { var t = new Array(N); var l = BN.prototype._countBits(N) - 1; for (var i = 0; i < N; i++) { t[i] = this.revBin(i, l, N); } return t; }; // Returns binary-reversed representation of `x` FFTM.prototype.revBin = function revBin (x, l, N) { if (x === 0 || x === N - 1) return x; var rb = 0; for (var i = 0; i < l; i++) { rb |= (x & 1) << (l - i - 1); x >>= 1; } return rb; }; // Performs "tweedling" phase, therefore 'emulating' // behaviour of the recursive algorithm FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) { for (var i = 0; i < N; i++) { rtws[i] = rws[rbt[i]]; itws[i] = iws[rbt[i]]; } }; FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) { this.permute(rbt, rws, iws, rtws, itws, N); for (var s = 1; s < N; s <<= 1) { var l = s << 1; var rtwdf = Math.cos(2 * Math.PI / l); var itwdf = Math.sin(2 * Math.PI / l); for (var p = 0; p < N; p += l) { var rtwdf_ = rtwdf; var itwdf_ = itwdf; for (var j = 0; j < s; j++) { var re = rtws[p + j]; var ie = itws[p + j]; var ro = rtws[p + j + s]; var io = itws[p + j + s]; var rx = rtwdf_ * ro - itwdf_ * io; io = rtwdf_ * io + itwdf_ * ro; ro = rx; rtws[p + j] = re + ro; itws[p + j] = ie + io; rtws[p + j + s] = re - ro; itws[p + j + s] = ie - io; /* jshint maxdepth : false */ if (j !== l) { rx = rtwdf * rtwdf_ - itwdf * itwdf_; itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_; rtwdf_ = rx; } } } } }; FFTM.prototype.guessLen13b = function guessLen13b (n, m) { var N = Math.max(m, n) | 1; var odd = N & 1; var i = 0; for (N = N / 2 | 0; N; N = N >>> 1) { i++; } return 1 << i + 1 + odd; }; FFTM.prototype.conjugate = function conjugate (rws, iws, N) { if (N <= 1) return; for (var i = 0; i < N / 2; i++) { var t = rws[i]; rws[i] = rws[N - i - 1]; rws[N - i - 1] = t; t = iws[i]; iws[i] = -iws[N - i - 1]; iws[N - i - 1] = -t; } }; FFTM.prototype.normalize13b = function normalize13b (ws, N) { var carry = 0; for (var i = 0; i < N / 2; i++) { var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry; ws[i] = w & 0x3ffffff; if (w < 0x4000000) { carry = 0; } else { carry = w / 0x4000000 | 0; } } return ws; }; FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) { var carry = 0; for (var i = 0; i < len; i++) { carry = carry + (ws[i] | 0); rws[2 * i] = carry & 0x1fff; carry = carry >>> 13; rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13; } // Pad with zeroes for (i = 2 * len; i < N; ++i) { rws[i] = 0; } assert(carry === 0); assert((carry & ~0x1fff) === 0); }; FFTM.prototype.stub = function stub (N) { var ph = new Array(N); for (var i = 0; i < N; i++) { ph[i] = 0; } return ph; }; FFTM.prototype.mulp = function mulp (x, y, out) { var N = 2 * this.guessLen13b(x.length, y.length); var rbt = this.makeRBT(N); var _ = this.stub(N); var rws = new Array(N); var rwst = new Array(N); var iwst = new Array(N); var nrws = new Array(N); var nrwst = new Array(N); var niwst = new Array(N); var rmws = out.words; rmws.length = N; this.convert13b(x.words, x.length, rws, N); this.convert13b(y.words, y.length, nrws, N); this.transform(rws, _, rwst, iwst, N, rbt); this.transform(nrws, _, nrwst, niwst, N, rbt); for (var i = 0; i < N; i++) { var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i]; iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i]; rwst[i] = rx; } this.conjugate(rwst, iwst, N); this.transform(rwst, iwst, rmws, _, N, rbt); this.conjugate(rmws, _, N); this.normalize13b(rmws, N); out.negative = x.negative ^ y.negative; out.length = x.length + y.length; return out.strip(); }; // Multiply `this` by `num` BN.prototype.mul = function mul (num) { var out = new BN(null); out.words = new Array(this.length + num.length); return this.mulTo(num, out); }; // Multiply employing FFT BN.prototype.mulf = function mulf (num) { var out = new BN(null); out.words = new Array(this.length + num.length); return jumboMulTo(this, num, out); }; // In-place Multiplication BN.prototype.imul = function imul (num) { return this.clone().mulTo(num, this); }; BN.prototype.imuln = function imuln (num) { assert(typeof num === 'number'); assert(num < 0x4000000); // Carry var carry = 0; for (var i = 0; i < this.length; i++) { var w = (this.words[i] | 0) * num; var lo = (w & 0x3ffffff) + (carry & 0x3ffffff); carry >>= 26; carry += (w / 0x4000000) | 0; // NOTE: lo is 27bit maximum carry += lo >>> 26; this.words[i] = lo & 0x3ffffff; } if (carry !== 0) { this.words[i] = carry; this.length++; } return this; }; BN.prototype.muln = function muln (num) { return this.clone().imuln(num); }; // `this` * `this` BN.prototype.sqr = function sqr () { return this.mul(this); }; // `this` * `this` in-place BN.prototype.isqr = function isqr () { return this.imul(this.clone()); }; // Math.pow(`this`, `num`) BN.prototype.pow = function pow (num) { var w = toBitArray(num); if (w.length === 0) return new BN(1); // Skip leading zeroes var res = this; for (var i = 0; i < w.length; i++, res = res.sqr()) { if (w[i] !== 0) break; } if (++i < w.length) { for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) { if (w[i] === 0) continue; res = res.mul(q); } } return res; }; // Shift-left in-place BN.prototype.iushln = function iushln (bits) { assert(typeof bits === 'number' && bits >= 0); var r = bits % 26; var s = (bits - r) / 26; var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r); var i; if (r !== 0) { var carry = 0; for (i = 0; i < this.length; i++) { var newCarry = this.words[i] & carryMask; var c = ((this.words[i] | 0) - newCarry) << r; this.words[i] = c | carry; carry = newCarry >>> (26 - r); } if (carry) { this.words[i] = carry; this.length++; } } if (s !== 0) { for (i = this.length - 1; i >= 0; i--) { this.words[i + s] = this.words[i]; } for (i = 0; i < s; i++) { this.words[i] = 0; } this.length += s; } return this.strip(); }; BN.prototype.ishln = function ishln (bits) { // TODO(indutny): implement me assert(this.negative === 0); return this.iushln(bits); }; // Shift-right in-place // NOTE: `hint` is a lowest bit before trailing zeroes // NOTE: if `extended` is present - it will be filled with destroyed bits BN.prototype.iushrn = function iushrn (bits, hint, extended) { assert(typeof bits === 'number' && bits >= 0); var h; if (hint) { h = (hint - (hint % 26)) / 26; } else { h = 0; } var r = bits % 26; var s = Math.min((bits - r) / 26, this.length); var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r); var maskedWords = extended; h -= s; h = Math.max(0, h); // Extended mode, copy masked part if (maskedWords) { for (var i = 0; i < s; i++) { maskedWords.words[i] = this.words[i]; } maskedWords.length = s; } if (s === 0) { // No-op, we should not move anything at all } else if (this.length > s) { this.length -= s; for (i = 0; i < this.length; i++) { this.words[i] = this.words[i + s]; } } else { this.words[0] = 0; this.length = 1; } var carry = 0; for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) { var word = this.words[i] | 0; this.words[i] = (carry << (26 - r)) | (word >>> r); carry = word & mask; } // Push carried bits as a mask if (maskedWords && carry !== 0) { maskedWords.words[maskedWords.length++] = carry; } if (this.length === 0) { this.words[0] = 0; this.length = 1; } return this.strip(); }; BN.prototype.ishrn = function ishrn (bits, hint, extended) { // TODO(indutny): implement me assert(this.negative === 0); return this.iushrn(bits, hint, extended); }; // Shift-left BN.prototype.shln = function shln (bits) { return this.clone().ishln(bits); }; BN.prototype.ushln = function ushln (bits) { return this.clone().iushln(bits); }; // Shift-right BN.prototype.shrn = function shrn (bits) { return this.clone().ishrn(bits); }; BN.prototype.ushrn = function ushrn (bits) { return this.clone().iushrn(bits); }; // Test if n bit is set BN.prototype.testn = function testn (bit) { assert(typeof bit === 'number' && bit >= 0); var r = bit % 26; var s = (bit - r) / 26; var q = 1 << r; // Fast case: bit is much higher than all existing words if (this.length <= s) return false; // Check bit and return var w = this.words[s]; return !!(w & q); }; // Return only lowers bits of number (in-place) BN.prototype.imaskn = function imaskn (bits) { assert(typeof bits === 'number' && bits >= 0); var r = bits % 26; var s = (bits - r) / 26; assert(this.negative === 0, 'imaskn works only with positive numbers'); if (this.length <= s) { return this; } if (r !== 0) { s++; } this.length = Math.min(s, this.length); if (r !== 0) { var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r); this.words[this.length - 1] &= mask; } return this.strip(); }; // Return only lowers bits of number BN.prototype.maskn = function maskn (bits) { return this.clone().imaskn(bits); }; // Add plain number `num` to `this` BN.prototype.iaddn = function iaddn (num) { assert(typeof num === 'number'); assert(num < 0x4000000); if (num < 0) return this.isubn(-num); // Possible sign change if (this.negative !== 0) { if (this.length === 1 && (this.words[0] | 0) < num) { this.words[0] = num - (this.words[0] | 0); this.negative = 0; return this; } this.negative = 0; this.isubn(num); this.negative = 1; return this; } // Add without checks return this._iaddn(num); }; BN.prototype._iaddn = function _iaddn (num) { this.words[0] += num; // Carry for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) { this.words[i] -= 0x4000000; if (i === this.length - 1) { this.words[i + 1] = 1; } else { this.words[i + 1]++; } } this.length = Math.max(this.length, i + 1); return this; }; // Subtract plain number `num` from `this` BN.prototype.isubn = function isubn (num) { assert(typeof num === 'number'); assert(num < 0x4000000); if (num < 0) return this.iaddn(-num); if (this.negative !== 0) { this.negative = 0; this.iaddn(num); this.negative = 1; return this; } this.words[0] -= num; if (this.length === 1 && this.words[0] < 0) { this.words[0] = -this.words[0]; this.negative = 1; } else { // Carry for (var i = 0; i < this.length && this.words[i] < 0; i++) { this.words[i] += 0x4000000; this.words[i + 1] -= 1; } } return this.strip(); }; BN.prototype.addn = function addn (num) { return this.clone().iaddn(num); }; BN.prototype.subn = function subn (num) { return this.clone().isubn(num); }; BN.prototype.iabs = function iabs () { this.negative = 0; return this; }; BN.prototype.abs = function abs () { return this.clone().iabs(); }; BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) { var len = num.length + shift; var i; this._expand(len); var w; var carry = 0; for (i = 0; i < num.length; i++) { w = (this.words[i + shift] | 0) + carry; var right = (num.words[i] | 0) * mul; w -= right & 0x3ffffff; carry = (w >> 26) - ((right / 0x4000000) | 0); this.words[i + shift] = w & 0x3ffffff; } for (; i < this.length - shift; i++) { w = (this.words[i + shift] | 0) + carry; carry = w >> 26; this.words[i + shift] = w & 0x3ffffff; } if (carry === 0) return this.strip(); // Subtraction overflow assert(carry === -1); carry = 0; for (i = 0; i < this.length; i++) { w = -(this.words[i] | 0) + carry; carry = w >> 26; this.words[i] = w & 0x3ffffff; } this.negative = 1; return this.strip(); }; BN.prototype._wordDiv = function _wordDiv (num, mode) { var shift = this.length - num.length; var a = this.clone(); var b = num; // Normalize var bhi = b.words[b.length - 1] | 0; var bhiBits = this._countBits(bhi); shift = 26 - bhiBits; if (shift !== 0) { b = b.ushln(shift); a.iushln(shift); bhi = b.words[b.length - 1] | 0; } // Initialize quotient var m = a.length - b.length; var q; if (mode !== 'mod') { q = new BN(null); q.length = m + 1; q.words = new Array(q.length); for (var i = 0; i < q.length; i++) { q.words[i] = 0; } } var diff = a.clone()._ishlnsubmul(b, 1, m); if (diff.negative === 0) { a = diff; if (q) { q.words[m] = 1; } } for (var j = m - 1; j >= 0; j--) { var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max // (0x7ffffff) qj = Math.min((qj / bhi) | 0, 0x3ffffff); a._ishlnsubmul(b, qj, j); while (a.negative !== 0) { qj--; a.negative = 0; a._ishlnsubmul(b, 1, j); if (!a.isZero()) { a.negative ^= 1; } } if (q) { q.words[j] = qj; } } if (q) { q.strip(); } a.strip(); // Denormalize if (mode !== 'div' && shift !== 0) { a.iushrn(shift); } return { div: q || null, mod: a }; }; // NOTE: 1) `mode` can be set to `mod` to request mod only, // to `div` to request div only, or be absent to // request both div & mod // 2) `positive` is true if unsigned mod is requested BN.prototype.divmod = function divmod (num, mode, positive) { assert(!num.isZero()); if (this.isZero()) { return { div: new BN(0), mod: new BN(0) }; } var div, mod, res; if (this.negative !== 0 && num.negative === 0) { res = this.neg().divmod(num, mode); if (mode !== 'mod') { div = res.div.neg(); } if (mode !== 'div') { mod = res.mod.neg(); if (positive && mod.negative !== 0) { mod.iadd(num); } } return { div: div, mod: mod }; } if (this.negative === 0 && num.negative !== 0) { res = this.divmod(num.neg(), mode); if (mode !== 'mod') { div = res.div.neg(); } return { div: div, mod: res.mod }; } if ((this.negative & num.negative) !== 0) { res = this.neg().divmod(num.neg(), mode); if (mode !== 'div') { mod = res.mod.neg(); if (positive && mod.negative !== 0) { mod.isub(num); } } return { div: res.div, mod: mod }; } // Both numbers are positive at this point // Strip both numbers to approximate shift value if (num.length > this.length || this.cmp(num) < 0) { return { div: new BN(0), mod: this }; } // Very short reduction if (num.length === 1) { if (mode === 'div') { return { div: this.divn(num.words[0]), mod: null }; } if (mode === 'mod') { return { div: null, mod: new BN(this.modn(num.words[0])) }; } return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) }; } return this._wordDiv(num, mode); }; // Find `this` / `num` BN.prototype.div = function div (num) { return this.divmod(num, 'div', false).div; }; // Find `this` % `num` BN.prototype.mod = function mod (num) { return this.divmod(num, 'mod', false).mod; }; BN.prototype.umod = function umod (num) { return this.divmod(num, 'mod', true).mod; }; // Find Round(`this` / `num`) BN.prototype.divRound = function divRound (num) { var dm = this.divmod(num); // Fast case - exact division if (dm.mod.isZero()) return dm.div; var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod; var half = num.ushrn(1); var r2 = num.andln(1); var cmp = mod.cmp(half); // Round down if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1); }; BN.prototype.modn = function modn (num) { assert(num <= 0x3ffffff); var p = (1 << 26) % num; var acc = 0; for (var i = this.length - 1; i >= 0; i--) { acc = (p * acc + (this.words[i] | 0)) % num; } return acc; }; // In-place division by number BN.prototype.idivn = function idivn (num) { assert(num <= 0x3ffffff); var carry = 0; for (var i = this.length - 1; i >= 0; i--) { var w = (this.words[i] | 0) + carry * 0x4000000; this.words[i] = (w / num) | 0; carry = w % num; } return this.strip(); }; BN.prototype.divn = function divn (num) { return this.clone().idivn(num); }; BN.prototype.egcd = function egcd (p) { assert(p.negative === 0); assert(!p.isZero()); var x = this; var y = p.clone(); if (x.negative !== 0) { x = x.umod(p); } else { x = x.clone(); } // A * x + B * y = x var A = new BN(1); var B = new BN(0); // C * x + D * y = y var C = new BN(0); var D = new BN(1); var g = 0; while (x.isEven() && y.isEven()) { x.iushrn(1); y.iushrn(1); ++g; } var yp = y.clone(); var xp = x.clone(); while (!x.isZero()) { for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1); if (i > 0) { x.iushrn(i); while (i-- > 0) { if (A.isOdd() || B.isOdd()) { A.iadd(yp); B.isub(xp); } A.iushrn(1); B.iushrn(1); } } for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1); if (j > 0) { y.iushrn(j); while (j-- > 0) { if (C.isOdd() || D.isOdd()) { C.iadd(yp); D.isub(xp); } C.iushrn(1); D.iushrn(1); } } if (x.cmp(y) >= 0) { x.isub(y); A.isub(C); B.isub(D); } else { y.isub(x); C.isub(A); D.isub(B); } } return { a: C, b: D, gcd: y.iushln(g) }; }; // This is reduced incarnation of the binary EEA // above, designated to invert members of the // _prime_ fields F(p) at a maximal speed BN.prototype._invmp = function _invmp (p) { assert(p.negative === 0); assert(!p.isZero()); var a = this; var b = p.clone(); if (a.negative !== 0) { a = a.umod(p); } else { a = a.clone(); } var x1 = new BN(1); var x2 = new BN(0); var delta = b.clone(); while (a.cmpn(1) > 0 && b.cmpn(1) > 0) { for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1); if (i > 0) { a.iushrn(i); while (i-- > 0) { if (x1.isOdd()) { x1.iadd(delta); } x1.iushrn(1); } } for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1); if (j > 0) { b.iushrn(j); while (j-- > 0) { if (x2.isOdd()) { x2.iadd(delta); } x2.iushrn(1); } } if (a.cmp(b) >= 0) { a.isub(b); x1.isub(x2); } else { b.isub(a); x2.isub(x1); } } var res; if (a.cmpn(1) === 0) { res = x1; } else { res = x2; } if (res.cmpn(0) < 0) { res.iadd(p); } return res; }; BN.prototype.gcd = function gcd (num) { if (this.isZero()) return num.abs(); if (num.isZero()) return this.abs(); var a = this.clone(); var b = num.clone(); a.negative = 0; b.negative = 0; // Remove common factor of two for (var shift = 0; a.isEven() && b.isEven(); shift++) { a.iushrn(1); b.iushrn(1); } do { while (a.isEven()) { a.iushrn(1); } while (b.isEven()) { b.iushrn(1); } var r = a.cmp(b); if (r < 0) { // Swap `a` and `b` to make `a` always bigger than `b` var t = a; a = b; b = t; } else if (r === 0 || b.cmpn(1) === 0) { break; } a.isub(b); } while (true); return b.iushln(shift); }; // Invert number in the field F(num) BN.prototype.invm = function invm (num) { return this.egcd(num).a.umod(num); }; BN.prototype.isEven = function isEven () { return (this.words[0] & 1) === 0; }; BN.prototype.isOdd = function isOdd () { return (this.words[0] & 1) === 1; }; // And first word and num BN.prototype.andln = function andln (num) { return this.words[0] & num; }; // Increment at the bit position in-line BN.prototype.bincn = function bincn (bit) { assert(typeof bit === 'number'); var r = bit % 26; var s = (bit - r) / 26; var q = 1 << r; // Fast case: bit is much higher than all existing words if (this.length <= s) { this._expand(s + 1); this.words[s] |= q; return this; } // Add bit and propagate, if needed var carry = q; for (var i = s; carry !== 0 && i < this.length; i++) { var w = this.words[i] | 0; w += carry; carry = w >>> 26; w &= 0x3ffffff; this.words[i] = w; } if (carry !== 0) { this.words[i] = carry; this.length++; } return this; }; BN.prototype.isZero = function isZero () { return this.length === 1 && this.words[0] === 0; }; BN.prototype.cmpn = function cmpn (num) { var negative = num < 0; if (this.negative !== 0 && !negative) return -1; if (this.negative === 0 && negative) return 1; this.strip(); var res; if (this.length > 1) { res = 1; } else { if (negative) { num = -num; } assert(num <= 0x3ffffff, 'Number is too big'); var w = this.words[0] | 0; res = w === num ? 0 : w < num ? -1 : 1; } if (this.negative !== 0) return -res | 0; return res; }; // Compare two numbers and return: // 1 - if `this` > `num` // 0 - if `this` == `num` // -1 - if `this` < `num` BN.prototype.cmp = function cmp (num) { if (this.negative !== 0 && num.negative === 0) return -1; if (this.negative === 0 && num.negative !== 0) return 1; var res = this.ucmp(num); if (this.negative !== 0) return -res | 0; return res; }; // Unsigned comparison BN.prototype.ucmp = function ucmp (num) { // At this point both numbers have the same sign if (this.length > num.length) return 1; if (this.length < num.length) return -1; var res = 0; for (var i = this.length - 1; i >= 0; i--) { var a = this.words[i] | 0; var b = num.words[i] | 0; if (a === b) continue; if (a < b) { res = -1; } else if (a > b) { res = 1; } break; } return res; }; BN.prototype.gtn = function gtn (num) { return this.cmpn(num) === 1; }; BN.prototype.gt = function gt (num) { return this.cmp(num) === 1; }; BN.prototype.gten = function gten (num) { return this.cmpn(num) >= 0; }; BN.prototype.gte = function gte (num) { return this.cmp(num) >= 0; }; BN.prototype.ltn = function ltn (num) { return this.cmpn(num) === -1; }; BN.prototype.lt = function lt (num) { return this.cmp(num) === -1; }; BN.prototype.lten = function lten (num) { return this.cmpn(num) <= 0; }; BN.prototype.lte = function lte (num) { return this.cmp(num) <= 0; }; BN.prototype.eqn = function eqn (num) { return this.cmpn(num) === 0; }; BN.prototype.eq = function eq (num) { return this.cmp(num) === 0; }; // // A reduce context, could be using montgomery or something better, depending // on the `m` itself. // BN.red = function red (num) { return new Red(num); }; BN.prototype.toRed = function toRed (ctx) { assert(!this.red, 'Already a number in reduction context'); assert(this.negative === 0, 'red works only with positives'); return ctx.convertTo(this)._forceRed(ctx); }; BN.prototype.fromRed = function fromRed () { assert(this.red, 'fromRed works only with numbers in reduction context'); return this.red.convertFrom(this); }; BN.prototype._forceRed = function _forceRed (ctx) { this.red = ctx; return this; }; BN.prototype.forceRed = function forceRed (ctx) { assert(!this.red, 'Already a number in reduction context'); return this._forceRed(ctx); }; BN.prototype.redAdd = function redAdd (num) { assert(this.red, 'redAdd works only with red numbers'); return this.red.add(this, num); }; BN.prototype.redIAdd = function redIAdd (num) { assert(this.red, 'redIAdd works only with red numbers'); return this.red.iadd(this, num); }; BN.prototype.redSub = function redSub (num) { assert(this.red, 'redSub works only with red numbers'); return this.red.sub(this, num); }; BN.prototype.redISub = function redISub (num) { assert(this.red, 'redISub works only with red numbers'); return this.red.isub(this, num); }; BN.prototype.redShl = function redShl (num) { assert(this.red, 'redShl works only with red numbers'); return this.red.shl(this, num); }; BN.prototype.redMul = function redMul (num) { assert(this.red, 'redMul works only with red numbers'); this.red._verify2(this, num); return this.red.mul(this, num); }; BN.prototype.redIMul = function redIMul (num) { assert(this.red, 'redMul works only with red numbers'); this.red._verify2(this, num); return this.red.imul(this, num); }; BN.prototype.redSqr = function redSqr () { assert(this.red, 'redSqr works only with red numbers'); this.red._verify1(this); return this.red.sqr(this); }; BN.prototype.redISqr = function redISqr () { assert(this.red, 'redISqr works only with red numbers'); this.red._verify1(this); return this.red.isqr(this); }; // Square root over p BN.prototype.redSqrt = function redSqrt () { assert(this.red, 'redSqrt works only with red numbers'); this.red._verify1(this); return this.red.sqrt(this); }; BN.prototype.redInvm = function redInvm () { assert(this.red, 'redInvm works only with red numbers'); this.red._verify1(this); return this.red.invm(this); }; // Return negative clone of `this` % `red modulo` BN.prototype.redNeg = function redNeg () { assert(this.red, 'redNeg works only with red numbers'); this.red._verify1(this); return this.red.neg(this); }; BN.prototype.redPow = function redPow (num) { assert(this.red && !num.red, 'redPow(normalNum)'); this.red._verify1(this); return this.red.pow(this, num); }; // Prime numbers with efficient reduction var primes = { k256: null, p224: null, p192: null, p25519: null }; // Pseudo-Mersenne prime function MPrime (name, p) { // P = 2 ^ N - K this.name = name; this.p = new BN(p, 16); this.n = this.p.bitLength(); this.k = new BN(1).iushln(this.n).isub(this.p); this.tmp = this._tmp(); } MPrime.prototype._tmp = function _tmp () { var tmp = new BN(null); tmp.words = new Array(Math.ceil(this.n / 13)); return tmp; }; MPrime.prototype.ireduce = function ireduce (num) { // Assumes that `num` is less than `P^2` // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P) var r = num; var rlen; do { this.split(r, this.tmp); r = this.imulK(r); r = r.iadd(this.tmp); rlen = r.bitLength(); } while (rlen > this.n); var cmp = rlen < this.n ? -1 : r.ucmp(this.p); if (cmp === 0) { r.words[0] = 0; r.length = 1; } else if (cmp > 0) { r.isub(this.p); } else { r.strip(); } return r; }; MPrime.prototype.split = function split (input, out) { input.iushrn(this.n, 0, out); }; MPrime.prototype.imulK = function imulK (num) { return num.imul(this.k); }; function K256 () { MPrime.call( this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'); } inherits(K256, MPrime); K256.prototype.split = function split (input, output) { // 256 = 9 * 26 + 22 var mask = 0x3fffff; var outLen = Math.min(input.length, 9); for (var i = 0; i < outLen; i++) { output.words[i] = input.words[i]; } output.length = outLen; if (input.length <= 9) { input.words[0] = 0; input.length = 1; return; } // Shift by 9 limbs var prev = input.words[9]; output.words[output.length++] = prev & mask; for (i = 10; i < input.length; i++) { var next = input.words[i] | 0; input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22); prev = next; } prev >>>= 22; input.words[i - 10] = prev; if (prev === 0 && input.length > 10) { input.length -= 10; } else { input.length -= 9; } }; K256.prototype.imulK = function imulK (num) { // K = 0x1000003d1 = [ 0x40, 0x3d1 ] num.words[num.length] = 0; num.words[num.length + 1] = 0; num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390 var lo = 0; for (var i = 0; i < num.length; i++) { var w = num.words[i] | 0; lo += w * 0x3d1; num.words[i] = lo & 0x3ffffff; lo = w * 0x40 + ((lo / 0x4000000) | 0); } // Fast length reduction if (num.words[num.length - 1] === 0) { num.length--; if (num.words[num.length - 1] === 0) { num.length--; } } return num; }; function P224 () { MPrime.call( this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001'); } inherits(P224, MPrime); function P192 () { MPrime.call( this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff'); } inherits(P192, MPrime); function P25519 () { // 2 ^ 255 - 19 MPrime.call( this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'); } inherits(P25519, MPrime); P25519.prototype.imulK = function imulK (num) { // K = 0x13 var carry = 0; for (var i = 0; i < num.length; i++) { var hi = (num.words[i] | 0) * 0x13 + carry; var lo = hi & 0x3ffffff; hi >>>= 26; num.words[i] = lo; carry = hi; } if (carry !== 0) { num.words[num.length++] = carry; } return num; }; // Exported mostly for testing purposes, use plain name instead BN._prime = function prime (name) { // Cached version of prime if (primes[name]) return primes[name]; var prime; if (name === 'k256') { prime = new K256(); } else if (name === 'p224') { prime = new P224(); } else if (name === 'p192') { prime = new P192(); } else if (name === 'p25519') { prime = new P25519(); } else { throw new Error('Unknown prime ' + name); } primes[name] = prime; return prime; }; // // Base reduction engine // function Red (m) { if (typeof m === 'string') { var prime = BN._prime(m); this.m = prime.p; this.prime = prime; } else { assert(m.gtn(1), 'modulus must be greater than 1'); this.m = m; this.prime = null; } } Red.prototype._verify1 = function _verify1 (a) { assert(a.negative === 0, 'red works only with positives'); assert(a.red, 'red works only with red numbers'); }; Red.prototype._verify2 = function _verify2 (a, b) { assert((a.negative | b.negative) === 0, 'red works only with positives'); assert(a.red && a.red === b.red, 'red works only with red numbers'); }; Red.prototype.imod = function imod (a) { if (this.prime) return this.prime.ireduce(a)._forceRed(this); return a.umod(this.m)._forceRed(this); }; Red.prototype.neg = function neg (a) { if (a.isZero()) { return a.clone(); } return this.m.sub(a)._forceRed(this); }; Red.prototype.add = function add (a, b) { this._verify2(a, b); var res = a.add(b); if (res.cmp(this.m) >= 0) { res.isub(this.m); } return res._forceRed(this); }; Red.prototype.iadd = function iadd (a, b) { this._verify2(a, b); var res = a.iadd(b); if (res.cmp(this.m) >= 0) { res.isub(this.m); } return res; }; Red.prototype.sub = function sub (a, b) { this._verify2(a, b); var res = a.sub(b); if (res.cmpn(0) < 0) { res.iadd(this.m); } return res._forceRed(this); }; Red.prototype.isub = function isub (a, b) { this._verify2(a, b); var res = a.isub(b); if (res.cmpn(0) < 0) { res.iadd(this.m); } return res; }; Red.prototype.shl = function shl (a, num) { this._verify1(a); return this.imod(a.ushln(num)); }; Red.prototype.imul = function imul (a, b) { this._verify2(a, b); return this.imod(a.imul(b)); }; Red.prototype.mul = function mul (a, b) { this._verify2(a, b); return this.imod(a.mul(b)); }; Red.prototype.isqr = function isqr (a) { return this.imul(a, a.clone()); }; Red.prototype.sqr = function sqr (a) { return this.mul(a, a); }; Red.prototype.sqrt = function sqrt (a) { if (a.isZero()) return a.clone(); var mod3 = this.m.andln(3); assert(mod3 % 2 === 1); // Fast case if (mod3 === 3) { var pow = this.m.add(new BN(1)).iushrn(2); return this.pow(a, pow); } // Tonelli-Shanks algorithm (Totally unoptimized and slow) // // Find Q and S, that Q * 2 ^ S = (P - 1) var q = this.m.subn(1); var s = 0; while (!q.isZero() && q.andln(1) === 0) { s++; q.iushrn(1); } assert(!q.isZero()); var one = new BN(1).toRed(this); var nOne = one.redNeg(); // Find quadratic non-residue // NOTE: Max is such because of generalized Riemann hypothesis. var lpow = this.m.subn(1).iushrn(1); var z = this.m.bitLength(); z = new BN(2 * z * z).toRed(this); while (this.pow(z, lpow).cmp(nOne) !== 0) { z.redIAdd(nOne); } var c = this.pow(z, q); var r = this.pow(a, q.addn(1).iushrn(1)); var t = this.pow(a, q); var m = s; while (t.cmp(one) !== 0) { var tmp = t; for (var i = 0; tmp.cmp(one) !== 0; i++) { tmp = tmp.redSqr(); } assert(i < m); var b = this.pow(c, new BN(1).iushln(m - i - 1)); r = r.redMul(b); c = b.redSqr(); t = t.redMul(c); m = i; } return r; }; Red.prototype.invm = function invm (a) { var inv = a._invmp(this.m); if (inv.negative !== 0) { inv.negative = 0; return this.imod(inv).redNeg(); } else { return this.imod(inv); } }; Red.prototype.pow = function pow (a, num) { if (num.isZero()) return new BN(1).toRed(this); if (num.cmpn(1) === 0) return a.clone(); var windowSize = 4; var wnd = new Array(1 << windowSize); wnd[0] = new BN(1).toRed(this); wnd[1] = a; for (var i = 2; i < wnd.length; i++) { wnd[i] = this.mul(wnd[i - 1], a); } var res = wnd[0]; var current = 0; var currentLen = 0; var start = num.bitLength() % 26; if (start === 0) { start = 26; } for (i = num.length - 1; i >= 0; i--) { var word = num.words[i]; for (var j = start - 1; j >= 0; j--) { var bit = (word >> j) & 1; if (res !== wnd[0]) { res = this.sqr(res); } if (bit === 0 && current === 0) { currentLen = 0; continue; } current <<= 1; current |= bit; currentLen++; if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue; res = this.mul(res, wnd[current]); currentLen = 0; current = 0; } start = 26; } return res; }; Red.prototype.convertTo = function convertTo (num) { var r = num.umod(this.m); return r === num ? r.clone() : r; }; Red.prototype.convertFrom = function convertFrom (num) { var res = num.clone(); res.red = null; return res; }; // // Montgomery method engine // BN.mont = function mont (num) { return new Mont(num); }; function Mont (m) { Red.call(this, m); this.shift = this.m.bitLength(); if (this.shift % 26 !== 0) { this.shift += 26 - (this.shift % 26); } this.r = new BN(1).iushln(this.shift); this.r2 = this.imod(this.r.sqr()); this.rinv = this.r._invmp(this.m); this.minv = this.rinv.mul(this.r).isubn(1).div(this.m); this.minv = this.minv.umod(this.r); this.minv = this.r.sub(this.minv); } inherits(Mont, Red); Mont.prototype.convertTo = function convertTo (num) { return this.imod(num.ushln(this.shift)); }; Mont.prototype.convertFrom = function convertFrom (num) { var r = this.imod(num.mul(this.rinv)); r.red = null; return r; }; Mont.prototype.imul = function imul (a, b) { if (a.isZero() || b.isZero()) { a.words[0] = 0; a.length = 1; return a; } var t = a.imul(b); var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m); var u = t.isub(c).iushrn(this.shift); var res = u; if (u.cmp(this.m) >= 0) { res = u.isub(this.m); } else if (u.cmpn(0) < 0) { res = u.iadd(this.m); } return res._forceRed(this); }; Mont.prototype.mul = function mul (a, b) { if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this); var t = a.mul(b); var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m); var u = t.isub(c).iushrn(this.shift); var res = u; if (u.cmp(this.m) >= 0) { res = u.isub(this.m); } else if (u.cmpn(0) < 0) { res = u.iadd(this.m); } return res._forceRed(this); }; Mont.prototype.invm = function invm (a) { // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R var res = this.imod(a._invmp(this.m).mul(this.r2)); return res._forceRed(this); }; })(typeof module === 'undefined' || module, this); },{"buffer":43}],42:[function(require,module,exports){ var r; module.exports = function rand(len) { if (!r) r = new Rand(null); return r.generate(len); }; function Rand(rand) { this.rand = rand; } module.exports.Rand = Rand; Rand.prototype.generate = function generate(len) { return this._rand(len); }; // Emulate crypto API using randy Rand.prototype._rand = function _rand(n) { if (this.rand.getBytes) return this.rand.getBytes(n); var res = new Uint8Array(n); for (var i = 0; i < res.length; i++) res[i] = this.rand.getByte(); return res; }; if (typeof self === 'object') { if (self.crypto && self.crypto.getRandomValues) { // Modern browsers Rand.prototype._rand = function _rand(n) { var arr = new Uint8Array(n); self.crypto.getRandomValues(arr); return arr; }; } else if (self.msCrypto && self.msCrypto.getRandomValues) { // IE Rand.prototype._rand = function _rand(n) { var arr = new Uint8Array(n); self.msCrypto.getRandomValues(arr); return arr; }; // Safari's WebWorkers do not have `crypto` } else if (typeof window === 'object') { // Old junk Rand.prototype._rand = function() { throw new Error('Not implemented yet'); }; } } else { // Node.js or Web worker with no crypto support try { var crypto = require('crypto'); if (typeof crypto.randomBytes !== 'function') throw new Error('Not supported'); Rand.prototype._rand = function _rand(n) { return crypto.randomBytes(n); }; } catch (e) { } } },{"crypto":43}],43:[function(require,module,exports){ },{}],44:[function(require,module,exports){ // based on the aes implimentation in triple sec // https://github.com/keybase/triplesec // which is in turn based on the one from crypto-js // https://code.google.com/p/crypto-js/ var Buffer = require('safe-buffer').Buffer function asUInt32Array (buf) { if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf) var len = (buf.length / 4) | 0 var out = new Array(len) for (var i = 0; i < len; i++) { out[i] = buf.readUInt32BE(i * 4) } return out } function scrubVec (v) { for (var i = 0; i < v.length; v++) { v[i] = 0 } } function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) { var SUB_MIX0 = SUB_MIX[0] var SUB_MIX1 = SUB_MIX[1] var SUB_MIX2 = SUB_MIX[2] var SUB_MIX3 = SUB_MIX[3] var s0 = M[0] ^ keySchedule[0] var s1 = M[1] ^ keySchedule[1] var s2 = M[2] ^ keySchedule[2] var s3 = M[3] ^ keySchedule[3] var t0, t1, t2, t3 var ksRow = 4 for (var round = 1; round < nRounds; round++) { t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++] t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++] t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++] t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++] s0 = t0 s1 = t1 s2 = t2 s3 = t3 } t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++] t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++] t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++] t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++] t0 = t0 >>> 0 t1 = t1 >>> 0 t2 = t2 >>> 0 t3 = t3 >>> 0 return [t0, t1, t2, t3] } // AES constants var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36] var G = (function () { // Compute double table var d = new Array(256) for (var j = 0; j < 256; j++) { if (j < 128) { d[j] = j << 1 } else { d[j] = (j << 1) ^ 0x11b } } var SBOX = [] var INV_SBOX = [] var SUB_MIX = [[], [], [], []] var INV_SUB_MIX = [[], [], [], []] // Walk GF(2^8) var x = 0 var xi = 0 for (var i = 0; i < 256; ++i) { // Compute sbox var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4) sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63 SBOX[x] = sx INV_SBOX[sx] = x // Compute multiplication var x2 = d[x] var x4 = d[x2] var x8 = d[x4] // Compute sub bytes, mix columns tables var t = (d[sx] * 0x101) ^ (sx * 0x1010100) SUB_MIX[0][x] = (t << 24) | (t >>> 8) SUB_MIX[1][x] = (t << 16) | (t >>> 16) SUB_MIX[2][x] = (t << 8) | (t >>> 24) SUB_MIX[3][x] = t // Compute inv sub bytes, inv mix columns tables t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100) INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8) INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16) INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24) INV_SUB_MIX[3][sx] = t if (x === 0) { x = xi = 1 } else { x = x2 ^ d[d[d[x8 ^ x2]]] xi ^= d[d[xi]] } } return { SBOX: SBOX, INV_SBOX: INV_SBOX, SUB_MIX: SUB_MIX, INV_SUB_MIX: INV_SUB_MIX } })() function AES (key) { this._key = asUInt32Array(key) this._reset() } AES.blockSize = 4 * 4 AES.keySize = 256 / 8 AES.prototype.blockSize = AES.blockSize AES.prototype.keySize = AES.keySize AES.prototype._reset = function () { var keyWords = this._key var keySize = keyWords.length var nRounds = keySize + 6 var ksRows = (nRounds + 1) * 4 var keySchedule = [] for (var k = 0; k < keySize; k++) { keySchedule[k] = keyWords[k] } for (k = keySize; k < ksRows; k++) { var t = keySchedule[k - 1] if (k % keySize === 0) { t = (t << 8) | (t >>> 24) t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | (G.SBOX[t & 0xff]) t ^= RCON[(k / keySize) | 0] << 24 } else if (keySize > 6 && k % keySize === 4) { t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | (G.SBOX[t & 0xff]) } keySchedule[k] = keySchedule[k - keySize] ^ t } var invKeySchedule = [] for (var ik = 0; ik < ksRows; ik++) { var ksR = ksRows - ik var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)] if (ik < 4 || ksR <= 4) { invKeySchedule[ik] = tt } else { invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]] } } this._nRounds = nRounds this._keySchedule = keySchedule this._invKeySchedule = invKeySchedule } AES.prototype.encryptBlockRaw = function (M) { M = asUInt32Array(M) return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds) } AES.prototype.encryptBlock = function (M) { var out = this.encryptBlockRaw(M) var buf = Buffer.allocUnsafe(16) buf.writeUInt32BE(out[0], 0) buf.writeUInt32BE(out[1], 4) buf.writeUInt32BE(out[2], 8) buf.writeUInt32BE(out[3], 12) return buf } AES.prototype.decryptBlock = function (M) { M = asUInt32Array(M) // swap var m1 = M[1] M[1] = M[3] M[3] = m1 var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds) var buf = Buffer.allocUnsafe(16) buf.writeUInt32BE(out[0], 0) buf.writeUInt32BE(out[3], 4) buf.writeUInt32BE(out[2], 8) buf.writeUInt32BE(out[1], 12) return buf } AES.prototype.scrub = function () { scrubVec(this._keySchedule) scrubVec(this._invKeySchedule) scrubVec(this._key) } module.exports.AES = AES },{"safe-buffer":262}],45:[function(require,module,exports){ var aes = require('./aes') var Buffer = require('safe-buffer').Buffer var Transform = require('cipher-base') var inherits = require('inherits') var GHASH = require('./ghash') var xor = require('buffer-xor') var incr32 = require('./incr32') function xorTest (a, b) { var out = 0 if (a.length !== b.length) out++ var len = Math.min(a.length, b.length) for (var i = 0; i < len; ++i) { out += (a[i] ^ b[i]) } return out } function calcIv (self, iv, ck) { if (iv.length === 12) { self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]) return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])]) } var ghash = new GHASH(ck) var len = iv.length var toPad = len % 16 ghash.update(iv) if (toPad) { toPad = 16 - toPad ghash.update(Buffer.alloc(toPad, 0)) } ghash.update(Buffer.alloc(8, 0)) var ivBits = len * 8 var tail = Buffer.alloc(8) tail.writeUIntBE(ivBits, 0, 8) ghash.update(tail) self._finID = ghash.state var out = Buffer.from(self._finID) incr32(out) return out } function StreamCipher (mode, key, iv, decrypt) { Transform.call(this) var h = Buffer.alloc(4, 0) this._cipher = new aes.AES(key) var ck = this._cipher.encryptBlock(h) this._ghash = new GHASH(ck) iv = calcIv(this, iv, ck) this._prev = Buffer.from(iv) this._cache = Buffer.allocUnsafe(0) this._secCache = Buffer.allocUnsafe(0) this._decrypt = decrypt this._alen = 0 this._len = 0 this._mode = mode this._authTag = null this._called = false } inherits(StreamCipher, Transform) StreamCipher.prototype._update = function (chunk) { if (!this._called && this._alen) { var rump = 16 - (this._alen % 16) if (rump < 16) { rump = Buffer.alloc(rump, 0) this._ghash.update(rump) } } this._called = true var out = this._mode.encrypt(this, chunk) if (this._decrypt) { this._ghash.update(chunk) } else { this._ghash.update(out) } this._len += chunk.length return out } StreamCipher.prototype._final = function () { if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data') var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID)) if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data') this._authTag = tag this._cipher.scrub() } StreamCipher.prototype.getAuthTag = function getAuthTag () { if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state') return this._authTag } StreamCipher.prototype.setAuthTag = function setAuthTag (tag) { if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state') this._authTag = tag } StreamCipher.prototype.setAAD = function setAAD (buf) { if (this._called) throw new Error('Attempting to set AAD in unsupported state') this._ghash.update(buf) this._alen += buf.length } module.exports = StreamCipher },{"./aes":44,"./ghash":49,"./incr32":50,"buffer-xor":74,"cipher-base":78,"inherits":203,"safe-buffer":262}],46:[function(require,module,exports){ var ciphers = require('./encrypter') var deciphers = require('./decrypter') var modes = require('./modes/list.json') function getCiphers () { return Object.keys(modes) } exports.createCipher = exports.Cipher = ciphers.createCipher exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv exports.createDecipher = exports.Decipher = deciphers.createDecipher exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv exports.listCiphers = exports.getCiphers = getCiphers },{"./decrypter":47,"./encrypter":48,"./modes/list.json":58}],47:[function(require,module,exports){ var AuthCipher = require('./authCipher') var Buffer = require('safe-buffer').Buffer var MODES = require('./modes') var StreamCipher = require('./streamCipher') var Transform = require('cipher-base') var aes = require('./aes') var ebtk = require('evp_bytestokey') var inherits = require('inherits') function Decipher (mode, key, iv) { Transform.call(this) this._cache = new Splitter() this._last = void 0 this._cipher = new aes.AES(key) this._prev = Buffer.from(iv) this._mode = mode this._autopadding = true } inherits(Decipher, Transform) Decipher.prototype._update = function (data) { this._cache.add(data) var chunk var thing var out = [] while ((chunk = this._cache.get(this._autopadding))) { thing = this._mode.decrypt(this, chunk) out.push(thing) } return Buffer.concat(out) } Decipher.prototype._final = function () { var chunk = this._cache.flush() if (this._autopadding) { return unpad(this._mode.decrypt(this, chunk)) } else if (chunk) { throw new Error('data not multiple of block length') } } Decipher.prototype.setAutoPadding = function (setTo) { this._autopadding = !!setTo return this } function Splitter () { this.cache = Buffer.allocUnsafe(0) } Splitter.prototype.add = function (data) { this.cache = Buffer.concat([this.cache, data]) } Splitter.prototype.get = function (autoPadding) { var out if (autoPadding) { if (this.cache.length > 16) { out = this.cache.slice(0, 16) this.cache = this.cache.slice(16) return out } } else { if (this.cache.length >= 16) { out = this.cache.slice(0, 16) this.cache = this.cache.slice(16) return out } } return null } Splitter.prototype.flush = function () { if (this.cache.length) return this.cache } function unpad (last) { var padded = last[15] if (padded < 1 || padded > 16) { throw new Error('unable to decrypt data') } var i = -1 while (++i < padded) { if (last[(i + (16 - padded))] !== padded) { throw new Error('unable to decrypt data') } } if (padded === 16) return return last.slice(0, 16 - padded) } function createDecipheriv (suite, password, iv) { var config = MODES[suite.toLowerCase()] if (!config) throw new TypeError('invalid suite type') if (typeof iv === 'string') iv = Buffer.from(iv) if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length) if (typeof password === 'string') password = Buffer.from(password) if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length) if (config.type === 'stream') { return new StreamCipher(config.module, password, iv, true) } else if (config.type === 'auth') { return new AuthCipher(config.module, password, iv, true) } return new Decipher(config.module, password, iv) } function createDecipher (suite, password) { var config = MODES[suite.toLowerCase()] if (!config) throw new TypeError('invalid suite type') var keys = ebtk(password, false, config.key, config.iv) return createDecipheriv(suite, keys.key, keys.iv) } exports.createDecipher = createDecipher exports.createDecipheriv = createDecipheriv },{"./aes":44,"./authCipher":45,"./modes":57,"./streamCipher":60,"cipher-base":78,"evp_bytestokey":185,"inherits":203,"safe-buffer":262}],48:[function(require,module,exports){ var MODES = require('./modes') var AuthCipher = require('./authCipher') var Buffer = require('safe-buffer').Buffer var StreamCipher = require('./streamCipher') var Transform = require('cipher-base') var aes = require('./aes') var ebtk = require('evp_bytestokey') var inherits = require('inherits') function Cipher (mode, key, iv) { Transform.call(this) this._cache = new Splitter() this._cipher = new aes.AES(key) this._prev = Buffer.from(iv) this._mode = mode this._autopadding = true } inherits(Cipher, Transform) Cipher.prototype._update = function (data) { this._cache.add(data) var chunk var thing var out = [] while ((chunk = this._cache.get())) { thing = this._mode.encrypt(this, chunk) out.push(thing) } return Buffer.concat(out) } var PADDING = Buffer.alloc(16, 0x10) Cipher.prototype._final = function () { var chunk = this._cache.flush() if (this._autopadding) { chunk = this._mode.encrypt(this, chunk) this._cipher.scrub() return chunk } if (!chunk.equals(PADDING)) { this._cipher.scrub() throw new Error('data not multiple of block length') } } Cipher.prototype.setAutoPadding = function (setTo) { this._autopadding = !!setTo return this } function Splitter () { this.cache = Buffer.allocUnsafe(0) } Splitter.prototype.add = function (data) { this.cache = Buffer.concat([this.cache, data]) } Splitter.prototype.get = function () { if (this.cache.length > 15) { var out = this.cache.slice(0, 16) this.cache = this.cache.slice(16) return out } return null } Splitter.prototype.flush = function () { var len = 16 - this.cache.length var padBuff = Buffer.allocUnsafe(len) var i = -1 while (++i < len) { padBuff.writeUInt8(len, i) } return Buffer.concat([this.cache, padBuff]) } function createCipheriv (suite, password, iv) { var config = MODES[suite.toLowerCase()] if (!config) throw new TypeError('invalid suite type') if (typeof password === 'string') password = Buffer.from(password) if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length) if (typeof iv === 'string') iv = Buffer.from(iv) if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length) if (config.type === 'stream') { return new StreamCipher(config.module, password, iv) } else if (config.type === 'auth') { return new AuthCipher(config.module, password, iv) } return new Cipher(config.module, password, iv) } function createCipher (suite, password) { var config = MODES[suite.toLowerCase()] if (!config) throw new TypeError('invalid suite type') var keys = ebtk(password, false, config.key, config.iv) return createCipheriv(suite, keys.key, keys.iv) } exports.createCipheriv = createCipheriv exports.createCipher = createCipher },{"./aes":44,"./authCipher":45,"./modes":57,"./streamCipher":60,"cipher-base":78,"evp_bytestokey":185,"inherits":203,"safe-buffer":262}],49:[function(require,module,exports){ var Buffer = require('safe-buffer').Buffer var ZEROES = Buffer.alloc(16, 0) function toArray (buf) { return [ buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12) ] } function fromArray (out) { var buf = Buffer.allocUnsafe(16) buf.writeUInt32BE(out[0] >>> 0, 0) buf.writeUInt32BE(out[1] >>> 0, 4) buf.writeUInt32BE(out[2] >>> 0, 8) buf.writeUInt32BE(out[3] >>> 0, 12) return buf } function GHASH (key) { this.h = key this.state = Buffer.alloc(16, 0) this.cache = Buffer.allocUnsafe(0) } // from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html // by Juho Vähä-Herttua GHASH.prototype.ghash = function (block) { var i = -1 while (++i < block.length) { this.state[i] ^= block[i] } this._multiply() } GHASH.prototype._multiply = function () { var Vi = toArray(this.h) var Zi = [0, 0, 0, 0] var j, xi, lsbVi var i = -1 while (++i < 128) { xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0 if (xi) { // Z_i+1 = Z_i ^ V_i Zi[0] ^= Vi[0] Zi[1] ^= Vi[1] Zi[2] ^= Vi[2] Zi[3] ^= Vi[3] } // Store the value of LSB(V_i) lsbVi = (Vi[3] & 1) !== 0 // V_i+1 = V_i >> 1 for (j = 3; j > 0; j--) { Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31) } Vi[0] = Vi[0] >>> 1 // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R if (lsbVi) { Vi[0] = Vi[0] ^ (0xe1 << 24) } } this.state = fromArray(Zi) } GHASH.prototype.update = function (buf) { this.cache = Buffer.concat([this.cache, buf]) var chunk while (this.cache.length >= 16) { chunk = this.cache.slice(0, 16) this.cache = this.cache.slice(16) this.ghash(chunk) } } GHASH.prototype.final = function (abl, bl) { if (this.cache.length) { this.ghash(Buffer.concat([this.cache, ZEROES], 16)) } this.ghash(fromArray([0, abl, 0, bl])) return this.state } module.exports = GHASH },{"safe-buffer":262}],50:[function(require,module,exports){ function incr32 (iv) { var len = iv.length var item while (len--) { item = iv.readUInt8(len) if (item === 255) { iv.writeUInt8(0, len) } else { item++ iv.writeUInt8(item, len) break } } } module.exports = incr32 },{}],51:[function(require,module,exports){ var xor = require('buffer-xor') exports.encrypt = function (self, block) { var data = xor(block, self._prev) self._prev = self._cipher.encryptBlock(data) return self._prev } exports.decrypt = function (self, block) { var pad = self._prev self._prev = block var out = self._cipher.decryptBlock(block) return xor(out, pad) } },{"buffer-xor":74}],52:[function(require,module,exports){ var Buffer = require('safe-buffer').Buffer var xor = require('buffer-xor') function encryptStart (self, data, decrypt) { var len = data.length var out = xor(data, self._cache) self._cache = self._cache.slice(len) self._prev = Buffer.concat([self._prev, decrypt ? data : out]) return out } exports.encrypt = function (self, data, decrypt) { var out = Buffer.allocUnsafe(0) var len while (data.length) { if (self._cache.length === 0) { self._cache = self._cipher.encryptBlock(self._prev) self._prev = Buffer.allocUnsafe(0) } if (self._cache.length <= data.length) { len = self._cache.length out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]) data = data.slice(len) } else { out = Buffer.concat([out, encryptStart(self, data, decrypt)]) break } } return out } },{"buffer-xor":74,"safe-buffer":262}],53:[function(require,module,exports){ var Buffer = require('safe-buffer').Buffer function encryptByte (self, byteParam, decrypt) { var pad var i = -1 var len = 8 var out = 0 var bit, value while (++i < len) { pad = self._cipher.encryptBlock(self._prev) bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0 value = pad[0] ^ bit out += ((value & 0x80) >> (i % 8)) self._prev = shiftIn(self._prev, decrypt ? bit : value) } return out } function shiftIn (buffer, value) { var len = buffer.length var i = -1 var out = Buffer.allocUnsafe(buffer.length) buffer = Buffer.concat([buffer, Buffer.from([value])]) while (++i < len) { out[i] = buffer[i] << 1 | buffer[i + 1] >> (7) } return out } exports.encrypt = function (self, chunk, decrypt) { var len = chunk.length var out = Buffer.allocUnsafe(len) var i = -1 while (++i < len) { out[i] = encryptByte(self, chunk[i], decrypt) } return out } },{"safe-buffer":262}],54:[function(require,module,exports){ var Buffer = require('safe-buffer').Buffer function encryptByte (self, byteParam, decrypt) { var pad = self._cipher.encryptBlock(self._prev) var out = pad[0] ^ byteParam self._prev = Buffer.concat([ self._prev.slice(1), Buffer.from([decrypt ? byteParam : out]) ]) return out } exports.encrypt = function (self, chunk, decrypt) { var len = chunk.length var out = Buffer.allocUnsafe(len) var i = -1 while (++i < len) { out[i] = encryptByte(self, chunk[i], decrypt) } return out } },{"safe-buffer":262}],55:[function(require,module,exports){ var xor = require('buffer-xor') var Buffer = require('safe-buffer').Buffer var incr32 = require('../incr32') function getBlock (self) { var out = self._cipher.encryptBlockRaw(self._prev) incr32(self._prev) return out } var blockSize = 16 exports.encrypt = function (self, chunk) { var chunkNum = Math.ceil(chunk.length / blockSize) var start = self._cache.length self._cache = Buffer.concat([ self._cache, Buffer.allocUnsafe(chunkNum * blockSize) ]) for (var i = 0; i < chunkNum; i++) { var out = getBlock(self) var offset = start + i * blockSize self._cache.writeUInt32BE(out[0], offset + 0) self._cache.writeUInt32BE(out[1], offset + 4) self._cache.writeUInt32BE(out[2], offset + 8) self._cache.writeUInt32BE(out[3], offset + 12) } var pad = self._cache.slice(0, chunk.length) self._cache = self._cache.slice(chunk.length) return xor(chunk, pad) } },{"../incr32":50,"buffer-xor":74,"safe-buffer":262}],56:[function(require,module,exports){ exports.encrypt = function (self, block) { return self._cipher.encryptBlock(block) } exports.decrypt = function (self, block) { return self._cipher.decryptBlock(block) } },{}],57:[function(require,module,exports){ var modeModules = { ECB: require('./ecb'), CBC: require('./cbc'), CFB: require('./cfb'), CFB8: require('./cfb8'), CFB1: require('./cfb1'), OFB: require('./ofb'), CTR: require('./ctr'), GCM: require('./ctr') } var modes = require('./list.json') for (var key in modes) { modes[key].module = modeModules[modes[key].mode] } module.exports = modes },{"./cbc":51,"./cfb":52,"./cfb1":53,"./cfb8":54,"./ctr":55,"./ecb":56,"./list.json":58,"./ofb":59}],58:[function(require,module,exports){ module.exports={ "aes-128-ecb": { "cipher": "AES", "key": 128, "iv": 0, "mode": "ECB", "type": "block" }, "aes-192-ecb": { "cipher": "AES", "key": 192, "iv": 0, "mode": "ECB", "type": "block" }, "aes-256-ecb": { "cipher": "AES", "key": 256, "iv": 0, "mode": "ECB", "type": "block" }, "aes-128-cbc": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CBC", "type": "block" }, "aes-192-cbc": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CBC", "type": "block" }, "aes-256-cbc": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CBC", "type": "block" }, "aes128": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CBC", "type": "block" }, "aes192": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CBC", "type": "block" }, "aes256": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CBC", "type": "block" }, "aes-128-cfb": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB", "type": "stream" }, "aes-192-cfb": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB", "type": "stream" }, "aes-256-cfb": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB", "type": "stream" }, "aes-128-cfb8": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB8", "type": "stream" }, "aes-192-cfb8": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB8", "type": "stream" }, "aes-256-cfb8": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB8", "type": "stream" }, "aes-128-cfb1": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB1", "type": "stream" }, "aes-192-cfb1": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB1", "type": "stream" }, "aes-256-cfb1": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB1", "type": "stream" }, "aes-128-ofb": { "cipher": "AES", "key": 128, "iv": 16, "mode": "OFB", "type": "stream" }, "aes-192-ofb": { "cipher": "AES", "key": 192, "iv": 16, "mode": "OFB", "type": "stream" }, "aes-256-ofb": { "cipher": "AES", "key": 256, "iv": 16, "mode": "OFB", "type": "stream" }, "aes-128-ctr": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CTR", "type": "stream" }, "aes-192-ctr": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CTR", "type": "stream" }, "aes-256-ctr": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CTR", "type": "stream" }, "aes-128-gcm": { "cipher": "AES", "key": 128, "iv": 12, "mode": "GCM", "type": "auth" }, "aes-192-gcm": { "cipher": "AES", "key": 192, "iv": 12, "mode": "GCM", "type": "auth" }, "aes-256-gcm": { "cipher": "AES", "key": 256, "iv": 12, "mode": "GCM", "type": "auth" } } },{}],59:[function(require,module,exports){ (function (Buffer){ var xor = require('buffer-xor') function getBlock (self) { self._prev = self._cipher.encryptBlock(self._prev) return self._prev } exports.encrypt = function (self, chunk) { while (self._cache.length < chunk.length) { self._cache = Buffer.concat([self._cache, getBlock(self)]) } var pad = self._cache.slice(0, chunk.length) self._cache = self._cache.slice(chunk.length) return xor(chunk, pad) } }).call(this,require("buffer").Buffer) },{"buffer":75,"buffer-xor":74}],60:[function(require,module,exports){ var aes = require('./aes') var Buffer = require('safe-buffer').Buffer var Transform = require('cipher-base') var inherits = require('inherits') function StreamCipher (mode, key, iv, decrypt) { Transform.call(this) this._cipher = new aes.AES(key) this._prev = Buffer.from(iv) this._cache = Buffer.allocUnsafe(0) this._secCache = Buffer.allocUnsafe(0) this._decrypt = decrypt this._mode = mode } inherits(StreamCipher, Transform) StreamCipher.prototype._update = function (chunk) { return this._mode.encrypt(this, chunk, this._decrypt) } StreamCipher.prototype._final = function () { this._cipher.scrub() } module.exports = StreamCipher },{"./aes":44,"cipher-base":78,"inherits":203,"safe-buffer":262}],61:[function(require,module,exports){ var DES = require('browserify-des') var aes = require('browserify-aes/browser') var aesModes = require('browserify-aes/modes') var desModes = require('browserify-des/modes') var ebtk = require('evp_bytestokey') function createCipher (suite, password) { suite = suite.toLowerCase() var keyLen, ivLen if (aesModes[suite]) { keyLen = aesModes[suite].key ivLen = aesModes[suite].iv } else if (desModes[suite]) { keyLen = desModes[suite].key * 8 ivLen = desModes[suite].iv } else { throw new TypeError('invalid suite type') } var keys = ebtk(password, false, keyLen, ivLen) return createCipheriv(suite, keys.key, keys.iv) } function createDecipher (suite, password) { suite = suite.toLowerCase() var keyLen, ivLen if (aesModes[suite]) { keyLen = aesModes[suite].key ivLen = aesModes[suite].iv } else if (desModes[suite]) { keyLen = desModes[suite].key * 8 ivLen = desModes[suite].iv } else { throw new TypeError('invalid suite type') } var keys = ebtk(password, false, keyLen, ivLen) return createDecipheriv(suite, keys.key, keys.iv) } function createCipheriv (suite, key, iv) { suite = suite.toLowerCase() if (aesModes[suite]) return aes.createCipheriv(suite, key, iv) if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite }) throw new TypeError('invalid suite type') } function createDecipheriv (suite, key, iv) { suite = suite.toLowerCase() if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv) if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true }) throw new TypeError('invalid suite type') } function getCiphers () { return Object.keys(desModes).concat(aes.getCiphers()) } exports.createCipher = exports.Cipher = createCipher exports.createCipheriv = exports.Cipheriv = createCipheriv exports.createDecipher = exports.Decipher = createDecipher exports.createDecipheriv = exports.Decipheriv = createDecipheriv exports.listCiphers = exports.getCiphers = getCiphers },{"browserify-aes/browser":46,"browserify-aes/modes":57,"browserify-des":62,"browserify-des/modes":63,"evp_bytestokey":185}],62:[function(require,module,exports){ var CipherBase = require('cipher-base') var des = require('des.js') var inherits = require('inherits') var Buffer = require('safe-buffer').Buffer var modes = { 'des-ede3-cbc': des.CBC.instantiate(des.EDE), 'des-ede3': des.EDE, 'des-ede-cbc': des.CBC.instantiate(des.EDE), 'des-ede': des.EDE, 'des-cbc': des.CBC.instantiate(des.DES), 'des-ecb': des.DES } modes.des = modes['des-cbc'] modes.des3 = modes['des-ede3-cbc'] module.exports = DES inherits(DES, CipherBase) function DES (opts) { CipherBase.call(this) var modeName = opts.mode.toLowerCase() var mode = modes[modeName] var type if (opts.decrypt) { type = 'decrypt' } else { type = 'encrypt' } var key = opts.key if (!Buffer.isBuffer(key)) { key = Buffer.from(key) } if (modeName === 'des-ede' || modeName === 'des-ede-cbc') { key = Buffer.concat([key, key.slice(0, 8)]) } var iv = opts.iv if (!Buffer.isBuffer(iv)) { iv = Buffer.from(iv) } this._des = mode.create({ key: key, iv: iv, type: type }) } DES.prototype._update = function (data) { return Buffer.from(this._des.update(data)) } DES.prototype._final = function () { return Buffer.from(this._des.final()) } },{"cipher-base":78,"des.js":88,"inherits":203,"safe-buffer":262}],63:[function(require,module,exports){ exports['des-ecb'] = { key: 8, iv: 0 } exports['des-cbc'] = exports.des = { key: 8, iv: 8 } exports['des-ede3-cbc'] = exports.des3 = { key: 24, iv: 8 } exports['des-ede3'] = { key: 24, iv: 0 } exports['des-ede-cbc'] = { key: 16, iv: 8 } exports['des-ede'] = { key: 16, iv: 0 } },{}],64:[function(require,module,exports){ (function (Buffer){ var bn = require('bn.js'); var randomBytes = require('randombytes'); module.exports = crt; function blind(priv) { var r = getr(priv); var blinder = r.toRed(bn.mont(priv.modulus)) .redPow(new bn(priv.publicExponent)).fromRed(); return { blinder: blinder, unblinder:r.invm(priv.modulus) }; } function crt(msg, priv) { var blinds = blind(priv); var len = priv.modulus.byteLength(); var mod = bn.mont(priv.modulus); var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus); var c1 = blinded.toRed(bn.mont(priv.prime1)); var c2 = blinded.toRed(bn.mont(priv.prime2)); var qinv = priv.coefficient; var p = priv.prime1; var q = priv.prime2; var m1 = c1.redPow(priv.exponent1); var m2 = c2.redPow(priv.exponent2); m1 = m1.fromRed(); m2 = m2.fromRed(); var h = m1.isub(m2).imul(qinv).umod(p); h.imul(q); m2.iadd(h); return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len)); } crt.getr = getr; function getr(priv) { var len = priv.modulus.byteLength(); var r = new bn(randomBytes(len)); while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) { r = new bn(randomBytes(len)); } return r; } }).call(this,require("buffer").Buffer) },{"bn.js":41,"buffer":75,"randombytes":246}],65:[function(require,module,exports){ module.exports = require('./browser/algorithms.json') },{"./browser/algorithms.json":66}],66:[function(require,module,exports){ module.exports={ "sha224WithRSAEncryption": { "sign": "rsa", "hash": "sha224", "id": "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { "sign": "ecdsa/rsa", "hash": "sha224", "id": "302d300d06096086480165030402040500041c" }, "sha256WithRSAEncryption": { "sign": "rsa", "hash": "sha256", "id": "3031300d060960864801650304020105000420" }, "RSA-SHA256": { "sign": "ecdsa/rsa", "hash": "sha256", "id": "3031300d060960864801650304020105000420" }, "sha384WithRSAEncryption": { "sign": "rsa", "hash": "sha384", "id": "3041300d060960864801650304020205000430" }, "RSA-SHA384": { "sign": "ecdsa/rsa", "hash": "sha384", "id": "3041300d060960864801650304020205000430" }, "sha512WithRSAEncryption": { "sign": "rsa", "hash": "sha512", "id": "3051300d060960864801650304020305000440" }, "RSA-SHA512": { "sign": "ecdsa/rsa", "hash": "sha512", "id": "3051300d060960864801650304020305000440" }, "RSA-SHA1": { "sign": "rsa", "hash": "sha1", "id": "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { "sign": "ecdsa", "hash": "sha1", "id": "" }, "sha256": { "sign": "ecdsa", "hash": "sha256", "id": "" }, "sha224": { "sign": "ecdsa", "hash": "sha224", "id": "" }, "sha384": { "sign": "ecdsa", "hash": "sha384", "id": "" }, "sha512": { "sign": "ecdsa", "hash": "sha512", "id": "" }, "DSA-SHA": { "sign": "dsa", "hash": "sha1", "id": "" }, "DSA-SHA1": { "sign": "dsa", "hash": "sha1", "id": "" }, "DSA": { "sign": "dsa", "hash": "sha1", "id": "" }, "DSA-WITH-SHA224": { "sign": "dsa", "hash": "sha224", "id": "" }, "DSA-SHA224": { "sign": "dsa", "hash": "sha224", "id": "" }, "DSA-WITH-SHA256": { "sign": "dsa", "hash": "sha256", "id": "" }, "DSA-SHA256": { "sign": "dsa", "hash": "sha256", "id": "" }, "DSA-WITH-SHA384": { "sign": "dsa", "hash": "sha384", "id": "" }, "DSA-SHA384": { "sign": "dsa", "hash": "sha384", "id": "" }, "DSA-WITH-SHA512": { "sign": "dsa", "hash": "sha512", "id": "" }, "DSA-SHA512": { "sign": "dsa", "hash": "sha512", "id": "" }, "DSA-RIPEMD160": { "sign": "dsa", "hash": "rmd160", "id": "" }, "ripemd160WithRSA": { "sign": "rsa", "hash": "rmd160", "id": "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { "sign": "rsa", "hash": "rmd160", "id": "3021300906052b2403020105000414" }, "md5WithRSAEncryption": { "sign": "rsa", "hash": "md5", "id": "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { "sign": "rsa", "hash": "md5", "id": "3020300c06082a864886f70d020505000410" } } },{}],67:[function(require,module,exports){ module.exports={ "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" } },{}],68:[function(require,module,exports){ (function (Buffer){ var createHash = require('create-hash') var stream = require('stream') var inherits = require('inherits') var sign = require('./sign') var verify = require('./verify') var algorithms = require('./algorithms.json') Object.keys(algorithms).forEach(function (key) { algorithms[key].id = new Buffer(algorithms[key].id, 'hex') algorithms[key.toLowerCase()] = algorithms[key] }) function Sign (algorithm) { stream.Writable.call(this) var data = algorithms[algorithm] if (!data) throw new Error('Unknown message digest') this._hashType = data.hash this._hash = createHash(data.hash) this._tag = data.id this._signType = data.sign } inherits(Sign, stream.Writable) Sign.prototype._write = function _write (data, _, done) { this._hash.update(data) done() } Sign.prototype.update = function update (data, enc) { if (typeof data === 'string') data = new Buffer(data, enc) this._hash.update(data) return this } Sign.prototype.sign = function signMethod (key, enc) { this.end() var hash = this._hash.digest() var sig = sign(hash, key, this._hashType, this._signType, this._tag) return enc ? sig.toString(enc) : sig } function Verify (algorithm) { stream.Writable.call(this) var data = algorithms[algorithm] if (!data) throw new Error('Unknown message digest') this._hash = createHash(data.hash) this._tag = data.id this._signType = data.sign } inherits(Verify, stream.Writable) Verify.prototype._write = function _write (data, _, done) { this._hash.update(data) done() } Verify.prototype.update = function update (data, enc) { if (typeof data === 'string') data = new Buffer(data, enc) this._hash.update(data) return this } Verify.prototype.verify = function verifyMethod (key, sig, enc) { if (typeof sig === 'string') sig = new Buffer(sig, enc) this.end() var hash = this._hash.digest() return verify(sig, hash, key, this._signType, this._tag) } function createSign (algorithm) { return new Sign(algorithm) } function createVerify (algorithm) { return new Verify(algorithm) } module.exports = { Sign: createSign, Verify: createVerify, createSign: createSign, createVerify: createVerify } }).call(this,require("buffer").Buffer) },{"./algorithms.json":66,"./sign":69,"./verify":70,"buffer":75,"create-hash":83,"inherits":203,"stream":273}],69:[function(require,module,exports){ (function (Buffer){ // much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js var createHmac = require('create-hmac') var crt = require('browserify-rsa') var EC = require('elliptic').ec var BN = require('bn.js') var parseKeys = require('parse-asn1') var curves = require('./curves.json') function sign (hash, key, hashType, signType, tag) { var priv = parseKeys(key) if (priv.curve) { // rsa keys can be interpreted as ecdsa ones in openssl if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type') return ecSign(hash, priv) } else if (priv.type === 'dsa') { if (signType !== 'dsa') throw new Error('wrong private key type') return dsaSign(hash, priv, hashType) } else { if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type') } hash = Buffer.concat([tag, hash]) var len = priv.modulus.byteLength() var pad = [ 0, 1 ] while (hash.length + pad.length + 1 < len) pad.push(0xff) pad.push(0x00) var i = -1 while (++i < hash.length) pad.push(hash[i]) var out = crt(pad, priv) return out } function ecSign (hash, priv) { var curveId = curves[priv.curve.join('.')] if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.')) var curve = new EC(curveId) var key = curve.keyFromPrivate(priv.privateKey) var out = key.sign(hash) return new Buffer(out.toDER()) } function dsaSign (hash, priv, algo) { var x = priv.params.priv_key var p = priv.params.p var q = priv.params.q var g = priv.params.g var r = new BN(0) var k var H = bits2int(hash, q).mod(q) var s = false var kv = getKey(x, q, hash, algo) while (s === false) { k = makeKey(q, kv, algo) r = makeR(g, k, p, q) s = k.invm(q).imul(H.add(x.mul(r))).mod(q) if (s.cmpn(0) === 0) { s = false r = new BN(0) } } return toDER(r, s) } function toDER (r, s) { r = r.toArray() s = s.toArray() // Pad values if (r[0] & 0x80) r = [ 0 ].concat(r) if (s[0] & 0x80) s = [ 0 ].concat(s) var total = r.length + s.length + 4 var res = [ 0x30, total, 0x02, r.length ] res = res.concat(r, [ 0x02, s.length ], s) return new Buffer(res) } function getKey (x, q, hash, algo) { x = new Buffer(x.toArray()) if (x.length < q.byteLength()) { var zeros = new Buffer(q.byteLength() - x.length) zeros.fill(0) x = Buffer.concat([ zeros, x ]) } var hlen = hash.length var hbits = bits2octets(hash, q) var v = new Buffer(hlen) v.fill(1) var k = new Buffer(hlen) k.fill(0) k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest() v = createHmac(algo, k).update(v).digest() k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest() v = createHmac(algo, k).update(v).digest() return { k: k, v: v } } function bits2int (obits, q) { var bits = new BN(obits) var shift = (obits.length << 3) - q.bitLength() if (shift > 0) bits.ishrn(shift) return bits } function bits2octets (bits, q) { bits = bits2int(bits, q) bits = bits.mod(q) var out = new Buffer(bits.toArray()) if (out.length < q.byteLength()) { var zeros = new Buffer(q.byteLength() - out.length) zeros.fill(0) out = Buffer.concat([ zeros, out ]) } return out } function makeKey (q, kv, algo) { var t var k do { t = new Buffer(0) while (t.length * 8 < q.bitLength()) { kv.v = createHmac(algo, kv.k).update(kv.v).digest() t = Buffer.concat([ t, kv.v ]) } k = bits2int(t, q) kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest() kv.v = createHmac(algo, kv.k).update(kv.v).digest() } while (k.cmp(q) !== -1) return k } function makeR (g, k, p, q) { return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q) } module.exports = sign module.exports.getKey = getKey module.exports.makeKey = makeKey }).call(this,require("buffer").Buffer) },{"./curves.json":67,"bn.js":41,"browserify-rsa":64,"buffer":75,"create-hmac":85,"elliptic":168,"parse-asn1":222}],70:[function(require,module,exports){ (function (Buffer){ // much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js var BN = require('bn.js') var EC = require('elliptic').ec var parseKeys = require('parse-asn1') var curves = require('./curves.json') function verify (sig, hash, key, signType, tag) { var pub = parseKeys(key) if (pub.type === 'ec') { // rsa keys can be interpreted as ecdsa ones in openssl if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type') return ecVerify(sig, hash, pub) } else if (pub.type === 'dsa') { if (signType !== 'dsa') throw new Error('wrong public key type') return dsaVerify(sig, hash, pub) } else { if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type') } hash = Buffer.concat([tag, hash]) var len = pub.modulus.byteLength() var pad = [ 1 ] var padNum = 0 while (hash.length + pad.length + 2 < len) { pad.push(0xff) padNum++ } pad.push(0x00) var i = -1 while (++i < hash.length) { pad.push(hash[i]) } pad = new Buffer(pad) var red = BN.mont(pub.modulus) sig = new BN(sig).toRed(red) sig = sig.redPow(new BN(pub.publicExponent)) sig = new Buffer(sig.fromRed().toArray()) var out = padNum < 8 ? 1 : 0 len = Math.min(sig.length, pad.length) if (sig.length !== pad.length) out = 1 i = -1 while (++i < len) out |= sig[i] ^ pad[i] return out === 0 } function ecVerify (sig, hash, pub) { var curveId = curves[pub.data.algorithm.curve.join('.')] if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.')) var curve = new EC(curveId) var pubkey = pub.data.subjectPrivateKey.data return curve.verify(hash, sig, pubkey) } function dsaVerify (sig, hash, pub) { var p = pub.data.p var q = pub.data.q var g = pub.data.g var y = pub.data.pub_key var unpacked = parseKeys.signature.decode(sig, 'der') var s = unpacked.s var r = unpacked.r checkValue(s, q) checkValue(r, q) var montp = BN.mont(p) var w = s.invm(q) var v = g.toRed(montp) .redPow(new BN(hash).mul(w).mod(q)) .fromRed() .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()) .mod(p) .mod(q) return v.cmp(r) === 0 } function checkValue (b, q) { if (b.cmpn(0) <= 0) throw new Error('invalid sig') if (b.cmp(q) >= q) throw new Error('invalid sig') } module.exports = verify }).call(this,require("buffer").Buffer) },{"./curves.json":67,"bn.js":41,"buffer":75,"elliptic":168,"parse-asn1":222}],71:[function(require,module,exports){ // Copyright Joyent, Inc. and other Node contributors. // // Permission is hereby granted, free of charge, to any person obtaining a // copy of this software and associated documentation files (the // "Software"), to deal in the Software without restriction, including // without limitation the rights to use, copy, modify, merge, publish, // distribute, sublicense, and/or sell copies of the Software, and to permit // persons to whom the Software is furnished to do so, subject to the // following conditions: // // The above copyright notice and this permission notice shall be included // in all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE // USE OR OTHER DEALINGS IN THE SOFTWARE. var Buffer = require('buffer').Buffer; var isBufferEncoding = Buffer.isEncoding || function(encoding) { switch (encoding && encoding.toLowerCase()) { case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true; default: return false; } } function assertEncoding(encoding) { if (encoding && !isBufferEncoding(encoding)) { throw new Error('Unknown encoding: ' + encoding); } } // StringDecoder provides an interface for efficiently splitting a series of // buffers into a series of JS strings without breaking apart multi-byte // characters. CESU-8 is handled as part of the UTF-8 encoding. // // @TODO Handling all encodings inside a single object makes it very difficult // to reason about this code, so it should be split up in the future. // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code // points as used by CESU-8. var StringDecoder = exports.StringDecoder = function(encoding) { this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, ''); assertEncoding(encoding); switch (this.encoding) { case 'utf8': // CESU-8 represents each of Surrogate Pair by 3-bytes this.surrogateSize = 3; break; case 'ucs2': case 'utf16le': // UTF-16 represents each of Surrogate Pair by 2-bytes this.surrogateSize = 2; this.detectIncompleteChar = utf16DetectIncompleteChar; break; case 'base64': // Base-64 stores 3 bytes in 4 chars, and pads the remainder. this.surrogateSize = 3; this.detectIncompleteChar = base64DetectIncompleteChar; break; default: this.write = passThroughWrite; return; } // Enough space to store all bytes of a single character. UTF-8 needs 4 // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate). this.charBuffer = new Buffer(6); // Number of bytes received for the current incomplete multi-byte character. this.charReceived = 0; // Number of bytes expected for the current incomplete multi-byte character. this.charLength = 0; }; // write decodes the given buffer and returns it as JS string that is // guaranteed to not contain any partial multi-byte characters. Any partial // character found at the end of the buffer is buffered up, and will be // returned when calling write again with the remaining bytes. // // Note: Converting a Buffer containing an orphan surrogate to a String // currently works, but converting a String to a Buffer (via `new Buffer`, or // Buffer#write) will replace incomplete surrogates with the unicode // replacement character. See https://codereview.chromium.org/121173009/ . StringDecoder.prototype.write = function(buffer) { var charStr = ''; // if our last write ended with an incomplete multibyte character while (this.charLength) { // determine how many remaining bytes this buffer has to offer for this char var available = (buffer.length >= this.charLength - this.charReceived) ? this.charLength - this.charReceived : buffer.length; // add the new bytes to the char buffer buffer.copy(this.charBuffer, this.charReceived, 0, available); this.charReceived += available; if (this.charReceived < this.charLength) { // still not enough chars in this buffer? wait for more ... return ''; } // remove bytes belonging to the current character from the buffer buffer = buffer.slice(available, buffer.length); // get the character that was split charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding); // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character var charCode = charStr.charCodeAt(charStr.length - 1); if (charCode >= 0xD800 && charCode <= 0xDBFF) { this.charLength += this.surrogateSize; charStr = ''; continue; } this.charReceived = this.charLength = 0; // if there are no more bytes in this buffer, just emit our char if (buffer.length === 0) { return charStr; } break; } // determine and set charLength / charReceived this.detectIncompleteChar(buffer); var end = buffer.length; if (this.charLength) { // buffer the incomplete character bytes we got buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end); end -= this.charReceived; } charStr += buffer.toString(this.encoding, 0, end); var end = charStr.length - 1; var charCode = charStr.charCodeAt(end); // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character if (charCode >= 0xD800 && charCode <= 0xDBFF) { var size = this.surrogateSize; this.charLength += size; this.charReceived += size; this.charBuffer.copy(this.charBuffer, size, 0, size); buffer.copy(this.charBuffer, 0, 0, size); return charStr.substring(0, end); } // or just emit the charStr return charStr; }; // detectIncompleteChar determines if there is an incomplete UTF-8 character at // the end of the given buffer. If so, it sets this.charLength to the byte // length that character, and sets this.charReceived to the number of bytes // that are available for this character. StringDecoder.prototype.detectIncompleteChar = function(buffer) { // determine how many bytes we have to check at the end of this buffer var i = (buffer.length >= 3) ? 3 : buffer.length; // Figure out if one of the last i bytes of our buffer announces an // incomplete char. for (; i > 0; i--) { var c = buffer[buffer.length - i]; // See http://en.wikipedia.org/wiki/UTF-8#Description // 110XXXXX if (i == 1 && c >> 5 == 0x06) { this.charLength = 2; break; } // 1110XXXX if (i <= 2 && c >> 4 == 0x0E) { this.charLength = 3; break; } // 11110XXX if (i <= 3 && c >> 3 == 0x1E) { this.charLength = 4; break; } } this.charReceived = i; }; StringDecoder.prototype.end = function(buffer) { var res = ''; if (buffer && buffer.length) res = this.write(buffer); if (this.charReceived) { var cr = this.charReceived; var buf = this.charBuffer; var enc = this.encoding; res += buf.slice(0, cr).toString(enc); } return res; }; function passThroughWrite(buffer) { return buffer.toString(this.encoding); } function utf16DetectIncompleteChar(buffer) { this.charReceived = buffer.length % 2; this.charLength = this.charReceived ? 2 : 0; } function base64DetectIncompleteChar(buffer) { this.charReceived = buffer.length % 3; this.charLength = this.charReceived ? 3 : 0; } },{"buffer":75}],72:[function(require,module,exports){ // Base58 encoding/decoding // Originally written by Mike Hearn for BitcoinJ // Copyright (c) 2011 Google Inc // Ported to JavaScript by Stefan Thomas // Merged Buffer refactorings from base58-native by Stephen Pair // Copyright (c) 2013 BitPay Inc var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz' var ALPHABET_MAP = {} for(var i = 0; i < ALPHABET.length; i++) { ALPHABET_MAP[ALPHABET.charAt(i)] = i } var BASE = 58 function encode(buffer) { if (buffer.length === 0) return '' var i, j, digits = [0] for (i = 0; i < buffer.length; i++) { for (j = 0; j < digits.length; j++) digits[j] <<= 8 digits[0] += buffer[i] var carry = 0 for (j = 0; j < digits.length; ++j) { digits[j] += carry carry = (digits[j] / BASE) | 0 digits[j] %= BASE } while (carry) { digits.push(carry % BASE) carry = (carry / BASE) | 0 } } // deal with leading zeros for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) digits.push(0) // convert digits to a string var stringOutput = "" for (var i = digits.length - 1; i >= 0; i--) { stringOutput = stringOutput + ALPHABET[digits[i]] } return stringOutput } function decode(string) { if (string.length === 0) return [] var i, j, bytes = [0] for (i = 0; i < string.length; i++) { var c = string[i] if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character') for (j = 0; j < bytes.length; j++) bytes[j] *= BASE bytes[0] += ALPHABET_MAP[c] var carry = 0 for (j = 0; j < bytes.length; ++j) { bytes[j] += carry carry = bytes[j] >> 8 bytes[j] &= 0xff } while (carry) { bytes.push(carry & 0xff) carry >>= 8 } } // deal with leading zeros for (i = 0; string[i] === '1' && i < string.length - 1; i++) bytes.push(0) return bytes.reverse() } module.exports = { encode: encode, decode: decode } },{}],73:[function(require,module,exports){ module.exports = function(a, b) { if (typeof a.compare === 'function') return a.compare(b) if (a === b) return 0 var x = a.length var y = b.length var i = 0 var len = Math.min(x, y) while (i < len) { if (a[i] !== b[i]) break ++i } if (i !== len) { x = a[i] y = b[i] } if (x < y) return -1 if (y < x) return 1 return 0 } },{}],74:[function(require,module,exports){ (function (Buffer){ module.exports = function xor (a, b) { var length = Math.min(a.length, b.length) var buffer = new Buffer(length) for (var i = 0; i < length; ++i) { buffer[i] = a[i] ^ b[i] } return buffer } }).call(this,require("buffer").Buffer) },{"buffer":75}],75:[function(require,module,exports){ (function (global,Buffer){ /*! * The buffer module from node.js, for the browser. * * @author Feross Aboukhadijeh <feross@feross.org> <http://feross.org> * @license MIT */ /* eslint-disable no-proto */ 'use strict' var base64 = require('base64-js') var ieee754 = require('ieee754') var isArray = require('isarray') exports.Buffer = Buffer exports.SlowBuffer = SlowBuffer exports.INSPECT_MAX_BYTES = 50 /** * If `Buffer.TYPED_ARRAY_SUPPORT`: * === true Use Uint8Array implementation (fastest) * === false Use Object implementation (most compatible, even IE6) * * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+, * Opera 11.6+, iOS 4.2+. * * Due to various browser bugs, sometimes the Object implementation will be used even * when the browser supports typed arrays. * * Note: * * - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances, * See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438. * * - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function. * * - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of * incorrect length in some situations. * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they * get the Object implementation, which is slower but behaves correctly. */ Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport() /* * Export kMaxLength after typed array support is determined. */ exports.kMaxLength = kMaxLength() function typedArraySupport () { try { var arr = new Uint8Array(1) arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }} return arr.foo() === 42 && // typed array instances can be augmented typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray` arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray` } catch (e) { return false } } function kMaxLength () { return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff } function createBuffer (that, length) { if (kMaxLength() < length) { throw new RangeError('Invalid typed array length') } if (Buffer.TYPED_ARRAY_SUPPORT) { // Return an augmented `Uint8Array` instance, for best performance that = new Uint8Array(length) that.__proto__ = Buffer.prototype } else { // Fallback: Return an object instance of the Buffer class if (that === null) { that = new Buffer(length) } that.length = length } return that } /** * The Buffer constructor returns instances of `Uint8Array` that have their * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of * `Uint8Array`, so the returned instances will have all the node `Buffer` methods * and the `Uint8Array` methods. Square bracket notation works as expected -- it * returns a single octet. * * The `Uint8Array` prototype remains unmodified. */ function Buffer (arg, encodingOrOffset, length) { if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) { return new Buffer(arg, encodingOrOffset, length) } // Common case. if (typeof arg === 'number') { if (typeof encodingOrOffset === 'string') { throw new Error( 'If encoding is specified then the first argument must be a string' ) } return allocUnsafe(this, arg) } return from(this, arg, encodingOrOffset, length) } Buffer.poolSize = 8192 // not used by this implementation // TODO: Legacy, not needed anymore. Remove in next major version. Buffer._augment = function (arr) { arr.__proto__ = Buffer.prototype return arr } function from (that, value, encodingOrOffset, length) { if (typeof value === 'number') { throw new TypeError('"value" argument must not be a number') } if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) { return fromArrayBuffer(that, value, encodingOrOffset, length) } if (typeof value === 'string') { return fromString(that, value, encodingOrOffset) } return fromObject(that, value) } /** * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError * if value is a number. * Buffer.from(str[, encoding]) * Buffer.from(array) * Buffer.from(buffer) * Buffer.from(arrayBuffer[, byteOffset[, length]]) **/ Buffer.from = function (value, encodingOrOffset, length) { return from(null, value, encodingOrOffset, length) } if (Buffer.TYPED_ARRAY_SUPPORT) { Buffer.prototype.__proto__ = Uint8Array.prototype Buffer.__proto__ = Uint8Array if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) { // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97 Object.defineProperty(Buffer, Symbol.species, { value: null, configurable: true }) } } function assertSize (size) { if (typeof size !== 'number') { throw new TypeError('"size" argument must be a number') } else if (size < 0) { throw new RangeError('"size" argument must not be negative') } } function alloc (that, size, fill, encoding) { assertSize(size) if (size <= 0) { return createBuffer(that, size) } if (fill !== undefined) { // Only pay attention to encoding if it's a string. This // prevents accidentally sending in a number that would // be interpretted as a start offset. return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill) } return createBuffer(that, size) } /** * Creates a new filled Buffer instance. * alloc(size[, fill[, encoding]]) **/ Buffer.alloc = function (size, fill, encoding) { return alloc(null, size, fill, encoding) } function allocUnsafe (that, size) { assertSize(size) that = createBuffer(that, size < 0 ? 0 : checked(size) | 0) if (!Buffer.TYPED_ARRAY_SUPPORT) { for (var i = 0; i < size; ++i) { that[i] = 0 } } return that } /** * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance. * */ Buffer.allocUnsafe = function (size) { return allocUnsafe(null, size) } /** * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance. */ Buffer.allocUnsafeSlow = function (size) { return allocUnsafe(null, size) } function fromString (that, string, encoding) { if (typeof encoding !== 'string' || encoding === '') { encoding = 'utf8' } if (!Buffer.isEncoding(encoding)) { throw new TypeError('"encoding" must be a valid string encoding') } var length = byteLength(string, encoding) | 0 that = createBuffer(that, length) var actual = that.write(string, encoding) if (actual !== length) { // Writing a hex string, for example, that contains invalid characters will // cause everything after the first invalid character to be ignored. (e.g. // 'abxxcd' will be treated as 'ab') that = that.slice(0, actual) } return that } function fromArrayLike (that, array) { var length = array.length < 0 ? 0 : checked(array.length) | 0 that = createBuffer(that, length) for (var i = 0; i < length; i += 1) { that[i] = array[i] & 255 } return that } function fromArrayBuffer (that, array, byteOffset, length) { array.byteLength // this throws if `array` is not a valid ArrayBuffer if (byteOffset < 0 || array.byteLength < byteOffset) { throw new RangeError('\'offset\' is out of bounds') } if (array.byteLength < byteOffset + (length || 0)) { throw new RangeError('\'length\' is out of bounds') } if (byteOffset === undefined && length === undefined) { array = new Uint8Array(array) } else if (length === undefined) { array = new Uint8Array(array, byteOffset) } else { array = new Uint8Array(array, byteOffset, length) } if (Buffer.TYPED_ARRAY_SUPPORT) { // Return an augmented `Uint8Array` instance, for best performance that = array that.__proto__ = Buffer.prototype } else { // Fallback: Return an object instance of the Buffer class that = fromArrayLike(that, array) } return that } function fromObject (that, obj) { if (Buffer.isBuffer(obj)) { var len = checked(obj.length) | 0 that = createBuffer(that, len) if (that.length === 0) { return that } obj.copy(that, 0, 0, len) return that } if (obj) { if ((typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer) || 'length' in obj) { if (typeof obj.length !== 'number' || isnan(obj.length)) { return createBuffer(that, 0) } return fromArrayLike(that, obj) } if (obj.type === 'Buffer' && isArray(obj.data)) { return fromArrayLike(that, obj.data) } } throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.') } function checked (length) { // Note: cannot use `length < kMaxLength()` here because that fails when // length is NaN (which is otherwise coerced to zero.) if (length >= kMaxLength()) { throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes') } return length | 0 } function SlowBuffer (length) { if (+length != length) { // eslint-disable-line eqeqeq length = 0 } return Buffer.alloc(+length) } Buffer.isBuffer = function isBuffer (b) { return !!(b != null && b._isBuffer) } Buffer.compare = function compare (a, b) { if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) { throw new TypeError('Arguments must be Buffers') } if (a === b) return 0 var x = a.length var y = b.length for (var i = 0, len = Math.min(x, y); i < len; ++i) { if (a[i] !== b[i]) { x = a[i] y = b[i] break } } if (x < y) return -1 if (y < x) return 1 return 0 } Buffer.isEncoding = function isEncoding (encoding) { switch (String(encoding).toLowerCase()) { case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'latin1': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return true default: return false } } Buffer.concat = function concat (list, length) { if (!isArray(list)) { throw new TypeError('"list" argument must be an Array of Buffers') } if (list.length === 0) { return Buffer.alloc(0) } var i if (length === undefined) { length = 0 for (i = 0; i < list.length; ++i) { length += list[i].length } } var buffer = Buffer.allocUnsafe(length) var pos = 0 for (i = 0; i < list.length; ++i) { var buf = list[i] if (!Buffer.isBuffer(buf)) { throw new TypeError('"list" argument must be an Array of Buffers') } buf.copy(buffer, pos) pos += buf.length } return buffer } function byteLength (string, encoding) { if (Buffer.isBuffer(string)) { return string.length } if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) { return string.byteLength } if (typeof string !== 'string') { string = '' + string } var len = string.length if (len === 0) return 0 // Use a for loop to avoid recursion var loweredCase = false for (;;) { switch (encoding) { case 'ascii': case 'latin1': case 'binary': return len case 'utf8': case 'utf-8': case undefined: return utf8ToBytes(string).length case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return len * 2 case 'hex': return len >>> 1 case 'base64': return base64ToBytes(string).length default: if (loweredCase) return utf8ToBytes(string).length // assume utf8 encoding = ('' + encoding).toLowerCase() loweredCase = true } } } Buffer.byteLength = byteLength function slowToString (encoding, start, end) { var loweredCase = false // No need to verify that "this.length <= MAX_UINT32" since it's a read-only // property of a typed array. // This behaves neither like String nor Uint8Array in that we set start/end // to their upper/lower bounds if the value passed is out of range. // undefined is handled specially as per ECMA-262 6th Edition, // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization. if (start === undefined || start < 0) { start = 0 } // Return early if start > this.length. Done here to prevent potential uint32 // coercion fail below. if (start > this.length) { return '' } if (end === undefined || end > this.length) { end = this.length } if (end <= 0) { return '' } // Force coersion to uint32. This will also coerce falsey/NaN values to 0. end >>>= 0 start >>>= 0 if (end <= start) { return '' } if (!encoding) encoding = 'utf8' while (true) { switch (encoding) { case 'hex': return hexSlice(this, start, end) case 'utf8': case 'utf-8': return utf8Slice(this, start, end) case 'ascii': return asciiSlice(this, start, end) case 'latin1': case 'binary': return latin1Slice(this, start, end) case 'base64': return base64Slice(this, start, end) case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return utf16leSlice(this, start, end) default: if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding) encoding = (encoding + '').toLowerCase() loweredCase = true } } } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect // Buffer instances. Buffer.prototype._isBuffer = true function swap (b, n, m) { var i = b[n] b[n] = b[m] b[m] = i } Buffer.prototype.swap16 = function swap16 () { var len = this.length if (len % 2 !== 0) { throw new RangeError('Buffer size must be a multiple of 16-bits') } for (var i = 0; i < len; i += 2) { swap(this, i, i + 1) } return this } Buffer.prototype.swap32 = function swap32 () { var len = this.length if (len % 4 !== 0) { throw new RangeError('Buffer size must be a multiple of 32-bits') } for (var i = 0; i < len; i += 4) { swap(this, i, i + 3) swap(this, i + 1, i + 2) } return this } Buffer.prototype.swap64 = function swap64 () { var len = this.length if (len % 8 !== 0) { throw new RangeError('Buffer size must be a multiple of 64-bits') } for (var i = 0; i < len; i += 8) { swap(this, i, i + 7) swap(this, i + 1, i + 6) swap(this, i + 2, i + 5) swap(this, i + 3, i + 4) } return this } Buffer.prototype.toString = function toString () { var length = this.length | 0 if (length === 0) return '' if (arguments.length === 0) return utf8Slice(this, 0, length) return slowToString.apply(this, arguments) } Buffer.prototype.equals = function equals (b) { if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer') if (this === b) return true return Buffer.compare(this, b) === 0 } Buffer.prototype.inspect = function inspect () { var str = '' var max = exports.INSPECT_MAX_BYTES if (this.length > 0) { str = this.toString('hex', 0, max).match(/.{2}/g).join(' ') if (this.length > max) str += ' ... ' } return '<Buffer ' + str + '>' } Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) { if (!Buffer.isBuffer(target)) { throw new TypeError('Argument must be a Buffer') } if (start === undefined) { start = 0 } if (end === undefined) { end = target ? target.length : 0 } if (thisStart === undefined) { thisStart = 0 } if (thisEnd === undefined) { thisEnd = this.length } if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) { throw new RangeError('out of range index') } if (thisStart >= thisEnd && start >= end) { return 0 } if (thisStart >= thisEnd) { return -1 } if (start >= end) { return 1 } start >>>= 0 end >>>= 0 thisStart >>>= 0 thisEnd >>>= 0 if (this === target) return 0 var x = thisEnd - thisStart var y = end - start var len = Math.min(x, y) var thisCopy = this.slice(thisStart, thisEnd) var targetCopy = target.slice(start, end) for (var i = 0; i < len; ++i) { if (thisCopy[i] !== targetCopy[i]) { x = thisCopy[i] y = targetCopy[i] break } } if (x < y) return -1 if (y < x) return 1 return 0 } // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`, // OR the last index of `val` in `buffer` at offset <= `byteOffset`. // // Arguments: // - buffer - a Buffer to search // - val - a string, Buffer, or number // - byteOffset - an index into `buffer`; will be clamped to an int32 // - encoding - an optional encoding, relevant is val is a string // - dir - true for indexOf, false for lastIndexOf function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) { // Empty buffer means no match if (buffer.length === 0) return -1 // Normalize byteOffset if (typeof byteOffset === 'string') { encoding = byteOffset byteOffset = 0 } else if (byteOffset > 0x7fffffff) { byteOffset = 0x7fffffff } else if (byteOffset < -0x80000000) { byteOffset = -0x80000000 } byteOffset = +byteOffset // Coerce to Number. if (isNaN(byteOffset)) { // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer byteOffset = dir ? 0 : (buffer.length - 1) } // Normalize byteOffset: negative offsets start from the end of the buffer if (byteOffset < 0) byteOffset = buffer.length + byteOffset if (byteOffset >= buffer.length) { if (dir) return -1 else byteOffset = buffer.length - 1 } else if (byteOffset < 0) { if (dir) byteOffset = 0 else return -1 } // Normalize val if (typeof val === 'string') { val = Buffer.from(val, encoding) } // Finally, search either indexOf (if dir is true) or lastIndexOf if (Buffer.isBuffer(val)) { // Special case: looking for empty string/buffer always fails if (val.length === 0) { return -1 } return arrayIndexOf(buffer, val, byteOffset, encoding, dir) } else if (typeof val === 'number') { val = val & 0xFF // Search for a byte value [0-255] if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') { if (dir) { return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) } else { return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) } } return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir) } throw new TypeError('val must be string, number or Buffer') } function arrayIndexOf (arr, val, byteOffset, encoding, dir) { var indexSize = 1 var arrLength = arr.length var valLength = val.length if (encoding !== undefined) { encoding = String(encoding).toLowerCase() if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') { if (arr.length < 2 || val.length < 2) { return -1 } indexSize = 2 arrLength /= 2 valLength /= 2 byteOffset /= 2 } } function read (buf, i) { if (indexSize === 1) { return buf[i] } else { return buf.readUInt16BE(i * indexSize) } } var i if (dir) { var foundIndex = -1 for (i = byteOffset; i < arrLength; i++) { if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) { if (foundIndex === -1) foundIndex = i if (i - foundIndex + 1 === valLength) return foundIndex * indexSize } else { if (foundIndex !== -1) i -= i - foundIndex foundIndex = -1 } } } else { if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength for (i = byteOffset; i >= 0; i--) { var found = true for (var j = 0; j < valLength; j++) { if (read(arr, i + j) !== read(val, j)) { found = false break } } if (found) return i } } return -1 } Buffer.prototype.includes = function includes (val, byteOffset, encoding) { return this.indexOf(val, byteOffset, encoding) !== -1 } Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, true) } Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, false) } function hexWrite (buf, string, offset, length) { offset = Number(offset) || 0 var remaining = buf.length - offset if (!length) { length = remaining } else { length = Number(length) if (length > remaining) { length = remaining } } // must be an even number of digits var strLen = string.length if (strLen % 2 !== 0) throw new TypeError('Invalid hex string') if (length > strLen / 2) { length = strLen / 2 } for (var i = 0; i < length; ++i) { var parsed = parseInt(string.substr(i * 2, 2), 16) if (isNaN(parsed)) return i buf[offset + i] = parsed } return i } function utf8Write (buf, string, offset, length) { return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length) } function asciiWrite (buf, string, offset, length) { return blitBuffer(asciiToBytes(string), buf, offset, length) } function latin1Write (buf, string, offset, length) { return asciiWrite(buf, string, offset, length) } function base64Write (buf, string, offset, length) { return blitBuffer(base64ToBytes(string), buf, offset, length) } function ucs2Write (buf, string, offset, length) { return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length) } Buffer.prototype.write = function write (string, offset, length, encoding) { // Buffer#write(string) if (offset === undefined) { encoding = 'utf8' length = this.length offset = 0 // Buffer#write(string, encoding) } else if (length === undefined && typeof offset === 'string') { encoding = offset length = this.length offset = 0 // Buffer#write(string, offset[, length][, encoding]) } else if (isFinite(offset)) { offset = offset | 0 if (isFinite(length)) { length = length | 0 if (encoding === undefined) encoding = 'utf8' } else { encoding = length length = undefined } // legacy write(string, encoding, offset, length) - remove in v0.13 } else { throw new Error( 'Buffer.write(string, encoding, offset[, length]) is no longer supported' ) } var remaining = this.length - offset if (length === undefined || length > remaining) length = remaining if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) { throw new RangeError('Attempt to write outside buffer bounds') } if (!encoding) encoding = 'utf8' var loweredCase = false for (;;) { switch (encoding) { case 'hex': return hexWrite(this, string, offset, length) case 'utf8': case 'utf-8': return utf8Write(this, string, offset, length) case 'ascii': return asciiWrite(this, string, offset, length) case 'latin1': case 'binary': return latin1Write(this, string, offset, length) case 'base64': // Warning: maxLength not taken into account in base64Write return base64Write(this, string, offset, length) case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return ucs2Write(this, string, offset, length) default: if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding) encoding = ('' + encoding).toLowerCase() loweredCase = true } } } Buffer.prototype.toJSON = function toJSON () { return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) } } function base64Slice (buf, start, end) { if (start === 0 && end === buf.length) { return base64.fromByteArray(buf) } else { return base64.fromByteArray(buf.slice(start, end)) } } function utf8Slice (buf, start, end) { end = Math.min(buf.length, end) var res = [] var i = start while (i < end) { var firstByte = buf[i] var codePoint = null var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1 if (i + bytesPerSequence <= end) { var secondByte, thirdByte, fourthByte, tempCodePoint switch (bytesPerSequence) { case 1: if (firstByte < 0x80) { codePoint = firstByte } break case 2: secondByte = buf[i + 1] if ((secondByte & 0xC0) === 0x80) { tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F) if (tempCodePoint > 0x7F) { codePoint = tempCodePoint } } break case 3: secondByte = buf[i + 1] thirdByte = buf[i + 2] if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) { tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F) if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) { codePoint = tempCodePoint } } break case 4: secondByte = buf[i + 1] thirdByte = buf[i + 2] fourthByte = buf[i + 3] if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) { tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F) if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) { codePoint = tempCodePoint } } } } if (codePoint === null) { // we did not generate a valid codePoint so insert a // replacement char (U+FFFD) and advance only 1 byte codePoint = 0xFFFD bytesPerSequence = 1 } else if (codePoint > 0xFFFF) { // encode to utf16 (surrogate pair dance) codePoint -= 0x10000 res.push(codePoint >>> 10 & 0x3FF | 0xD800) codePoint = 0xDC00 | codePoint & 0x3FF } res.push(codePoint) i += bytesPerSequence } return decodeCodePointsArray(res) } // Based on http://stackoverflow.com/a/22747272/680742, the browser with // the lowest limit is Chrome, with 0x10000 args. // We go 1 magnitude less, for safety var MAX_ARGUMENTS_LENGTH = 0x1000 function decodeCodePointsArray (codePoints) { var len = codePoints.length if (len <= MAX_ARGUMENTS_LENGTH) { return String.fromCharCode.apply(String, codePoints) // avoid extra slice() } // Decode in chunks to avoid "call stack size exceeded". var res = '' var i = 0 while (i < len) { res += String.fromCharCode.apply( String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH) ) } return res } function asciiSlice (buf, start, end) { var ret = '' end = Math.min(buf.length, end) for (var i = start; i < end; ++i) { ret += String.fromCharCode(buf[i] & 0x7F) } return ret } function latin1Slice (buf, start, end) { var ret = '' end = Math.min(buf.length, end) for (var i = start; i < end; ++i) { ret += String.fromCharCode(buf[i]) } return ret } function hexSlice (buf, start, end) { var len = buf.length if (!start || start < 0) start = 0 if (!end || end < 0 || end > len) end = len var out = '' for (var i = start; i < end; ++i) { out += toHex(buf[i]) } return out } function utf16leSlice (buf, start, end) { var bytes = buf.slice(start, end) var res = '' for (var i = 0; i < bytes.length; i += 2) { res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256) } return res } Buffer.prototype.slice = function slice (start, end) { var len = this.length start = ~~start end = end === undefined ? len : ~~end if (start < 0) { start += len if (start < 0) start = 0 } else if (start > len) { start = len } if (end < 0) { end += len if (end < 0) end = 0 } else if (end > len) { end = len } if (end < start) end = start var newBuf if (Buffer.TYPED_ARRAY_SUPPORT) { newBuf = this.subarray(start, end) newBuf.__proto__ = Buffer.prototype } else { var sliceLen = end - start newBuf = new Buffer(sliceLen, undefined) for (var i = 0; i < sliceLen; ++i) { newBuf[i] = this[i + start] } } return newBuf } /* * Need to make sure that buffer isn't trying to write out of bounds. */ function checkOffset (offset, ext, length) { if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint') if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length') } Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) checkOffset(offset, byteLength, this.length) var val = this[offset] var mul = 1 var i = 0 while (++i < byteLength && (mul *= 0x100)) { val += this[offset + i] * mul } return val } Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) { checkOffset(offset, byteLength, this.length) } var val = this[offset + --byteLength] var mul = 1 while (byteLength > 0 && (mul *= 0x100)) { val += this[offset + --byteLength] * mul } return val } Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) { if (!noAssert) checkOffset(offset, 1, this.length) return this[offset] } Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) return this[offset] | (this[offset + 1] << 8) } Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) return (this[offset] << 8) | this[offset + 1] } Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000) } Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]) } Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) checkOffset(offset, byteLength, this.length) var val = this[offset] var mul = 1 var i = 0 while (++i < byteLength && (mul *= 0x100)) { val += this[offset + i] * mul } mul *= 0x80 if (val >= mul) val -= Math.pow(2, 8 * byteLength) return val } Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) { offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) checkOffset(offset, byteLength, this.length) var i = byteLength var mul = 1 var val = this[offset + --i] while (i > 0 && (mul *= 0x100)) { val += this[offset + --i] * mul } mul *= 0x80 if (val >= mul) val -= Math.pow(2, 8 * byteLength) return val } Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) { if (!noAssert) checkOffset(offset, 1, this.length) if (!(this[offset] & 0x80)) return (this[offset]) return ((0xff - this[offset] + 1) * -1) } Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) var val = this[offset] | (this[offset + 1] << 8) return (val & 0x8000) ? val | 0xFFFF0000 : val } Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length) var val = this[offset + 1] | (this[offset] << 8) return (val & 0x8000) ? val | 0xFFFF0000 : val } Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24) } Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]) } Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return ieee754.read(this, offset, true, 23, 4) } Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length) return ieee754.read(this, offset, false, 23, 4) } Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) { if (!noAssert) checkOffset(offset, 8, this.length) return ieee754.read(this, offset, true, 52, 8) } Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) { if (!noAssert) checkOffset(offset, 8, this.length) return ieee754.read(this, offset, false, 52, 8) } function checkInt (buf, value, offset, ext, max, min) { if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance') if (value > max || value < min) throw new RangeError('"value" argument is out of bounds') if (offset + ext > buf.length) throw new RangeError('Index out of range') } Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) { var maxBytes = Math.pow(2, 8 * byteLength) - 1 checkInt(this, value, offset, byteLength, maxBytes, 0) } var mul = 1 var i = 0 this[offset] = value & 0xFF while (++i < byteLength && (mul *= 0x100)) { this[offset + i] = (value / mul) & 0xFF } return offset + byteLength } Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 byteLength = byteLength | 0 if (!noAssert) { var maxBytes = Math.pow(2, 8 * byteLength) - 1 checkInt(this, value, offset, byteLength, maxBytes, 0) } var i = byteLength - 1 var mul = 1 this[offset + i] = value & 0xFF while (--i >= 0 && (mul *= 0x100)) { this[offset + i] = (value / mul) & 0xFF } return offset + byteLength } Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0) if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value) this[offset] = (value & 0xff) return offset + 1 } function objectWriteUInt16 (buf, value, offset, littleEndian) { if (value < 0) value = 0xffff + value + 1 for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) { buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8 } } Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value & 0xff) this[offset + 1] = (value >>> 8) } else { objectWriteUInt16(this, value, offset, true) } return offset + 2 } Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 8) this[offset + 1] = (value & 0xff) } else { objectWriteUInt16(this, value, offset, false) } return offset + 2 } function objectWriteUInt32 (buf, value, offset, littleEndian) { if (value < 0) value = 0xffffffff + value + 1 for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) { buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff } } Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset + 3] = (value >>> 24) this[offset + 2] = (value >>> 16) this[offset + 1] = (value >>> 8) this[offset] = (value & 0xff) } else { objectWriteUInt32(this, value, offset, true) } return offset + 4 } Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 24) this[offset + 1] = (value >>> 16) this[offset + 2] = (value >>> 8) this[offset + 3] = (value & 0xff) } else { objectWriteUInt32(this, value, offset, false) } return offset + 4 } Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 if (!noAssert) { var limit = Math.pow(2, 8 * byteLength - 1) checkInt(this, value, offset, byteLength, limit - 1, -limit) } var i = 0 var mul = 1 var sub = 0 this[offset] = value & 0xFF while (++i < byteLength && (mul *= 0x100)) { if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) { sub = 1 } this[offset + i] = ((value / mul) >> 0) - sub & 0xFF } return offset + byteLength } Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) { value = +value offset = offset | 0 if (!noAssert) { var limit = Math.pow(2, 8 * byteLength - 1) checkInt(this, value, offset, byteLength, limit - 1, -limit) } var i = byteLength - 1 var mul = 1 var sub = 0 this[offset + i] = value & 0xFF while (--i >= 0 && (mul *= 0x100)) { if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) { sub = 1 } this[offset + i] = ((value / mul) >> 0) - sub & 0xFF } return offset + byteLength } Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80) if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value) if (value < 0) value = 0xff + value + 1 this[offset] = (value & 0xff) return offset + 1 } Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value & 0xff) this[offset + 1] = (value >>> 8) } else { objectWriteUInt16(this, value, offset, true) } return offset + 2 } Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 8) this[offset + 1] = (value & 0xff) } else { objectWriteUInt16(this, value, offset, false) } return offset + 2 } Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000) if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value & 0xff) this[offset + 1] = (value >>> 8) this[offset + 2] = (value >>> 16) this[offset + 3] = (value >>> 24) } else { objectWriteUInt32(this, value, offset, true) } return offset + 4 } Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) { value = +value offset = offset | 0 if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000) if (value < 0) value = 0xffffffff + value + 1 if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = (value >>> 24) this[offset + 1] = (value >>> 16) this[offset + 2] = (value >>> 8) this[offset + 3] = (value & 0xff) } else { objectWriteUInt32(this, value, offset, false) } return offset + 4 } function checkIEEE754 (buf, value, offset, ext, max, min) { if (offset + ext > buf.length) throw new RangeError('Index out of range') if (offset < 0) throw new RangeError('Index out of range') } function writeFloat (buf, value, offset, littleEndian, noAssert) { if (!noAssert) { checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38) } ieee754.write(buf, value, offset, littleEndian, 23, 4) return offset + 4 } Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) { return writeFloat(this, value, offset, true, noAssert) } Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) { return writeFloat(this, value, offset, false, noAssert) } function writeDouble (buf, value, offset, littleEndian, noAssert) { if (!noAssert) { checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308) } ieee754.write(buf, value, offset, littleEndian, 52, 8) return offset + 8 } Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) { return writeDouble(this, value, offset, true, noAssert) } Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) { return writeDouble(this, value, offset, false, noAssert) } // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length) Buffer.prototype.copy = function copy (target, targetStart, start, end) { if (!start) start = 0 if (!end && end !== 0) end = this.length if (targetStart >= target.length) targetStart = target.length if (!targetStart) targetStart = 0 if (end > 0 && end < start) end = start // Copy 0 bytes; we're done if (end === start) return 0 if (target.length === 0 || this.length === 0) return 0 // Fatal error conditions if (targetStart < 0) { throw new RangeError('targetStart out of bounds') } if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds') if (end < 0) throw new RangeError('sourceEnd out of bounds') // Are we oob? if (end > this.length) end = this.length if (target.length - targetStart < end - start) { end = target.length - targetStart + start } var len = end - start var i if (this === target && start < targetStart && targetStart < end) { // descending copy from end for (i = len - 1; i >= 0; --i) { target[i + targetStart] = this[i + start] } } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) { // ascending copy from start for (i = 0; i < len; ++i) { target[i + targetStart] = this[i + start] } } else { Uint8Array.prototype.set.call( target, this.subarray(start, start + len), targetStart ) } return len } // Usage: // buffer.fill(number[, offset[, end]]) // buffer.fill(buffer[, offset[, end]]) // buffer.fill(string[, offset[, end]][, encoding]) Buffer.prototype.fill = function fill (val, start, end, encoding) { // Handle string cases: if (typeof val === 'string') { if (typeof start === 'string') { encoding = start start = 0 end = this.length } else if (typeof end === 'string') { encoding = end end = this.length } if (val.length === 1) { var code = val.charCodeAt(0) if (code < 256) { val = code } } if (encoding !== undefined && typeof encoding !== 'string') { throw new TypeError('encoding must be a string') } if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) { throw new TypeError('Unknown encoding: ' + encoding) } } else if (typeof val === 'number') { val = val & 255 } // Invalid ranges are not set to a default, so can range check early. if (start < 0 || this.length < start || this.length < end) { throw new RangeError('Out of range index') } if (end <= start) { return this } start = start >>> 0 end = end === undefined ? this.length : end >>> 0 if (!val) val = 0 var i if (typeof val === 'number') { for (i = start; i < end; ++i) { this[i] = val } } else { var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString()) var len = bytes.length for (i = 0; i < end - start; ++i) { this[i + start] = bytes[i % len] } } return this } // HELPER FUNCTIONS // ================ var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g function base64clean (str) { // Node strips out invalid characters like \n and \t from the string, base64-js does not str = stringtrim(str).replace(INVALID_BASE64_RE, '') // Node converts strings with length < 2 to '' if (str.length < 2) return '' // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not while (str.length % 4 !== 0) { str = str + '=' } return str } function stringtrim (str) { if (str.trim) return str.trim() return str.replace(/^\s+|\s+$/g, '') } function toHex (n) { if (n < 16) return '0' + n.toString(16) return n.toString(16) } function utf8ToBytes (string, units) { units = units || Infinity var codePoint var length = string.length var leadSurrogate = null var bytes = [] for (var i = 0; i < length; ++i) { codePoint = string.charCodeAt(i) // is surrogate component if (codePoint > 0xD7FF && codePoint < 0xE000) { // last char was a lead if (!leadSurrogate) { // no lead yet if (codePoint > 0xDBFF) { // unexpected trail if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) continue } else if (i + 1 === length) { // unpaired lead if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) continue } // valid lead leadSurrogate = codePoint continue } // 2 leads in a row if (codePoint < 0xDC00) { if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) leadSurrogate = codePoint continue } // valid surrogate pair codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000 } else if (leadSurrogate) { // valid bmp char, but last char was a lead if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD) } leadSurrogate = null // encode utf8 if (codePoint < 0x80) { if ((units -= 1) < 0) break bytes.push(codePoint) } else if (codePoint < 0x800) { if ((units -= 2) < 0) break bytes.push( codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80 ) } else if (codePoint < 0x10000) { if ((units -= 3) < 0) break bytes.push( codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80 ) } else if (codePoint < 0x110000) { if ((units -= 4) < 0) break bytes.push( codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80 ) } else { throw new Error('Invalid code point') } } return bytes } function asciiToBytes (str) { var byteArray = [] for (var i = 0; i < str.length; ++i) { // Node's code seems to be doing this and not & 0x7F.. byteArray.push(str.charCodeAt(i) & 0xFF) } return byteArray } function utf16leToBytes (str, units) { var c, hi, lo var byteArray = [] for (var i = 0; i < str.length; ++i) { if ((units -= 2) < 0) break c = str.charCodeAt(i) hi = c >> 8 lo = c % 256 byteArray.push(lo) byteArray.push(hi) } return byteArray } function base64ToBytes (str) { return base64.toByteArray(base64clean(str)) } function blitBuffer (src, dst, offset, length) { for (var i = 0; i < length; ++i) { if ((i + offset >= dst.length) || (i >= src.length)) break dst[i + offset] = src[i] } return i } function isnan (val) { return val !== val // eslint-disable-line no-self-compare } }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer) },{"base64-js":35,"buffer":75,"ieee754":201,"isarray":205}],76:[function(require,module,exports){ module.exports = { "100": "Continue", "101": "Switching Protocols", "102": "Processing", "200": "OK", "201": "Created", "202": "Accepted", "203": "Non-Authoritative Information", "204": "No Content", "205": "Reset Content", "206": "Partial Content", "207": "Multi-Status", "208": "Already Reported", "226": "IM Used", "300": "Multiple Choices", "301": "Moved Permanently", "302": "Found", "303": "See Other", "304": "Not Modified", "305": "Use Proxy", "307": "Temporary Redirect", "308": "Permanent Redirect", "400": "Bad Request", "401": "Unauthorized", "402": "Payment Required", "403": "Forbidden", "404": "Not Found", "405": "Method Not Allowed", "406": "Not Acceptable", "407": "Proxy Authentication Required", "408": "Request Timeout", "409": "Conflict", "410": "Gone", "411": "Length Required", "412": "Precondition Failed", "413": "Payload Too Large", "414": "URI Too Long", "415": "Unsupported Media Type", "416": "Range Not Satisfiable", "417": "Expectation Failed", "418": "I'm a teapot", "421": "Misdirected Request", "422": "Unprocessable Entity", "423": "Locked", "424": "Failed Dependency", "425": "Unordered Collection", "426": "Upgrade Required", "428": "Precondition Required", "429": "Too Many Requests", "431": "Request Header Fields Too Large", "451": "Unavailable For Legal Reasons", "500": "Internal Server Error", "501": "Not Implemented", "502": "Bad Gateway", "503": "Service Unavailable", "504": "Gateway Timeout", "505": "HTTP Version Not Supported", "506": "Variant Also Negotiates", "507": "Insufficient Storage", "508": "Loop Detected", "509": "Bandwidth Limit Exceeded", "510": "Not Extended", "511": "Network Authentication Required" } },{}],77:[function(require,module,exports){ /* Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io> Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ /** * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io> * Backing buffer: ArrayBuffer, Accessor: Uint8Array * Released under the Apache License, Version 2.0 * see: https://github.com/dcodeIO/bytebuffer.js for details */ (function(global, factory) { /* AMD */ if (typeof define === 'function' && define["amd"]) define(["long"], factory); /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"]) module['exports'] = (function() { var Long; try { Long = require("long"); } catch (e) {} return factory(Long); })(); /* Global */ else (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]); })(this, function(Long) { "use strict"; /** * Constructs a new ByteBuffer. * @class The swiss army knife for binary data in JavaScript. * @exports ByteBuffer * @constructor * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}. * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to * {@link ByteBuffer.DEFAULT_ENDIAN}. * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to * {@link ByteBuffer.DEFAULT_NOASSERT}. * @expose */ var ByteBuffer = function(capacity, littleEndian, noAssert) { if (typeof capacity === 'undefined') capacity = ByteBuffer.DEFAULT_CAPACITY; if (typeof littleEndian === 'undefined') littleEndian = ByteBuffer.DEFAULT_ENDIAN; if (typeof noAssert === 'undefined') noAssert = ByteBuffer.DEFAULT_NOASSERT; if (!noAssert) { capacity = capacity | 0; if (capacity < 0) throw RangeError("Illegal capacity"); littleEndian = !!littleEndian; noAssert = !!noAssert; } /** * Backing ArrayBuffer. * @type {!ArrayBuffer} * @expose */ this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity); /** * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`. * @type {?Uint8Array} * @expose */ this.view = capacity === 0 ? null : new Uint8Array(this.buffer); /** * Absolute read/write offset. * @type {number} * @expose * @see ByteBuffer#flip * @see ByteBuffer#clear */ this.offset = 0; /** * Marked offset. * @type {number} * @expose * @see ByteBuffer#mark * @see ByteBuffer#reset */ this.markedOffset = -1; /** * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation. * @type {number} * @expose * @see ByteBuffer#flip * @see ByteBuffer#clear */ this.limit = capacity; /** * Whether to use little endian byte order, defaults to `false` for big endian. * @type {boolean} * @expose */ this.littleEndian = littleEndian; /** * Whether to skip assertions of offsets and values, defaults to `false`. * @type {boolean} * @expose */ this.noAssert = noAssert; }; /** * ByteBuffer version. * @type {string} * @const * @expose */ ByteBuffer.VERSION = "5.0.1"; /** * Little endian constant that can be used instead of its boolean value. Evaluates to `true`. * @type {boolean} * @const * @expose */ ByteBuffer.LITTLE_ENDIAN = true; /** * Big endian constant that can be used instead of its boolean value. Evaluates to `false`. * @type {boolean} * @const * @expose */ ByteBuffer.BIG_ENDIAN = false; /** * Default initial capacity of `16`. * @type {number} * @expose */ ByteBuffer.DEFAULT_CAPACITY = 16; /** * Default endianess of `false` for big endian. * @type {boolean} * @expose */ ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN; /** * Default no assertions flag of `false`. * @type {boolean} * @expose */ ByteBuffer.DEFAULT_NOASSERT = false; /** * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded * and int64 support is not available. * @type {?Long} * @const * @see https://github.com/dcodeIO/long.js * @expose */ ByteBuffer.Long = Long || null; /** * @alias ByteBuffer.prototype * @inner */ var ByteBufferPrototype = ByteBuffer.prototype; /** * An indicator used to reliably determine if an object is a ByteBuffer or not. * @type {boolean} * @const * @expose * @private */ ByteBufferPrototype.__isByteBuffer__; Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", { value: true, enumerable: false, configurable: false }); // helpers /** * @type {!ArrayBuffer} * @inner */ var EMPTY_BUFFER = new ArrayBuffer(0); /** * String.fromCharCode reference for compile-time renaming. * @type {function(...number):string} * @inner */ var stringFromCharCode = String.fromCharCode; /** * Creates a source function for a string. * @param {string} s String to read from * @returns {function():number|null} Source function returning the next char code respectively `null` if there are * no more characters left. * @throws {TypeError} If the argument is invalid * @inner */ function stringSource(s) { var i=0; return function() { return i < s.length ? s.charCodeAt(i++) : null; }; } /** * Creates a destination function for a string. * @returns {function(number=):undefined|string} Destination function successively called with the next char code. * Returns the final string when called without arguments. * @inner */ function stringDestination() { var cs = [], ps = []; return function() { if (arguments.length === 0) return ps.join('')+stringFromCharCode.apply(String, cs); if (cs.length + arguments.length > 1024) ps.push(stringFromCharCode.apply(String, cs)), cs.length = 0; Array.prototype.push.apply(cs, arguments); }; } /** * Gets the accessor type. * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes) * @expose */ ByteBuffer.accessor = function() { return Uint8Array; }; /** * Allocates a new ByteBuffer backed by a buffer of the specified capacity. * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}. * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to * {@link ByteBuffer.DEFAULT_ENDIAN}. * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to * {@link ByteBuffer.DEFAULT_NOASSERT}. * @returns {!ByteBuffer} * @expose */ ByteBuffer.allocate = function(capacity, littleEndian, noAssert) { return new ByteBuffer(capacity, littleEndian, noAssert); }; /** * Concatenates multiple ByteBuffers into one. * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary", * defaults to "utf8") * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults * to {@link ByteBuffer.DEFAULT_ENDIAN}. * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to * {@link ByteBuffer.DEFAULT_NOASSERT}. * @returns {!ByteBuffer} Concatenated ByteBuffer * @expose */ ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) { if (typeof encoding === 'boolean' || typeof encoding !== 'string') { noAssert = littleEndian; littleEndian = encoding; encoding = undefined; } var capacity = 0; for (var i=0, k=buffers.length, length; i<k; ++i) { if (!ByteBuffer.isByteBuffer(buffers[i])) buffers[i] = ByteBuffer.wrap(buffers[i], encoding); length = buffers[i].limit - buffers[i].offset; if (length > 0) capacity += length; } if (capacity === 0) return new ByteBuffer(0, littleEndian, noAssert); var bb = new ByteBuffer(capacity, littleEndian, noAssert), bi; i=0; while (i<k) { bi = buffers[i++]; length = bi.limit - bi.offset; if (length <= 0) continue; bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset); bb.offset += length; } bb.limit = bb.offset; bb.offset = 0; return bb; }; /** * Tests if the specified type is a ByteBuffer. * @param {*} bb ByteBuffer to test * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false` * @expose */ ByteBuffer.isByteBuffer = function(bb) { return (bb && bb["__isByteBuffer__"]) === true; }; /** * Gets the backing buffer type. * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes) * @expose */ ByteBuffer.type = function() { return ArrayBuffer; }; /** * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its * {@link ByteBuffer#limit} to the length of the wrapped data. * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to * "utf8") * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to * {@link ByteBuffer.DEFAULT_ENDIAN}. * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to * {@link ByteBuffer.DEFAULT_NOASSERT}. * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer` * @expose */ ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) { if (typeof encoding !== 'string') { noAssert = littleEndian; littleEndian = encoding; encoding = undefined; } if (typeof buffer === 'string') { if (typeof encoding === 'undefined') encoding = "utf8"; switch (encoding) { case "base64": return ByteBuffer.fromBase64(buffer, littleEndian); case "hex": return ByteBuffer.fromHex(buffer, littleEndian); case "binary": return ByteBuffer.fromBinary(buffer, littleEndian); case "utf8": return ByteBuffer.fromUTF8(buffer, littleEndian); case "debug": return ByteBuffer.fromDebug(buffer, littleEndian); default: throw Error("Unsupported encoding: "+encoding); } } if (buffer === null || typeof buffer !== 'object') throw TypeError("Illegal buffer"); var bb; if (ByteBuffer.isByteBuffer(buffer)) { bb = ByteBufferPrototype.clone.call(buffer); bb.markedOffset = -1; return bb; } if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array bb = new ByteBuffer(0, littleEndian, noAssert); if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER bb.buffer = buffer.buffer; bb.offset = buffer.byteOffset; bb.limit = buffer.byteOffset + buffer.byteLength; bb.view = new Uint8Array(buffer.buffer); } } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer bb = new ByteBuffer(0, littleEndian, noAssert); if (buffer.byteLength > 0) { bb.buffer = buffer; bb.offset = 0; bb.limit = buffer.byteLength; bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null; } } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets bb = new ByteBuffer(buffer.length, littleEndian, noAssert); bb.limit = buffer.length; for (var i=0; i<buffer.length; ++i) bb.view[i] = buffer[i]; } else throw TypeError("Illegal buffer"); // Otherwise fail return bb; }; /** * Writes the array as a bitset. * @param {Array<boolean>} value Array of booleans to write * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted. * @returns {!ByteBuffer} * @expose */ ByteBufferPrototype.writeBitSet = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (!(value instanceof Array)) throw TypeError("Illegal BitSet: Not an array"); if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } var start = offset, bits = value.length, bytes = (bits >> 3), bit = 0, k; offset += this.writeVarint32(bits,offset); while(bytes--) { k = (!!value[bit++] & 1) | ((!!value[bit++] & 1) << 1) | ((!!value[bit++] & 1) << 2) | ((!!value[bit++] & 1) << 3) | ((!!value[bit++] & 1) << 4) | ((!!value[bit++] & 1) << 5) | ((!!value[bit++] & 1) << 6) | ((!!value[bit++] & 1) << 7); this.writeByte(k,offset++); } if(bit < bits) { var m = 0; k = 0; while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++)); this.writeByte(k,offset++); } if (relative) { this.offset = offset; return this; } return offset - start; } /** * Reads a BitSet as an array of booleans. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted. * @returns {Array<boolean> * @expose */ ByteBufferPrototype.readBitSet = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; var ret = this.readVarint32(offset), bits = ret.value, bytes = (bits >> 3), bit = 0, value = [], k; offset += ret.length; while(bytes--) { k = this.readByte(offset++); value[bit++] = !!(k & 0x01); value[bit++] = !!(k & 0x02); value[bit++] = !!(k & 0x04); value[bit++] = !!(k & 0x08); value[bit++] = !!(k & 0x10); value[bit++] = !!(k & 0x20); value[bit++] = !!(k & 0x40); value[bit++] = !!(k & 0x80); } if(bit < bits) { var m = 0; k = this.readByte(offset++); while(bit < bits) value[bit++] = !!((k >> (m++)) & 1); } if (relative) { this.offset = offset; } return value; } /** * Reads the specified number of bytes. * @param {number} length Number of bytes to read * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted. * @returns {!ByteBuffer} * @expose */ ByteBufferPrototype.readBytes = function(length, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + length > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength); } var slice = this.slice(offset, offset + length); if (relative) this.offset += length; return slice; }; /** * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}. * @function * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets * will be modified according to the performed read operation. * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8") * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeBytes = ByteBufferPrototype.append; // types/ints/int8 /** * Writes an 8bit signed integer. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeInt8 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: "+value+" (not an integer)"); value |= 0; if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } offset += 1; var capacity0 = this.buffer.byteLength; if (offset > capacity0) this.resize((capacity0 *= 2) > offset ? capacity0 : offset); offset -= 1; this.view[offset] = value; if (relative) this.offset += 1; return this; }; /** * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}. * @function * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8; /** * Reads an 8bit signed integer. * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted. * @returns {number} Value read * @expose */ ByteBufferPrototype.readInt8 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength); } var value = this.view[offset]; if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed if (relative) this.offset += 1; return value; }; /** * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}. * @function * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted. * @returns {number} Value read * @expose */ ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8; /** * Writes an 8bit unsigned integer. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeUint8 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: "+value+" (not an integer)"); value >>>= 0; if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } offset += 1; var capacity1 = this.buffer.byteLength; if (offset > capacity1) this.resize((capacity1 *= 2) > offset ? capacity1 : offset); offset -= 1; this.view[offset] = value; if (relative) this.offset += 1; return this; }; /** * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}. * @function * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8; /** * Reads an 8bit unsigned integer. * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted. * @returns {number} Value read * @expose */ ByteBufferPrototype.readUint8 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength); } var value = this.view[offset]; if (relative) this.offset += 1; return value; }; /** * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}. * @function * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted. * @returns {number} Value read * @expose */ ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8; // types/ints/int16 /** * Writes a 16bit signed integer. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted. * @throws {TypeError} If `offset` or `value` is not a valid number * @throws {RangeError} If `offset` is out of bounds * @expose */ ByteBufferPrototype.writeInt16 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: "+value+" (not an integer)"); value |= 0; if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } offset += 2; var capacity2 = this.buffer.byteLength; if (offset > capacity2) this.resize((capacity2 *= 2) > offset ? capacity2 : offset); offset -= 2; if (this.littleEndian) { this.view[offset+1] = (value & 0xFF00) >>> 8; this.view[offset ] = value & 0x00FF; } else { this.view[offset] = (value & 0xFF00) >>> 8; this.view[offset+1] = value & 0x00FF; } if (relative) this.offset += 2; return this; }; /** * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}. * @function * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted. * @throws {TypeError} If `offset` or `value` is not a valid number * @throws {RangeError} If `offset` is out of bounds * @expose */ ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16; /** * Reads a 16bit signed integer. * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted. * @returns {number} Value read * @throws {TypeError} If `offset` is not a valid number * @throws {RangeError} If `offset` is out of bounds * @expose */ ByteBufferPrototype.readInt16 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength); } var value = 0; if (this.littleEndian) { value = this.view[offset ]; value |= this.view[offset+1] << 8; } else { value = this.view[offset ] << 8; value |= this.view[offset+1]; } if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed if (relative) this.offset += 2; return value; }; /** * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}. * @function * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted. * @returns {number} Value read * @throws {TypeError} If `offset` is not a valid number * @throws {RangeError} If `offset` is out of bounds * @expose */ ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16; /** * Writes a 16bit unsigned integer. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted. * @throws {TypeError} If `offset` or `value` is not a valid number * @throws {RangeError} If `offset` is out of bounds * @expose */ ByteBufferPrototype.writeUint16 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: "+value+" (not an integer)"); value >>>= 0; if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } offset += 2; var capacity3 = this.buffer.byteLength; if (offset > capacity3) this.resize((capacity3 *= 2) > offset ? capacity3 : offset); offset -= 2; if (this.littleEndian) { this.view[offset+1] = (value & 0xFF00) >>> 8; this.view[offset ] = value & 0x00FF; } else { this.view[offset] = (value & 0xFF00) >>> 8; this.view[offset+1] = value & 0x00FF; } if (relative) this.offset += 2; return this; }; /** * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}. * @function * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted. * @throws {TypeError} If `offset` or `value` is not a valid number * @throws {RangeError} If `offset` is out of bounds * @expose */ ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16; /** * Reads a 16bit unsigned integer. * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted. * @returns {number} Value read * @throws {TypeError} If `offset` is not a valid number * @throws {RangeError} If `offset` is out of bounds * @expose */ ByteBufferPrototype.readUint16 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength); } var value = 0; if (this.littleEndian) { value = this.view[offset ]; value |= this.view[offset+1] << 8; } else { value = this.view[offset ] << 8; value |= this.view[offset+1]; } if (relative) this.offset += 2; return value; }; /** * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}. * @function * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted. * @returns {number} Value read * @throws {TypeError} If `offset` is not a valid number * @throws {RangeError} If `offset` is out of bounds * @expose */ ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16; // types/ints/int32 /** * Writes a 32bit signed integer. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @expose */ ByteBufferPrototype.writeInt32 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: "+value+" (not an integer)"); value |= 0; if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } offset += 4; var capacity4 = this.buffer.byteLength; if (offset > capacity4) this.resize((capacity4 *= 2) > offset ? capacity4 : offset); offset -= 4; if (this.littleEndian) { this.view[offset+3] = (value >>> 24) & 0xFF; this.view[offset+2] = (value >>> 16) & 0xFF; this.view[offset+1] = (value >>> 8) & 0xFF; this.view[offset ] = value & 0xFF; } else { this.view[offset ] = (value >>> 24) & 0xFF; this.view[offset+1] = (value >>> 16) & 0xFF; this.view[offset+2] = (value >>> 8) & 0xFF; this.view[offset+3] = value & 0xFF; } if (relative) this.offset += 4; return this; }; /** * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @expose */ ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32; /** * Reads a 32bit signed integer. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @returns {number} Value read * @expose */ ByteBufferPrototype.readInt32 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength); } var value = 0; if (this.littleEndian) { value = this.view[offset+2] << 16; value |= this.view[offset+1] << 8; value |= this.view[offset ]; value += this.view[offset+3] << 24 >>> 0; } else { value = this.view[offset+1] << 16; value |= this.view[offset+2] << 8; value |= this.view[offset+3]; value += this.view[offset ] << 24 >>> 0; } value |= 0; // Cast to signed if (relative) this.offset += 4; return value; }; /** * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}. * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted. * @returns {number} Value read * @expose */ ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32; /** * Writes a 32bit unsigned integer. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @expose */ ByteBufferPrototype.writeUint32 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: "+value+" (not an integer)"); value >>>= 0; if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } offset += 4; var capacity5 = this.buffer.byteLength; if (offset > capacity5) this.resize((capacity5 *= 2) > offset ? capacity5 : offset); offset -= 4; if (this.littleEndian) { this.view[offset+3] = (value >>> 24) & 0xFF; this.view[offset+2] = (value >>> 16) & 0xFF; this.view[offset+1] = (value >>> 8) & 0xFF; this.view[offset ] = value & 0xFF; } else { this.view[offset ] = (value >>> 24) & 0xFF; this.view[offset+1] = (value >>> 16) & 0xFF; this.view[offset+2] = (value >>> 8) & 0xFF; this.view[offset+3] = value & 0xFF; } if (relative) this.offset += 4; return this; }; /** * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}. * @function * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @expose */ ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32; /** * Reads a 32bit unsigned integer. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @returns {number} Value read * @expose */ ByteBufferPrototype.readUint32 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength); } var value = 0; if (this.littleEndian) { value = this.view[offset+2] << 16; value |= this.view[offset+1] << 8; value |= this.view[offset ]; value += this.view[offset+3] << 24 >>> 0; } else { value = this.view[offset+1] << 16; value |= this.view[offset+2] << 8; value |= this.view[offset+3]; value += this.view[offset ] << 24 >>> 0; } if (relative) this.offset += 4; return value; }; /** * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}. * @function * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @returns {number} Value read * @expose */ ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32; // types/ints/int64 if (Long) { /** * Writes a 64bit signed integer. * @param {number|!Long} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeInt64 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value === 'number') value = Long.fromNumber(value); else if (typeof value === 'string') value = Long.fromString(value); else if (!(value && value instanceof Long)) throw TypeError("Illegal value: "+value+" (not an integer or Long)"); if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } if (typeof value === 'number') value = Long.fromNumber(value); else if (typeof value === 'string') value = Long.fromString(value); offset += 8; var capacity6 = this.buffer.byteLength; if (offset > capacity6) this.resize((capacity6 *= 2) > offset ? capacity6 : offset); offset -= 8; var lo = value.low, hi = value.high; if (this.littleEndian) { this.view[offset+3] = (lo >>> 24) & 0xFF; this.view[offset+2] = (lo >>> 16) & 0xFF; this.view[offset+1] = (lo >>> 8) & 0xFF; this.view[offset ] = lo & 0xFF; offset += 4; this.view[offset+3] = (hi >>> 24) & 0xFF; this.view[offset+2] = (hi >>> 16) & 0xFF; this.view[offset+1] = (hi >>> 8) & 0xFF; this.view[offset ] = hi & 0xFF; } else { this.view[offset ] = (hi >>> 24) & 0xFF; this.view[offset+1] = (hi >>> 16) & 0xFF; this.view[offset+2] = (hi >>> 8) & 0xFF; this.view[offset+3] = hi & 0xFF; offset += 4; this.view[offset ] = (lo >>> 24) & 0xFF; this.view[offset+1] = (lo >>> 16) & 0xFF; this.view[offset+2] = (lo >>> 8) & 0xFF; this.view[offset+3] = lo & 0xFF; } if (relative) this.offset += 8; return this; }; /** * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}. * @param {number|!Long} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64; /** * Reads a 64bit signed integer. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {!Long} * @expose */ ByteBufferPrototype.readInt64 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength); } var lo = 0, hi = 0; if (this.littleEndian) { lo = this.view[offset+2] << 16; lo |= this.view[offset+1] << 8; lo |= this.view[offset ]; lo += this.view[offset+3] << 24 >>> 0; offset += 4; hi = this.view[offset+2] << 16; hi |= this.view[offset+1] << 8; hi |= this.view[offset ]; hi += this.view[offset+3] << 24 >>> 0; } else { hi = this.view[offset+1] << 16; hi |= this.view[offset+2] << 8; hi |= this.view[offset+3]; hi += this.view[offset ] << 24 >>> 0; offset += 4; lo = this.view[offset+1] << 16; lo |= this.view[offset+2] << 8; lo |= this.view[offset+3]; lo += this.view[offset ] << 24 >>> 0; } var value = new Long(lo, hi, false); if (relative) this.offset += 8; return value; }; /** * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {!Long} * @expose */ ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64; /** * Writes a 64bit unsigned integer. * @param {number|!Long} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeUint64 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value === 'number') value = Long.fromNumber(value); else if (typeof value === 'string') value = Long.fromString(value); else if (!(value && value instanceof Long)) throw TypeError("Illegal value: "+value+" (not an integer or Long)"); if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } if (typeof value === 'number') value = Long.fromNumber(value); else if (typeof value === 'string') value = Long.fromString(value); offset += 8; var capacity7 = this.buffer.byteLength; if (offset > capacity7) this.resize((capacity7 *= 2) > offset ? capacity7 : offset); offset -= 8; var lo = value.low, hi = value.high; if (this.littleEndian) { this.view[offset+3] = (lo >>> 24) & 0xFF; this.view[offset+2] = (lo >>> 16) & 0xFF; this.view[offset+1] = (lo >>> 8) & 0xFF; this.view[offset ] = lo & 0xFF; offset += 4; this.view[offset+3] = (hi >>> 24) & 0xFF; this.view[offset+2] = (hi >>> 16) & 0xFF; this.view[offset+1] = (hi >>> 8) & 0xFF; this.view[offset ] = hi & 0xFF; } else { this.view[offset ] = (hi >>> 24) & 0xFF; this.view[offset+1] = (hi >>> 16) & 0xFF; this.view[offset+2] = (hi >>> 8) & 0xFF; this.view[offset+3] = hi & 0xFF; offset += 4; this.view[offset ] = (lo >>> 24) & 0xFF; this.view[offset+1] = (lo >>> 16) & 0xFF; this.view[offset+2] = (lo >>> 8) & 0xFF; this.view[offset+3] = lo & 0xFF; } if (relative) this.offset += 8; return this; }; /** * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}. * @function * @param {number|!Long} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64; /** * Reads a 64bit unsigned integer. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {!Long} * @expose */ ByteBufferPrototype.readUint64 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength); } var lo = 0, hi = 0; if (this.littleEndian) { lo = this.view[offset+2] << 16; lo |= this.view[offset+1] << 8; lo |= this.view[offset ]; lo += this.view[offset+3] << 24 >>> 0; offset += 4; hi = this.view[offset+2] << 16; hi |= this.view[offset+1] << 8; hi |= this.view[offset ]; hi += this.view[offset+3] << 24 >>> 0; } else { hi = this.view[offset+1] << 16; hi |= this.view[offset+2] << 8; hi |= this.view[offset+3]; hi += this.view[offset ] << 24 >>> 0; offset += 4; lo = this.view[offset+1] << 16; lo |= this.view[offset+2] << 8; lo |= this.view[offset+3]; lo += this.view[offset ] << 24 >>> 0; } var value = new Long(lo, hi, true); if (relative) this.offset += 8; return value; }; /** * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}. * @function * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {!Long} * @expose */ ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64; } // Long // types/floats/float32 /* ieee754 - https://github.com/feross/ieee754 The MIT License (MIT) Copyright (c) Feross Aboukhadijeh Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ /** * Reads an IEEE754 float from a byte array. * @param {!Array} buffer * @param {number} offset * @param {boolean} isLE * @param {number} mLen * @param {number} nBytes * @returns {number} * @inner */ function ieee754_read(buffer, offset, isLE, mLen, nBytes) { var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? (nBytes - 1) : 0, d = isLE ? -1 : 1, s = buffer[offset + i]; i += d; e = s & ((1 << (-nBits)) - 1); s >>= (-nBits); nBits += eLen; for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {} m = e & ((1 << (-nBits)) - 1); e >>= (-nBits); nBits += mLen; for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {} if (e === 0) { e = 1 - eBias; } else if (e === eMax) { return m ? NaN : ((s ? -1 : 1) * Infinity); } else { m = m + Math.pow(2, mLen); e = e - eBias; } return (s ? -1 : 1) * m * Math.pow(2, e - mLen); } /** * Writes an IEEE754 float to a byte array. * @param {!Array} buffer * @param {number} value * @param {number} offset * @param {boolean} isLE * @param {number} mLen * @param {number} nBytes * @inner */ function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) { var e, m, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0), i = isLE ? 0 : (nBytes - 1), d = isLE ? 1 : -1, s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0; value = Math.abs(value); if (isNaN(value) || value === Infinity) { m = isNaN(value) ? 1 : 0; e = eMax; } else { e = Math.floor(Math.log(value) / Math.LN2); if (value * (c = Math.pow(2, -e)) < 1) { e--; c *= 2; } if (e + eBias >= 1) { value += rt / c; } else { value += rt * Math.pow(2, 1 - eBias); } if (value * c >= 2) { e++; c /= 2; } if (e + eBias >= eMax) { m = 0; e = eMax; } else if (e + eBias >= 1) { m = (value * c - 1) * Math.pow(2, mLen); e = e + eBias; } else { m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen); e = 0; } } for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {} e = (e << mLen) | m; eLen += mLen; for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {} buffer[offset + i - d] |= s * 128; } /** * Writes a 32bit float. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeFloat32 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value !== 'number') throw TypeError("Illegal value: "+value+" (not a number)"); if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } offset += 4; var capacity8 = this.buffer.byteLength; if (offset > capacity8) this.resize((capacity8 *= 2) > offset ? capacity8 : offset); offset -= 4; ieee754_write(this.view, value, offset, this.littleEndian, 23, 4); if (relative) this.offset += 4; return this; }; /** * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}. * @function * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32; /** * Reads a 32bit float. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @returns {number} * @expose */ ByteBufferPrototype.readFloat32 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength); } var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4); if (relative) this.offset += 4; return value; }; /** * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}. * @function * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted. * @returns {number} * @expose */ ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32; // types/floats/float64 /** * Writes a 64bit float. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeFloat64 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value !== 'number') throw TypeError("Illegal value: "+value+" (not a number)"); if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } offset += 8; var capacity9 = this.buffer.byteLength; if (offset > capacity9) this.resize((capacity9 *= 2) > offset ? capacity9 : offset); offset -= 8; ieee754_write(this.view, value, offset, this.littleEndian, 52, 8); if (relative) this.offset += 8; return this; }; /** * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}. * @function * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64; /** * Reads a 64bit float. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {number} * @expose */ ByteBufferPrototype.readFloat64 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength); } var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8); if (relative) this.offset += 8; return value; }; /** * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}. * @function * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted. * @returns {number} * @expose */ ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64; // types/varints/varint32 /** * Maximum number of bytes required to store a 32bit base 128 variable-length integer. * @type {number} * @const * @expose */ ByteBuffer.MAX_VARINT32_BYTES = 5; /** * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer. * @param {number} value Value to encode * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES} * @expose */ ByteBuffer.calculateVarint32 = function(value) { // ref: src/google/protobuf/io/coded_stream.cc value = value >>> 0; if (value < 1 << 7 ) return 1; else if (value < 1 << 14) return 2; else if (value < 1 << 21) return 3; else if (value < 1 << 28) return 4; else return 5; }; /** * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding. * @param {number} n Signed 32bit integer * @returns {number} Unsigned zigzag encoded 32bit integer * @expose */ ByteBuffer.zigZagEncode32 = function(n) { return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h }; /** * Decodes a zigzag encoded signed 32bit integer. * @param {number} n Unsigned zigzag encoded 32bit integer * @returns {number} Signed 32bit integer * @expose */ ByteBuffer.zigZagDecode32 = function(n) { return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h }; /** * Writes a 32bit base 128 variable-length integer. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written * @expose */ ByteBufferPrototype.writeVarint32 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: "+value+" (not an integer)"); value |= 0; if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } var size = ByteBuffer.calculateVarint32(value), b; offset += size; var capacity10 = this.buffer.byteLength; if (offset > capacity10) this.resize((capacity10 *= 2) > offset ? capacity10 : offset); offset -= size; value >>>= 0; while (value >= 0x80) { b = (value & 0x7f) | 0x80; this.view[offset++] = b; value >>>= 7; } this.view[offset++] = value; if (relative) { this.offset = offset; return this; } return size; }; /** * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer. * @param {number} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written * @expose */ ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) { return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset); }; /** * Reads a 32bit base 128 variable-length integer. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read * and the actual number of bytes read. * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available * to fully decode the varint. * @expose */ ByteBufferPrototype.readVarint32 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength); } var c = 0, value = 0 >>> 0, b; do { if (!this.noAssert && offset > this.limit) { var err = Error("Truncated"); err['truncated'] = true; throw err; } b = this.view[offset++]; if (c < 5) value |= (b & 0x7f) << (7*c); ++c; } while ((b & 0x80) !== 0); value |= 0; if (relative) { this.offset = offset; return value; } return { "value": value, "length": c }; }; /** * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read * and the actual number of bytes read. * @throws {Error} If it's not a valid varint * @expose */ ByteBufferPrototype.readVarint32ZigZag = function(offset) { var val = this.readVarint32(offset); if (typeof val === 'object') val["value"] = ByteBuffer.zigZagDecode32(val["value"]); else val = ByteBuffer.zigZagDecode32(val); return val; }; // types/varints/varint64 if (Long) { /** * Maximum number of bytes required to store a 64bit base 128 variable-length integer. * @type {number} * @const * @expose */ ByteBuffer.MAX_VARINT64_BYTES = 10; /** * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer. * @param {number|!Long} value Value to encode * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES} * @expose */ ByteBuffer.calculateVarint64 = function(value) { if (typeof value === 'number') value = Long.fromNumber(value); else if (typeof value === 'string') value = Long.fromString(value); // ref: src/google/protobuf/io/coded_stream.cc var part0 = value.toInt() >>> 0, part1 = value.shiftRightUnsigned(28).toInt() >>> 0, part2 = value.shiftRightUnsigned(56).toInt() >>> 0; if (part2 == 0) { if (part1 == 0) { if (part0 < 1 << 14) return part0 < 1 << 7 ? 1 : 2; else return part0 < 1 << 21 ? 3 : 4; } else { if (part1 < 1 << 14) return part1 < 1 << 7 ? 5 : 6; else return part1 < 1 << 21 ? 7 : 8; } } else return part2 < 1 << 7 ? 9 : 10; }; /** * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding. * @param {number|!Long} value Signed long * @returns {!Long} Unsigned zigzag encoded long * @expose */ ByteBuffer.zigZagEncode64 = function(value) { if (typeof value === 'number') value = Long.fromNumber(value, false); else if (typeof value === 'string') value = Long.fromString(value, false); else if (value.unsigned !== false) value = value.toSigned(); // ref: src/google/protobuf/wire_format_lite.h return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned(); }; /** * Decodes a zigzag encoded signed 64bit integer. * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number * @returns {!Long} Signed long * @expose */ ByteBuffer.zigZagDecode64 = function(value) { if (typeof value === 'number') value = Long.fromNumber(value, false); else if (typeof value === 'string') value = Long.fromString(value, false); else if (value.unsigned !== false) value = value.toSigned(); // ref: src/google/protobuf/wire_format_lite.h return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned(); }; /** * Writes a 64bit base 128 variable-length integer. * @param {number|Long} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written. * @expose */ ByteBufferPrototype.writeVarint64 = function(value, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof value === 'number') value = Long.fromNumber(value); else if (typeof value === 'string') value = Long.fromString(value); else if (!(value && value instanceof Long)) throw TypeError("Illegal value: "+value+" (not an integer or Long)"); if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } if (typeof value === 'number') value = Long.fromNumber(value, false); else if (typeof value === 'string') value = Long.fromString(value, false); else if (value.unsigned !== false) value = value.toSigned(); var size = ByteBuffer.calculateVarint64(value), part0 = value.toInt() >>> 0, part1 = value.shiftRightUnsigned(28).toInt() >>> 0, part2 = value.shiftRightUnsigned(56).toInt() >>> 0; offset += size; var capacity11 = this.buffer.byteLength; if (offset > capacity11) this.resize((capacity11 *= 2) > offset ? capacity11 : offset); offset -= size; switch (size) { case 10: this.view[offset+9] = (part2 >>> 7) & 0x01; case 9 : this.view[offset+8] = size !== 9 ? (part2 ) | 0x80 : (part2 ) & 0x7F; case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F; case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F; case 6 : this.view[offset+5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7F; case 5 : this.view[offset+4] = size !== 5 ? (part1 ) | 0x80 : (part1 ) & 0x7F; case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F; case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F; case 2 : this.view[offset+1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7F; case 1 : this.view[offset ] = size !== 1 ? (part0 ) | 0x80 : (part0 ) & 0x7F; } if (relative) { this.offset += size; return this; } else { return size; } }; /** * Writes a zig-zag encoded 64bit base 128 variable-length integer. * @param {number|Long} value Value to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written. * @expose */ ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) { return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset); }; /** * Reads a 64bit base 128 variable-length integer. Requires Long.js. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes * read if omitted. * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and * the actual number of bytes read. * @throws {Error} If it's not a valid varint * @expose */ ByteBufferPrototype.readVarint64 = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength); } // ref: src/google/protobuf/io/coded_stream.cc var start = offset, part0 = 0, part1 = 0, part2 = 0, b = 0; b = this.view[offset++]; part0 = (b & 0x7F) ; if ( b & 0x80 ) { b = this.view[offset++]; part0 |= (b & 0x7F) << 7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) { b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) { b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) { b = this.view[offset++]; part1 = (b & 0x7F) ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) { b = this.view[offset++]; part1 |= (b & 0x7F) << 7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) { b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) { b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) { b = this.view[offset++]; part2 = (b & 0x7F) ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) { b = this.view[offset++]; part2 |= (b & 0x7F) << 7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) { throw Error("Buffer overrun"); }}}}}}}}}} var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false); if (relative) { this.offset = offset; return value; } else { return { 'value': value, 'length': offset-start }; } }; /** * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes * read if omitted. * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and * the actual number of bytes read. * @throws {Error} If it's not a valid varint * @expose */ ByteBufferPrototype.readVarint64ZigZag = function(offset) { var val = this.readVarint64(offset); if (val && val['value'] instanceof Long) val["value"] = ByteBuffer.zigZagDecode64(val["value"]); else val = ByteBuffer.zigZagDecode64(val); return val; }; } // Long // types/strings/cstring /** * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL * characters itself. * @param {string} str String to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes * contained in `str` + 1 if omitted. * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written * @expose */ ByteBufferPrototype.writeCString = function(str, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; var i, k = str.length; if (!this.noAssert) { if (typeof str !== 'string') throw TypeError("Illegal str: Not a string"); for (i=0; i<k; ++i) { if (str.charCodeAt(i) === 0) throw RangeError("Illegal str: Contains NULL-characters"); } if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } // UTF8 strings do not contain zero bytes in between except for the zero character, so: k = utfx.calculateUTF16asUTF8(stringSource(str))[1]; offset += k+1; var capacity12 = this.buffer.byteLength; if (offset > capacity12) this.resize((capacity12 *= 2) > offset ? capacity12 : offset); offset -= k+1; utfx.encodeUTF16toUTF8(stringSource(str), function(b) { this.view[offset++] = b; }.bind(this)); this.view[offset++] = 0; if (relative) { this.offset = offset; return this; } return k; }; /** * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters * itself. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes * read if omitted. * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string * read and the actual number of bytes read. * @expose */ ByteBufferPrototype.readCString = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength); } var start = offset, temp; // UTF8 strings do not contain zero bytes in between except for the zero character itself, so: var sd, b = -1; utfx.decodeUTF8toUTF16(function() { if (b === 0) return null; if (offset >= this.limit) throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit); b = this.view[offset++]; return b === 0 ? null : b; }.bind(this), sd = stringDestination(), true); if (relative) { this.offset = offset; return sd(); } else { return { "string": sd(), "length": offset - start }; } }; // types/strings/istring /** * Writes a length as uint32 prefixed UTF8 encoded string. * @param {string} str String to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written * @expose * @see ByteBuffer#writeVarint32 */ ByteBufferPrototype.writeIString = function(str, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof str !== 'string') throw TypeError("Illegal str: Not a string"); if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } var start = offset, k; k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1]; offset += 4+k; var capacity13 = this.buffer.byteLength; if (offset > capacity13) this.resize((capacity13 *= 2) > offset ? capacity13 : offset); offset -= 4+k; if (this.littleEndian) { this.view[offset+3] = (k >>> 24) & 0xFF; this.view[offset+2] = (k >>> 16) & 0xFF; this.view[offset+1] = (k >>> 8) & 0xFF; this.view[offset ] = k & 0xFF; } else { this.view[offset ] = (k >>> 24) & 0xFF; this.view[offset+1] = (k >>> 16) & 0xFF; this.view[offset+2] = (k >>> 8) & 0xFF; this.view[offset+3] = k & 0xFF; } offset += 4; utfx.encodeUTF16toUTF8(stringSource(str), function(b) { this.view[offset++] = b; }.bind(this)); if (offset !== start + 4 + k) throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k)); if (relative) { this.offset = offset; return this; } return offset - start; }; /** * Reads a length as uint32 prefixed UTF8 encoded string. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes * read if omitted. * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string * read and the actual number of bytes read. * @expose * @see ByteBuffer#readVarint32 */ ByteBufferPrototype.readIString = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength); } var start = offset; var len = this.readUint32(offset); var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4); offset += str['length']; if (relative) { this.offset = offset; return str['string']; } else { return { 'string': str['string'], 'length': offset - start }; } }; // types/strings/utf8string /** * Metrics representing number of UTF8 characters. Evaluates to `c`. * @type {string} * @const * @expose */ ByteBuffer.METRICS_CHARS = 'c'; /** * Metrics representing number of bytes. Evaluates to `b`. * @type {string} * @const * @expose */ ByteBuffer.METRICS_BYTES = 'b'; /** * Writes an UTF8 encoded string. * @param {string} str String to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted. * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written. * @expose */ ByteBufferPrototype.writeUTF8String = function(str, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } var k; var start = offset; k = utfx.calculateUTF16asUTF8(stringSource(str))[1]; offset += k; var capacity14 = this.buffer.byteLength; if (offset > capacity14) this.resize((capacity14 *= 2) > offset ? capacity14 : offset); offset -= k; utfx.encodeUTF16toUTF8(stringSource(str), function(b) { this.view[offset++] = b; }.bind(this)); if (relative) { this.offset = offset; return this; } return offset - start; }; /** * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}. * @function * @param {string} str String to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted. * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written. * @expose */ ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String; /** * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's * `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF. * @param {string} str String to calculate * @returns {number} Number of UTF8 characters * @expose */ ByteBuffer.calculateUTF8Chars = function(str) { return utfx.calculateUTF16asUTF8(stringSource(str))[0]; }; /** * Calculates the number of UTF8 bytes of a string. * @param {string} str String to calculate * @returns {number} Number of UTF8 bytes * @expose */ ByteBuffer.calculateUTF8Bytes = function(str) { return utfx.calculateUTF16asUTF8(stringSource(str))[1]; }; /** * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}. * @function * @param {string} str String to calculate * @returns {number} Number of UTF8 bytes * @expose */ ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes; /** * Reads an UTF8 encoded string. * @param {number} length Number of characters or bytes to read. * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to * {@link ByteBuffer.METRICS_CHARS}. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes * read if omitted. * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string * read and the actual number of bytes read. * @expose */ ByteBufferPrototype.readUTF8String = function(length, metrics, offset) { if (typeof metrics === 'number') { offset = metrics; metrics = undefined; } var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS; if (!this.noAssert) { if (typeof length !== 'number' || length % 1 !== 0) throw TypeError("Illegal length: "+length+" (not an integer)"); length |= 0; if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } var i = 0, start = offset, sd; if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser sd = stringDestination(); utfx.decodeUTF8(function() { return i < length && offset < this.limit ? this.view[offset++] : null; }.bind(this), function(cp) { ++i; utfx.UTF8toUTF16(cp, sd); }); if (i !== length) throw RangeError("Illegal range: Truncated data, "+i+" == "+length); if (relative) { this.offset = offset; return sd(); } else { return { "string": sd(), "length": offset - start }; } } else if (metrics === ByteBuffer.METRICS_BYTES) { if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + length > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength); } var k = offset + length; utfx.decodeUTF8toUTF16(function() { return offset < k ? this.view[offset++] : null; }.bind(this), sd = stringDestination(), this.noAssert); if (offset !== k) throw RangeError("Illegal range: Truncated data, "+offset+" == "+k); if (relative) { this.offset = offset; return sd(); } else { return { 'string': sd(), 'length': offset - start }; } } else throw TypeError("Unsupported metrics: "+metrics); }; /** * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}. * @function * @param {number} length Number of characters or bytes to read * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to * {@link ByteBuffer.METRICS_CHARS}. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes * read if omitted. * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string * read and the actual number of bytes read. * @expose */ ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String; // types/strings/vstring /** * Writes a length as varint32 prefixed UTF8 encoded string. * @param {string} str String to write * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written * @expose * @see ByteBuffer#writeVarint32 */ ByteBufferPrototype.writeVString = function(str, offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof str !== 'string') throw TypeError("Illegal str: Not a string"); if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } var start = offset, k, l; k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1]; l = ByteBuffer.calculateVarint32(k); offset += l+k; var capacity15 = this.buffer.byteLength; if (offset > capacity15) this.resize((capacity15 *= 2) > offset ? capacity15 : offset); offset -= l+k; offset += this.writeVarint32(k, offset); utfx.encodeUTF16toUTF8(stringSource(str), function(b) { this.view[offset++] = b; }.bind(this)); if (offset !== start+k+l) throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l)); if (relative) { this.offset = offset; return this; } return offset - start; }; /** * Reads a length as varint32 prefixed UTF8 encoded string. * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes * read if omitted. * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string * read and the actual number of bytes read. * @expose * @see ByteBuffer#readVarint32 */ ByteBufferPrototype.readVString = function(offset) { var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength); } var start = offset; var len = this.readVarint32(offset); var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']); offset += str['length']; if (relative) { this.offset = offset; return str['string']; } else { return { 'string': str['string'], 'length': offset - start }; } }; /** * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended * data's length. * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets * will be modified according to the performed read operation. * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8") * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. * @returns {!ByteBuffer} this * @expose * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|` * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|` */ ByteBufferPrototype.append = function(source, encoding, offset) { if (typeof encoding === 'number' || typeof encoding !== 'string') { offset = encoding; encoding = undefined; } var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } if (!(source instanceof ByteBuffer)) source = ByteBuffer.wrap(source, encoding); var length = source.limit - source.offset; if (length <= 0) return this; // Nothing to append offset += length; var capacity16 = this.buffer.byteLength; if (offset > capacity16) this.resize((capacity16 *= 2) > offset ? capacity16 : offset); offset -= length; this.view.set(source.view.subarray(source.offset, source.limit), offset); source.offset += length; if (relative) this.offset += length; return this; }; /** * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the specified offset up to the length of this ByteBuffer's data. * @param {!ByteBuffer} target Target ByteBuffer * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes * read if omitted. * @returns {!ByteBuffer} this * @expose * @see ByteBuffer#append */ ByteBufferPrototype.appendTo = function(target, offset) { target.append(this, offset); return this; }; /** * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to * disable them if your code already makes sure that everything is valid. * @param {boolean} assert `true` to enable assertions, otherwise `false` * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.assert = function(assert) { this.noAssert = !assert; return this; }; /** * Gets the capacity of this ByteBuffer's backing buffer. * @returns {number} Capacity of the backing buffer * @expose */ ByteBufferPrototype.capacity = function() { return this.buffer.byteLength; }; /** * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the * backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.clear = function() { this.offset = 0; this.limit = this.buffer.byteLength; this.markedOffset = -1; return this; }; /** * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset}, * {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}. * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false` * @returns {!ByteBuffer} Cloned instance * @expose */ ByteBufferPrototype.clone = function(copy) { var bb = new ByteBuffer(0, this.littleEndian, this.noAssert); if (copy) { bb.buffer = new ArrayBuffer(this.buffer.byteLength); bb.view = new Uint8Array(bb.buffer); } else { bb.buffer = this.buffer; bb.view = this.view; } bb.offset = this.offset; bb.markedOffset = this.markedOffset; bb.limit = this.limit; return bb; }; /** * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes * between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and * adapt {@link ByteBuffer#markedOffset} to the same relative position if set. * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset} * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit} * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.compact = function(begin, end) { if (typeof begin === 'undefined') begin = this.offset; if (typeof end === 'undefined') end = this.limit; if (!this.noAssert) { if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); begin >>>= 0; if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer"); end >>>= 0; if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength); } if (begin === 0 && end === this.buffer.byteLength) return this; // Already compacted var len = end - begin; if (len === 0) { this.buffer = EMPTY_BUFFER; this.view = null; if (this.markedOffset >= 0) this.markedOffset -= begin; this.offset = 0; this.limit = 0; return this; } var buffer = new ArrayBuffer(len); var view = new Uint8Array(buffer); view.set(this.view.subarray(begin, end)); this.buffer = buffer; this.view = view; if (this.markedOffset >= 0) this.markedOffset -= begin; this.offset = 0; this.limit = len; return this; }; /** * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and * {@link ByteBuffer#limit}. * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}. * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}. * @returns {!ByteBuffer} Copy * @expose */ ByteBufferPrototype.copy = function(begin, end) { if (typeof begin === 'undefined') begin = this.offset; if (typeof end === 'undefined') end = this.limit; if (!this.noAssert) { if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); begin >>>= 0; if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer"); end >>>= 0; if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength); } if (begin === end) return new ByteBuffer(0, this.littleEndian, this.noAssert); var capacity = end - begin, bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert); bb.offset = 0; bb.limit = capacity; if (bb.markedOffset >= 0) bb.markedOffset -= begin; this.copyTo(bb, 0, begin, end); return bb; }; /** * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and * {@link ByteBuffer#limit}. * @param {!ByteBuffer} target Target ByteBuffer * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset} * by the number of bytes copied if omitted. * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the * number of bytes copied if omitted. * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit} * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) { var relative, targetRelative; if (!this.noAssert) { if (!ByteBuffer.isByteBuffer(target)) throw TypeError("Illegal target: Not a ByteBuffer"); } targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0; sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0; sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0; if (targetOffset < 0 || targetOffset > target.buffer.byteLength) throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength); if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength) throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength); var len = sourceLimit - sourceOffset; if (len === 0) return target; // Nothing to copy target.ensureCapacity(targetOffset + len); target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset); if (relative) this.offset += len; if (targetRelative) target.offset += len; return this; }; /** * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the * current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity, * the required capacity will be used instead. * @param {number} capacity Required capacity * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.ensureCapacity = function(capacity) { var current = this.buffer.byteLength; if (current < capacity) return this.resize((current *= 2) > capacity ? current : capacity); return this; }; /** * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between * {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. * @param {number|string} value Byte value to fill with. If given as a string, the first character is used. * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes * written if omitted. defaults to {@link ByteBuffer#offset}. * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}. * @returns {!ByteBuffer} this * @expose * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes */ ByteBufferPrototype.fill = function(value, begin, end) { var relative = typeof begin === 'undefined'; if (relative) begin = this.offset; if (typeof value === 'string' && value.length > 0) value = value.charCodeAt(0); if (typeof begin === 'undefined') begin = this.offset; if (typeof end === 'undefined') end = this.limit; if (!this.noAssert) { if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: "+value+" (not an integer)"); value |= 0; if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); begin >>>= 0; if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer"); end >>>= 0; if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength); } if (begin >= end) return this; // Nothing to fill while (begin < end) this.view[begin++] = value; if (relative) this.offset = begin; return this; }; /** * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and * `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.flip = function() { this.limit = this.offset; this.offset = 0; return this; }; /** * Marks an offset on this ByteBuffer to be used later. * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}. * @returns {!ByteBuffer} this * @throws {TypeError} If `offset` is not a valid number * @throws {RangeError} If `offset` is out of bounds * @see ByteBuffer#reset * @expose */ ByteBufferPrototype.mark = function(offset) { offset = typeof offset === 'undefined' ? this.offset : offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } this.markedOffset = offset; return this; }; /** * Sets the byte order. * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.order = function(littleEndian) { if (!this.noAssert) { if (typeof littleEndian !== 'boolean') throw TypeError("Illegal littleEndian: Not a boolean"); } this.littleEndian = !!littleEndian; return this; }; /** * Switches (to) little endian byte order. * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.LE = function(littleEndian) { this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true; return this; }; /** * Switches (to) big endian byte order. * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.BE = function(bigEndian) { this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false; return this; }; /** * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the * prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer * will be resized and its contents moved accordingly. * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be * modified according to the performed read operation. * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8") * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes * prepended if omitted. * @returns {!ByteBuffer} this * @expose * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|` * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|` */ ByteBufferPrototype.prepend = function(source, encoding, offset) { if (typeof encoding === 'number' || typeof encoding !== 'string') { offset = encoding; encoding = undefined; } var relative = typeof offset === 'undefined'; if (relative) offset = this.offset; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: "+offset+" (not an integer)"); offset >>>= 0; if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength); } if (!(source instanceof ByteBuffer)) source = ByteBuffer.wrap(source, encoding); var len = source.limit - source.offset; if (len <= 0) return this; // Nothing to prepend var diff = len - offset; if (diff > 0) { // Not enough space before offset, so resize + move var buffer = new ArrayBuffer(this.buffer.byteLength + diff); var view = new Uint8Array(buffer); view.set(this.view.subarray(offset, this.buffer.byteLength), len); this.buffer = buffer; this.view = view; this.offset += diff; if (this.markedOffset >= 0) this.markedOffset += diff; this.limit += diff; offset += diff; } else { var arrayView = new Uint8Array(this.buffer); } this.view.set(source.view.subarray(source.offset, source.limit), offset - len); source.offset = source.limit; if (relative) this.offset -= len; return this; }; /** * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the * prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer * will be resized and its contents moved accordingly. * @param {!ByteBuffer} target Target ByteBuffer * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes * prepended if omitted. * @returns {!ByteBuffer} this * @expose * @see ByteBuffer#prepend */ ByteBufferPrototype.prependTo = function(target, offset) { target.prepend(this, offset); return this; }; /** * Prints debug information about this ByteBuffer's contents. * @param {function(string)=} out Output function to call, defaults to console.log * @expose */ ByteBufferPrototype.printDebug = function(out) { if (typeof out !== 'function') out = console.log.bind(console); out( this.toString()+"\n"+ "-------------------------------------------------------------------\n"+ this.toDebug(/* columns */ true) ); }; /** * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and * {@link ByteBuffer#limit}, so this returns `limit - offset`. * @returns {number} Remaining readable bytes. May be negative if `offset > limit`. * @expose */ ByteBufferPrototype.remaining = function() { return this.limit - this.offset; }; /** * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark} * before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been * marked, sets `offset = 0`. * @returns {!ByteBuffer} this * @see ByteBuffer#mark * @expose */ ByteBufferPrototype.reset = function() { if (this.markedOffset >= 0) { this.offset = this.markedOffset; this.markedOffset = -1; } else { this.offset = 0; } return this; }; /** * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that * large or larger. * @param {number} capacity Capacity required * @returns {!ByteBuffer} this * @throws {TypeError} If `capacity` is not a number * @throws {RangeError} If `capacity < 0` * @expose */ ByteBufferPrototype.resize = function(capacity) { if (!this.noAssert) { if (typeof capacity !== 'number' || capacity % 1 !== 0) throw TypeError("Illegal capacity: "+capacity+" (not an integer)"); capacity |= 0; if (capacity < 0) throw RangeError("Illegal capacity: 0 <= "+capacity); } if (this.buffer.byteLength < capacity) { var buffer = new ArrayBuffer(capacity); var view = new Uint8Array(buffer); view.set(this.view); this.buffer = buffer; this.view = view; } return this; }; /** * Reverses this ByteBuffer's contents. * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset} * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit} * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.reverse = function(begin, end) { if (typeof begin === 'undefined') begin = this.offset; if (typeof end === 'undefined') end = this.limit; if (!this.noAssert) { if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); begin >>>= 0; if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer"); end >>>= 0; if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength); } if (begin === end) return this; // Nothing to reverse Array.prototype.reverse.call(this.view.subarray(begin, end)); return this; }; /** * Skips the next `length` bytes. This will just advance * @param {number} length Number of bytes to skip. May also be negative to move the offset back. * @returns {!ByteBuffer} this * @expose */ ByteBufferPrototype.skip = function(length) { if (!this.noAssert) { if (typeof length !== 'number' || length % 1 !== 0) throw TypeError("Illegal length: "+length+" (not an integer)"); length |= 0; } var offset = this.offset + length; if (!this.noAssert) { if (offset < 0 || offset > this.buffer.byteLength) throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength); } this.offset = offset; return this; }; /** * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`. * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}. * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}. * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer} * @expose */ ByteBufferPrototype.slice = function(begin, end) { if (typeof begin === 'undefined') begin = this.offset; if (typeof end === 'undefined') end = this.limit; if (!this.noAssert) { if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); begin >>>= 0; if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer"); end >>>= 0; if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength); } var bb = this.clone(); bb.offset = begin; bb.limit = end; return bb; }; /** * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between * {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if * possible. Defaults to `false` * @returns {!ArrayBuffer} Contents as an ArrayBuffer * @expose */ ByteBufferPrototype.toBuffer = function(forceCopy) { var offset = this.offset, limit = this.limit; if (!this.noAssert) { if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: Not an integer"); offset >>>= 0; if (typeof limit !== 'number' || limit % 1 !== 0) throw TypeError("Illegal limit: Not an integer"); limit >>>= 0; if (offset < 0 || offset > limit || limit > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength); } // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So: if (!forceCopy && offset === 0 && limit === this.buffer.byteLength) return this.buffer; if (offset === limit) return EMPTY_BUFFER; var buffer = new ArrayBuffer(limit - offset); new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0); return buffer; }; /** * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between * {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}. * @function * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory. * Defaults to `false` * @returns {!ArrayBuffer} Contents as an ArrayBuffer * @expose */ ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer; /** * Converts the ByteBuffer's contents to a string. * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows * direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with * highlighted offsets. * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset} * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit} * @returns {string} String representation * @throws {Error} If `encoding` is invalid * @expose */ ByteBufferPrototype.toString = function(encoding, begin, end) { if (typeof encoding === 'undefined') return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")"; if (typeof encoding === 'number') encoding = "utf8", begin = encoding, end = begin; switch (encoding) { case "utf8": return this.toUTF8(begin, end); case "base64": return this.toBase64(begin, end); case "hex": return this.toHex(begin, end); case "binary": return this.toBinary(begin, end); case "debug": return this.toDebug(); case "columns": return this.toColumns(); default: throw Error("Unsupported encoding: "+encoding); } }; // lxiv-embeddable /** * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io> * Released under the Apache License, Version 2.0 * see: https://github.com/dcodeIO/lxiv for details */ var lxiv = function() { "use strict"; /** * lxiv namespace. * @type {!Object.<string,*>} * @exports lxiv */ var lxiv = {}; /** * Character codes for output. * @type {!Array.<number>} * @inner */ var aout = [ 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 ]; /** * Character codes for input. * @type {!Array.<number>} * @inner */ var ain = []; for (var i=0, k=aout.length; i<k; ++i) ain[aout[i]] = i; /** * Encodes bytes to base64 char codes. * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if * there are no more bytes left. * @param {!function(number)} dst Characters destination as a function successively called with each encoded char * code. */ lxiv.encode = function(src, dst) { var b, t; while ((b = src()) !== null) { dst(aout[(b>>2)&0x3f]); t = (b&0x3)<<4; if ((b = src()) !== null) { t |= (b>>4)&0xf; dst(aout[(t|((b>>4)&0xf))&0x3f]); t = (b&0xf)<<2; if ((b = src()) !== null) dst(aout[(t|((b>>6)&0x3))&0x3f]), dst(aout[b&0x3f]); else dst(aout[t&0x3f]), dst(61); } else dst(aout[t&0x3f]), dst(61), dst(61); } }; /** * Decodes base64 char codes to bytes. * @param {!function():number|null} src Characters source as a function returning the next char code respectively * `null` if there are no more characters left. * @param {!function(number)} dst Bytes destination as a function successively called with the next byte. * @throws {Error} If a character code is invalid */ lxiv.decode = function(src, dst) { var c, t1, t2; function fail(c) { throw Error("Illegal character code: "+c); } while ((c = src()) !== null) { t1 = ain[c]; if (typeof t1 === 'undefined') fail(c); if ((c = src()) !== null) { t2 = ain[c]; if (typeof t2 === 'undefined') fail(c); dst((t1<<2)>>>0|(t2&0x30)>>4); if ((c = src()) !== null) { t1 = ain[c]; if (typeof t1 === 'undefined') if (c === 61) break; else fail(c); dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2); if ((c = src()) !== null) { t2 = ain[c]; if (typeof t2 === 'undefined') if (c === 61) break; else fail(c); dst(((t1&0x3)<<6)>>>0|t2); } } } } }; /** * Tests if a string is valid base64. * @param {string} str String to test * @returns {boolean} `true` if valid, otherwise `false` */ lxiv.test = function(str) { return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str); }; return lxiv; }(); // encodings/base64 /** * Encodes this ByteBuffer's contents to a base64 encoded string. * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}. * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}. * @returns {string} Base64 encoded string * @throws {RangeError} If `begin` or `end` is out of bounds * @expose */ ByteBufferPrototype.toBase64 = function(begin, end) { if (typeof begin === 'undefined') begin = this.offset; if (typeof end === 'undefined') end = this.limit; begin = begin | 0; end = end | 0; if (begin < 0 || end > this.capacity || begin > end) throw RangeError("begin, end"); var sd; lxiv.encode(function() { return begin < end ? this.view[begin++] : null; }.bind(this), sd = stringDestination()); return sd(); }; /** * Decodes a base64 encoded string to a ByteBuffer. * @param {string} str String to decode * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to * {@link ByteBuffer.DEFAULT_ENDIAN}. * @returns {!ByteBuffer} ByteBuffer * @expose */ ByteBuffer.fromBase64 = function(str, littleEndian) { if (typeof str !== 'string') throw TypeError("str"); var bb = new ByteBuffer(str.length/4*3, littleEndian), i = 0; lxiv.decode(stringSource(str), function(b) { bb.view[i++] = b; }); bb.limit = i; return bb; }; /** * Encodes a binary string to base64 like `window.btoa` does. * @param {string} str Binary string * @returns {string} Base64 encoded string * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa * @expose */ ByteBuffer.btoa = function(str) { return ByteBuffer.fromBinary(str).toBase64(); }; /** * Decodes a base64 encoded string to binary like `window.atob` does. * @param {string} b64 Base64 encoded string * @returns {string} Binary string * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob * @expose */ ByteBuffer.atob = function(b64) { return ByteBuffer.fromBase64(b64).toBinary(); }; // encodings/binary /** * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes. * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}. * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}. * @returns {string} Binary encoded string * @throws {RangeError} If `offset > limit` * @expose */ ByteBufferPrototype.toBinary = function(begin, end) { if (typeof begin === 'undefined') begin = this.offset; if (typeof end === 'undefined') end = this.limit; begin |= 0; end |= 0; if (begin < 0 || end > this.capacity() || begin > end) throw RangeError("begin, end"); if (begin === end) return ""; var chars = [], parts = []; while (begin < end) { chars.push(this.view[begin++]); if (chars.length >= 1024) parts.push(String.fromCharCode.apply(String, chars)), chars = []; } return parts.join('') + String.fromCharCode.apply(String, chars); }; /** * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer. * @param {string} str String to decode * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to * {@link ByteBuffer.DEFAULT_ENDIAN}. * @returns {!ByteBuffer} ByteBuffer * @expose */ ByteBuffer.fromBinary = function(str, littleEndian) { if (typeof str !== 'string') throw TypeError("str"); var i = 0, k = str.length, charCode, bb = new ByteBuffer(k, littleEndian); while (i<k) { charCode = str.charCodeAt(i); if (charCode > 0xff) throw RangeError("illegal char code: "+charCode); bb.view[i++] = charCode; } bb.limit = k; return bb; }; // encodings/debug /** * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are: * * `<` : offset, * * `'` : markedOffset, * * `>` : limit, * * `|` : offset and limit, * * `[` : offset and markedOffset, * * `]` : markedOffset and limit, * * `!` : offset, markedOffset and limit * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false` * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true` * @expose * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3` * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4` * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1` * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1` */ ByteBufferPrototype.toDebug = function(columns) { var i = -1, k = this.buffer.byteLength, b, hex = "", asc = "", out = ""; while (i<k) { if (i !== -1) { b = this.view[i]; if (b < 0x10) hex += "0"+b.toString(16).toUpperCase(); else hex += b.toString(16).toUpperCase(); if (columns) asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.'; } ++i; if (columns) { if (i > 0 && i % 16 === 0 && i !== k) { while (hex.length < 3*16+3) hex += " "; out += hex+asc+"\n"; hex = asc = ""; } } if (i === this.offset && i === this.limit) hex += i === this.markedOffset ? "!" : "|"; else if (i === this.offset) hex += i === this.markedOffset ? "[" : "<"; else if (i === this.limit) hex += i === this.markedOffset ? "]" : ">"; else hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : ""); } if (columns && hex !== " ") { while (hex.length < 3*16+3) hex += " "; out += hex + asc + "\n"; } return columns ? out : hex; }; /** * Decodes a hex encoded string with marked offsets to a ByteBuffer. * @param {string} str Debug string to decode (not be generated with `columns = true`) * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to * {@link ByteBuffer.DEFAULT_ENDIAN}. * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to * {@link ByteBuffer.DEFAULT_NOASSERT}. * @returns {!ByteBuffer} ByteBuffer * @expose * @see ByteBuffer#toDebug */ ByteBuffer.fromDebug = function(str, littleEndian, noAssert) { var k = str.length, bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert); var i = 0, j = 0, ch, b, rs = false, // Require symbol next ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)? fail = false; while (i<k) { switch (ch = str.charAt(i++)) { case '!': if (!noAssert) { if (ho || hm || hl) { fail = true; break; } ho = hm = hl = true; } bb.offset = bb.markedOffset = bb.limit = j; rs = false; break; case '|': if (!noAssert) { if (ho || hl) { fail = true; break; } ho = hl = true; } bb.offset = bb.limit = j; rs = false; break; case '[': if (!noAssert) { if (ho || hm) { fail = true; break; } ho = hm = true; } bb.offset = bb.markedOffset = j; rs = false; break; case '<': if (!noAssert) { if (ho) { fail = true; break; } ho = true; } bb.offset = j; rs = false; break; case ']': if (!noAssert) { if (hl || hm) { fail = true; break; } hl = hm = true; } bb.limit = bb.markedOffset = j; rs = false; break; case '>': if (!noAssert) { if (hl) { fail = true; break; } hl = true; } bb.limit = j; rs = false; break; case "'": if (!noAssert) { if (hm) { fail = true; break; } hm = true; } bb.markedOffset = j; rs = false; break; case ' ': rs = false; break; default: if (!noAssert) { if (rs) { fail = true; break; } } b = parseInt(ch+str.charAt(i++), 16); if (!noAssert) { if (isNaN(b) || b < 0 || b > 255) throw TypeError("Illegal str: Not a debug encoded string"); } bb.view[j++] = b; rs = true; } if (fail) throw TypeError("Illegal str: Invalid symbol at "+i); } if (!noAssert) { if (!ho || !hl) throw TypeError("Illegal str: Missing offset or limit"); if (j<bb.buffer.byteLength) throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k); } return bb; }; // encodings/hex /** * Encodes this ByteBuffer's contents to a hex encoded string. * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}. * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}. * @returns {string} Hex encoded string * @expose */ ByteBufferPrototype.toHex = function(begin, end) { begin = typeof begin === 'undefined' ? this.offset : begin; end = typeof end === 'undefined' ? this.limit : end; if (!this.noAssert) { if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); begin >>>= 0; if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer"); end >>>= 0; if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength); } var out = new Array(end - begin), b; while (begin < end) { b = this.view[begin++]; if (b < 0x10) out.push("0", b.toString(16)); else out.push(b.toString(16)); } return out.join(''); }; /** * Decodes a hex encoded string to a ByteBuffer. * @param {string} str String to decode * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to * {@link ByteBuffer.DEFAULT_ENDIAN}. * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to * {@link ByteBuffer.DEFAULT_NOASSERT}. * @returns {!ByteBuffer} ByteBuffer * @expose */ ByteBuffer.fromHex = function(str, littleEndian, noAssert) { if (!noAssert) { if (typeof str !== 'string') throw TypeError("Illegal str: Not a string"); if (str.length % 2 !== 0) throw TypeError("Illegal str: Length not a multiple of 2"); } var k = str.length, bb = new ByteBuffer((k / 2) | 0, littleEndian), b; for (var i=0, j=0; i<k; i+=2) { b = parseInt(str.substring(i, i+2), 16); if (!noAssert) if (!isFinite(b) || b < 0 || b > 255) throw TypeError("Illegal str: Contains non-hex characters"); bb.view[j++] = b; } bb.limit = j; return bb; }; // utfx-embeddable /** * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io> * Released under the Apache License, Version 2.0 * see: https://github.com/dcodeIO/utfx for details */ var utfx = function() { "use strict"; /** * utfx namespace. * @inner * @type {!Object.<string,*>} */ var utfx = {}; /** * Maximum valid code point. * @type {number} * @const */ utfx.MAX_CODEPOINT = 0x10FFFF; /** * Encodes UTF8 code points to UTF8 bytes. * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point * respectively `null` if there are no more code points left or a single numeric code point. * @param {!function(number)} dst Bytes destination as a function successively called with the next byte */ utfx.encodeUTF8 = function(src, dst) { var cp = null; if (typeof src === 'number') cp = src, src = function() { return null; }; while (cp !== null || (cp = src()) !== null) { if (cp < 0x80) dst(cp&0x7F); else if (cp < 0x800) dst(((cp>>6)&0x1F)|0xC0), dst((cp&0x3F)|0x80); else if (cp < 0x10000) dst(((cp>>12)&0x0F)|0xE0), dst(((cp>>6)&0x3F)|0x80), dst((cp&0x3F)|0x80); else dst(((cp>>18)&0x07)|0xF0), dst(((cp>>12)&0x3F)|0x80), dst(((cp>>6)&0x3F)|0x80), dst((cp&0x3F)|0x80); cp = null; } }; /** * Decodes UTF8 bytes to UTF8 code points. * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there * are no more bytes left. * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point. * @throws {RangeError} If a starting byte is invalid in UTF8 * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the * remaining bytes. */ utfx.decodeUTF8 = function(src, dst) { var a, b, c, d, fail = function(b) { b = b.slice(0, b.indexOf(null)); var err = Error(b.toString()); err.name = "TruncatedError"; err['bytes'] = b; throw err; }; while ((a = src()) !== null) { if ((a&0x80) === 0) dst(a); else if ((a&0xE0) === 0xC0) ((b = src()) === null) && fail([a, b]), dst(((a&0x1F)<<6) | (b&0x3F)); else if ((a&0xF0) === 0xE0) ((b=src()) === null || (c=src()) === null) && fail([a, b, c]), dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F)); else if ((a&0xF8) === 0xF0) ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]), dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F)); else throw RangeError("Illegal starting byte: "+a); } }; /** * Converts UTF16 characters to UTF8 code points. * @param {!function():number|null} src Characters source as a function returning the next char code respectively * `null` if there are no more characters left. * @param {!function(number)} dst Code points destination as a function successively called with each converted code * point. */ utfx.UTF16toUTF8 = function(src, dst) { var c1, c2 = null; while (true) { if ((c1 = c2 !== null ? c2 : src()) === null) break; if (c1 >= 0xD800 && c1 <= 0xDFFF) { if ((c2 = src()) !== null) { if (c2 >= 0xDC00 && c2 <= 0xDFFF) { dst((c1-0xD800)*0x400+c2-0xDC00+0x10000); c2 = null; continue; } } } dst(c1); } if (c2 !== null) dst(c2); }; /** * Converts UTF8 code points to UTF16 characters. * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point * respectively `null` if there are no more code points left or a single numeric code point. * @param {!function(number)} dst Characters destination as a function successively called with each converted char code. * @throws {RangeError} If a code point is out of range */ utfx.UTF8toUTF16 = function(src, dst) { var cp = null; if (typeof src === 'number') cp = src, src = function() { return null; }; while (cp !== null || (cp = src()) !== null) { if (cp <= 0xFFFF) dst(cp); else cp -= 0x10000, dst((cp>>10)+0xD800), dst((cp%0x400)+0xDC00); cp = null; } }; /** * Converts and encodes UTF16 characters to UTF8 bytes. * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null` * if there are no more characters left. * @param {!function(number)} dst Bytes destination as a function successively called with the next byte. */ utfx.encodeUTF16toUTF8 = function(src, dst) { utfx.UTF16toUTF8(src, function(cp) { utfx.encodeUTF8(cp, dst); }); }; /** * Decodes and converts UTF8 bytes to UTF16 characters. * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there * are no more bytes left. * @param {!function(number)} dst Characters destination as a function successively called with each converted char code. * @throws {RangeError} If a starting byte is invalid in UTF8 * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes. */ utfx.decodeUTF8toUTF16 = function(src, dst) { utfx.decodeUTF8(src, function(cp) { utfx.UTF8toUTF16(cp, dst); }); }; /** * Calculates the byte length of an UTF8 code point. * @param {number} cp UTF8 code point * @returns {number} Byte length */ utfx.calculateCodePoint = function(cp) { return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4; }; /** * Calculates the number of UTF8 bytes required to store UTF8 code points. * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively * `null` if there are no more code points left. * @returns {number} The number of UTF8 bytes required */ utfx.calculateUTF8 = function(src) { var cp, l=0; while ((cp = src()) !== null) l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4; return l; }; /** * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes. * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively * `null` if there are no more characters left. * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1. */ utfx.calculateUTF16asUTF8 = function(src) { var n=0, l=0; utfx.UTF16toUTF8(src, function(cp) { ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4; }); return [n,l]; }; return utfx; }(); // encodings/utf8 /** * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded * string. * @returns {string} Hex encoded string * @throws {RangeError} If `offset > limit` * @expose */ ByteBufferPrototype.toUTF8 = function(begin, end) { if (typeof begin === 'undefined') begin = this.offset; if (typeof end === 'undefined') end = this.limit; if (!this.noAssert) { if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer"); begin >>>= 0; if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer"); end >>>= 0; if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength); } var sd; try { utfx.decodeUTF8toUTF16(function() { return begin < end ? this.view[begin++] : null; }.bind(this), sd = stringDestination()); } catch (e) { if (begin !== end) throw RangeError("Illegal range: Truncated data, "+begin+" != "+end); } return sd(); }; /** * Decodes an UTF8 encoded string to a ByteBuffer. * @param {string} str String to decode * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to * {@link ByteBuffer.DEFAULT_ENDIAN}. * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to * {@link ByteBuffer.DEFAULT_NOASSERT}. * @returns {!ByteBuffer} ByteBuffer * @expose */ ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) { if (!noAssert) if (typeof str !== 'string') throw TypeError("Illegal str: Not a string"); var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert), i = 0; utfx.encodeUTF16toUTF8(stringSource(str), function(b) { bb.view[i++] = b; }); bb.limit = i; return bb; }; return ByteBuffer; }); },{"long":212}],78:[function(require,module,exports){ var Buffer = require('safe-buffer').Buffer var Transform = require('stream').Transform var StringDecoder = require('string_decoder').StringDecoder var inherits = require('inherits') function CipherBase (hashMode) { Transform.call(this) this.hashMode = typeof hashMode === 'string' if (this.hashMode) { this[hashMode] = this._finalOrDigest } else { this.final = this._finalOrDigest } if (this._final) { this.__final = this._final this._final = null } this._decoder = null this._encoding = null } inherits(CipherBase, Transform) CipherBase.prototype.update = function (data, inputEnc, outputEnc) { if (typeof data === 'string') { data = Buffer.from(data, inputEnc) } var outData = this._update(data) if (this.hashMode) return this if (outputEnc) { outData = this._toString(outData, outputEnc) } return outData } CipherBase.prototype.setAutoPadding = function () {} CipherBase.prototype.getAuthTag = function () { throw new Error('trying to get auth tag in unsupported state') } CipherBase.prototype.setAuthTag = function () { throw new Error('trying to set auth tag in unsupported state') } CipherBase.prototype.setAAD = function () { throw new Error('trying to set aad in unsupported state') } CipherBase.prototype._transform = function (data, _, next) { var err try { if (this.hashMode) { this._update(data) } else { this.push(this._update(data)) } } catch (e) { err = e } finally { next(err) } } CipherBase.prototype._flush = function (done) { var err try { this.push(this.__final()) } catch (e) { err = e } done(err) } CipherBase.prototype._finalOrDigest = function (outputEnc) { var outData = this.__final() || Buffer.alloc(0) if (outputEnc) { outData = this._toString(outData, outputEnc, true) } return outData } CipherBase.prototype._toString = function (value, enc, fin) { if (!this._decoder) { this._decoder = new StringDecoder(enc) this._encoding = enc } if (this._encoding !== enc) throw new Error('can\'t switch encodings') var out = this._decoder.write(value) if (fin) { out += this._decoder.end() } return out } module.exports = CipherBase },{"inherits":203,"safe-buffer":262,"stream":273,"string_decoder":71}],79:[function(require,module,exports){ (function (Buffer){ var base58 = require('bs58') var createHash = require('create-hash') function encode (payload, version) { if (Array.isArray(payload) || payload instanceof Uint8Array) { payload = new Buffer(payload) } var buf if (version != null) { if (typeof version === 'number') { version = new Buffer([version]) } buf = Buffer.concat([version, payload]) } else { buf = payload } var checksum = sha256x2(buf).slice(0, 4) var result = Buffer.concat([buf, checksum]) return base58.encode(result) } function decode (base58str, version) { var arr = base58.decode(base58str) var buf = new Buffer(arr) var versionLength if (version == null) { versionLength = 0 } else { if (typeof version === 'number') version = new Buffer([version]) versionLength = version.length var versionCompare = buf.slice(0, versionLength) if (versionCompare.toString('hex') !== version.toString('hex')) { throw new Error('Invalid version') } } var checksum = buf.slice(-4) var endPos = buf.length - 4 var bytes = buf.slice(0, endPos) var newChecksum = sha256x2(bytes).slice(0, 4) if (checksum.toString('hex') !== newChecksum.toString('hex')) { throw new Error('Invalid checksum') } return bytes.slice(versionLength) } function isValid (base58str, version) { try { decode(base58str, version) } catch (e) { return false } return true } function createEncoder (version) { return function (payload) { return encode(payload, version) } } function createDecoder (version) { return function (base58str) { return decode(base58str, version) } } function createValidator (version) { return function (base58str) { return isValid(base58str, version) } } function sha256x2 (buffer) { var sha = createHash('sha256').update(buffer).digest() return createHash('sha256').update(sha).digest() } module.exports = { encode: encode, decode: decode, isValid: isValid, createEncoder: createEncoder, createDecoder: createDecoder, createValidator: createValidator } }).call(this,require("buffer").Buffer) },{"bs58":72,"buffer":75,"create-hash":83}],80:[function(require,module,exports){ /** * Expose `Emitter`. */ if (typeof module !== 'undefined') { module.exports = Emitter; } /** * Initialize a new `Emitter`. * * @api public */ function Emitter(obj) { if (obj) return mixin(obj); }; /** * Mixin the emitter properties. * * @param {Object} obj * @return {Object} * @api private */ function mixin(obj) { for (var key in Emitter.prototype) { obj[key] = Emitter.prototype[key]; } return obj; } /** * Listen on the given `event` with `fn`. * * @param {String} event * @param {Function} fn * @return {Emitter} * @api public */ Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn){ this._callbacks = this._callbacks || {}; (this._callbacks['$' + event] = this._callbacks['$' + event] || []) .push(fn); return this; }; /** * Adds an `event` listener that will be invoked a single * time then automatically removed. * * @param {String} event * @param {Function} fn * @return {Emitter} * @api public */ Emitter.prototype.once = function(event, fn){ function on() { this.off(event, on); fn.apply(this, arguments); } on.fn = fn; this.on(event, on); return this; }; /** * Remove the given callback for `event` or all * registered callbacks. * * @param {String} event * @param {Function} fn * @return {Emitter} * @api public */ Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn){ this._callbacks = this._callbacks || {}; // all if (0 == arguments.length) { this._callbacks = {}; return this; } // specific event var callbacks = this._callbacks['$' + event]; if (!callbacks) return this; // remove all handlers if (1 == arguments.length) { delete this._callbacks['$' + event]; return this; } // remove specific handler var cb; for (var i = 0; i < callbacks.length; i++) { cb = callbacks[i]; if (cb === fn || cb.fn === fn) { callbacks.splice(i, 1); break; } } // Remove event specific arrays for event types that no // one is subscribed for to avoid memory leak. if (callbacks.length === 0) { delete this._callbacks['$' + event]; } return this; }; /** * Emit `event` with the given args. * * @param {String} event * @param {Mixed} ... * @return {Emitter} */ Emitter.prototype.emit = function(event){ this._callbacks = this._callbacks || {}; var args = new Array(arguments.length - 1) , callbacks = this._callbacks['$' + event]; for (var i = 1; i < arguments.length; i++) { args[i - 1] = arguments[i]; } if (callbacks) { callbacks = callbacks.slice(0); for (var i = 0, len = callbacks.length; i < len; ++i) { callbacks[i].apply(this, args); } } return this; }; /** * Return array of callbacks for `event`. * * @param {String} event * @return {Array} * @api public */ Emitter.prototype.listeners = function(event){ this._callbacks = this._callbacks || {}; return this._callbacks['$' + event] || []; }; /** * Check if this emitter has `event` handlers. * * @param {String} event * @return {Boolean} * @api public */ Emitter.prototype.hasListeners = function(event){ return !! this.listeners(event).length; }; },{}],81:[function(require,module,exports){ (function (Buffer){ // Copyright Joyent, Inc. and other Node contributors. // // Permission is hereby granted, free of charge, to any person obtaining a // copy of this software and associated documentation files (the // "Software"), to deal in the Software without restriction, including // without limitation the rights to use, copy, modify, merge, publish, // distribute, sublicense, and/or sell copies of the Software, and to permit // persons to whom the Software is furnished to do so, subject to the // following conditions: // // The above copyright notice and this permission notice shall be included // in all copies or substantial portions of the Software. // // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE // USE OR OTHER DEALINGS IN THE SOFTWARE. // NOTE: These type checking functions intentionally don't use `instanceof` // because it is fragile and can be easily faked with `Object.create()`. function isArray(arg) { if (Array.isArray) { return Array.isArray(arg); } return objectToString(arg) === '[object Array]'; } exports.isArray = isArray; function isBoolean(arg) { return typeof arg === 'boolean'; } exports.isBoolean = isBoolean; function isNull(arg) { return arg === null; } exports.isNull = isNull; function isNullOrUndefined(arg) { return arg == null; } exports.isNullOrUndefined = isNullOrUndefined; function isNumber(arg) { return typeof arg === 'number'; } exports.isNumber = isNumber; function isString(arg) { return typeof arg === 'string'; } exports.isString = isString; function isSymbol(arg) { return typeof arg === 'symbol'; } exports.isSymbol = isSymbol; function isUndefined(arg) { return arg === void 0; } exports.isUndefined = isUndefined; function isRegExp(re) { return objectToString(re) === '[object RegExp]'; } exports.isRegExp = isRegExp; function isObject(arg) { return typeof arg === 'object' && arg !== null; } exports.isObject = isObject; function isDate(d) { return objectToString(d) === '[object Date]'; } exports.isDate = isDate; function isError(e) { return (objectToString(e) === '[object Error]' || e instanceof Error); } exports.isError = isError; function isFunction(arg) { return typeof arg === 'function'; } exports.isFunction = isFunction; function isPrimitive(arg) { return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol typeof arg === 'undefined'; } exports.isPrimitive = isPrimitive; exports.isBuffer = Buffer.isBuffer; function objectToString(o) { return Object.prototype.toString.call(o); } }).call(this,{"isBuffer":require("../../is-buffer/index.js")}) },{"../../is-buffer/index.js":204}],82:[function(require,module,exports){ (function (Buffer){ var elliptic = require('elliptic') var BN = require('bn.js') module.exports = function createECDH (curve) { return new ECDH(curve) } var aliases = { secp256k1: { name: 'secp256k1', byteLength: 32 }, secp224r1: { name: 'p224', byteLength: 28 }, prime256v1: { name: 'p256', byteLength: 32 }, prime192v1: { name: 'p192', byteLength: 24 }, ed25519: { name: 'ed25519', byteLength: 32 }, secp384r1: { name: 'p384', byteLength: 48 }, secp521r1: { name: 'p521', byteLength: 66 } } aliases.p224 = aliases.secp224r1 aliases.p256 = aliases.secp256r1 = aliases.prime256v1 aliases.p192 = aliases.secp192r1 = aliases.prime192v1 aliases.p384 = aliases.secp384r1 aliases.p521 = aliases.secp521r1 function ECDH (curve) { this.curveType = aliases[curve] if (!this.curveType) { this.curveType = { name: curve } } this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap this.keys = void 0 } ECDH.prototype.generateKeys = function (enc, format) { this.keys = this.curve.genKeyPair() return this.getPublicKey(enc, format) } ECDH.prototype.computeSecret = function (other, inenc, enc) { inenc = inenc || 'utf8' if (!Buffer.isBuffer(other)) { other = new Buffer(other, inenc) } var otherPub = this.curve.keyFromPublic(other).getPublic() var out = otherPub.mul(this.keys.getPrivate()).getX() return formatReturnValue(out, enc, this.curveType.byteLength) } ECDH.prototype.getPublicKey = function (enc, format) { var key = this.keys.getPublic(format === 'compressed', true) if (format === 'hybrid') { if (key[key.length - 1] % 2) { key[0] = 7 } else { key[0] = 6 } } return formatReturnValue(key, enc) } ECDH.prototype.getPrivateKey = function (enc) { return formatReturnValue(this.keys.getPrivate(), enc) } ECDH.prototype.setPublicKey = function (pub, enc) { enc = enc || 'utf8' if (!Buffer.isBuffer(pub)) { pub = new Buffer(pub, enc) } this.keys._importPublic(pub) return this } ECDH.prototype.setPrivateKey = function (priv, enc) { enc = enc || 'utf8' if (!Buffer.isBuffer(priv)) { priv = new Buffer(priv, enc) } var _priv = new BN(priv) _priv = _priv.toString(16) this.keys = this.curve.genKeyPair() this.keys._importPrivate(_priv) return this } function formatReturnValue (bn, enc, len) { if (!Array.isArray(bn)) { bn = bn.toArray() } var buf = new Buffer(bn) if (len && buf.length < len) { var zeros = new Buffer(len - buf.length) zeros.fill(0) buf = Buffer.concat([zeros, buf]) } if (!enc) { return buf } else { return buf.toString(enc) } } }).call(this,require("buffer").Buffer) },{"bn.js":41,"buffer":75,"elliptic":168}],83:[function(require,module,exports){ 'use strict' var inherits = require('inherits') var MD5 = require('md5.js') var RIPEMD160 = require('ripemd160') var sha = require('sha.js') var Base = require('cipher-base') function Hash (hash) { Base.call(this, 'digest') this._hash = hash } inherits(Hash, Base) Hash.prototype._update = function (data) { this._hash.update(data) } Hash.prototype._final = function () { return this._hash.digest() } module.exports = function createHash (alg) { alg = alg.toLowerCase() if (alg === 'md5') return new MD5() if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160() return new Hash(sha(alg)) } },{"cipher-base":78,"inherits":203,"md5.js":213,"ripemd160":261,"sha.js":265}],84:[function(require,module,exports){ var MD5 = require('md5.js') module.exports = function (buffer) { return new MD5().update(buffer).digest() } },{"md5.js":213}],85:[function(require,module,exports){ 'use strict' var inherits = require('inherits') var Legacy = require('./legacy') var Base = require('cipher-base') var Buffer = require('safe-buffer').Buffer var md5 = require('create-hash/md5') var RIPEMD160 = require('ripemd160') var sha = require('sha.js') var ZEROS = Buffer.alloc(128) function Hmac (alg, key) { Base.call(this, 'digest') if (typeof key === 'string') { key = Buffer.from(key) } var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64 this._alg = alg this._key = key if (key.length > blocksize) { var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg) key = hash.update(key).digest() } else if (key.length < blocksize) { key = Buffer.concat([key, ZEROS], blocksize) } var ipad = this._ipad = Buffer.allocUnsafe(blocksize) var opad = this._opad = Buffer.allocUnsafe(blocksize) for (var i = 0; i < blocksize; i++) { ipad[i] = key[i] ^ 0x36 opad[i] = key[i] ^ 0x5C } this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg) this._hash.update(ipad) } inherits(Hmac, Base) Hmac.prototype._update = function (data) { this._hash.update(data) } Hmac.prototype._final = function () { var h = this._hash.digest() var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg) return hash.update(this._opad).update(h).digest() } module.exports = function createHmac (alg, key) { alg = alg.toLowerCase() if (alg === 'rmd160' || alg === 'ripemd160') { return new Hmac('rmd160', key) } if (alg === 'md5') { return new Legacy(md5, key) } return new Hmac(alg, key) } },{"./legacy":86,"cipher-base":78,"create-hash/md5":84,"inherits":203,"ripemd160":261,"safe-buffer":262,"sha.js":265}],86:[function(require,module,exports){ 'use strict' var inherits = require('inherits') var Buffer = require('safe-buffer').Buffer var Base = require('cipher-base') var ZEROS = Buffer.alloc(128) var blocksize = 64 function Hmac (alg, key) { Base.call(this, 'digest') if (typeof key === 'string') { key = Buffer.from(key) } this._alg = alg this._key = key if (key.length > blocksize) { key = alg(key) } else if (key.length < blocksize) { key = Buffer.concat([key, ZEROS], blocksize) } var ipad = this._ipad = Buffer.allocUnsafe(blocksize) var opad = this._opad = Buffer.allocUnsafe(blocksize) for (var i = 0; i < blocksize; i++) { ipad[i] = key[i] ^ 0x36 opad[i] = key[i] ^ 0x5C } this._hash = [ipad] } inherits(Hmac, Base) Hmac.prototype._update = function (data) { this._hash.push(data) } Hmac.prototype._final = function () { var h = this._alg(Buffer.concat(this._hash)) return this._alg(Buffer.concat([this._opad, h])) } module.exports = Hmac },{"cipher-base":78,"inherits":203,"safe-buffer":262}],87:[function(require,module,exports){ 'use strict' exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes') exports.createHash = exports.Hash = require('create-hash') exports.createHmac = exports.Hmac = require('create-hmac') var algos = require('browserify-sign/algos') var algoKeys = Object.keys(algos) var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys) exports.getHashes = function () { return hashes } var p = require('pbkdf2') exports.pbkdf2 = p.pbkdf2 exports.pbkdf2Sync = p.pbkdf2Sync var aes = require('browserify-cipher') exports.Cipher = aes.Cipher exports.createCipher = aes.createCipher exports.Cipheriv = aes.Cipheriv exports.createCipheriv = aes.createCipheriv exports.Decipher = aes.Decipher exports.createDecipher = aes.createDecipher exports.Decipheriv = aes.Decipheriv exports.createDecipheriv = aes.createDecipheriv exports.getCiphers = aes.getCiphers exports.listCiphers = aes.listCiphers var dh = require('diffie-hellman') exports.DiffieHellmanGroup = dh.DiffieHellmanGroup exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup exports.getDiffieHellman = dh.getDiffieHellman exports.createDiffieHellman = dh.createDiffieHellman exports.DiffieHellman = dh.DiffieHellman var sign = require('browserify-sign') exports.createSign = sign.createSign exports.Sign = sign.Sign exports.createVerify = sign.createVerify exports.Verify = sign.Verify exports.createECDH = require('create-ecdh') var publicEncrypt = require('public-encrypt') exports.publicEncrypt = publicEncrypt.publicEncrypt exports.privateEncrypt = publicEncrypt.privateEncrypt exports.publicDecrypt = publicEncrypt.publicDecrypt exports.privateDecrypt = publicEncrypt.privateDecrypt // the least I can do is make error messages for the rest of the node.js/crypto api. // ;[ // 'createCredentials' // ].forEach(function (name) { // exports[name] = function () { // throw new Error([ // 'sorry, ' + name + ' is not implemented yet', // 'we accept pull requests', // 'https://github.com/crypto-browserify/crypto-browserify' // ].join('\n')) // } // }) var rf = require('randomfill') exports.randomFill = rf.randomFill exports.randomFillSync = rf.randomFillSync exports.createCredentials = function () { throw new Error([ 'sorry, createCredentials is not implemented yet', 'we accept pull requests', 'https://github.com/crypto-browserify/crypto-browserify' ].join('\n')) } exports.constants = { 'DH_CHECK_P_NOT_SAFE_PRIME': 2, 'DH_CHECK_P_NOT_PRIME': 1, 'DH_UNABLE_TO_CHECK_GENERATOR': 4, 'DH_NOT_SUITABLE_GENERATOR': 8, 'NPN_ENABLED': 1, 'ALPN_ENABLED': 1, 'RSA_PKCS1_PADDING': 1, 'RSA_SSLV23_PADDING': 2, 'RSA_NO_PADDING': 3, 'RSA_PKCS1_OAEP_PADDING': 4, 'RSA_X931_PADDING': 5, 'RSA_PKCS1_PSS_PADDING': 6, 'POINT_CONVERSION_COMPRESSED': 2, 'POINT_CONVERSION_UNCOMPRESSED': 4, 'POINT_CONVERSION_HYBRID': 6 } },{"browserify-cipher":61,"browserify-sign":68,"browserify-sign/algos":65,"create-ecdh":82,"create-hash":83,"create-hmac":85,"diffie-hellman":94,"pbkdf2":223,"public-encrypt":236,"randombytes":246,"randomfill":247}],88:[function(require,module,exports){ 'use strict'; exports.utils = require('./des/utils'); exports.Cipher = require('./des/cipher'); exports.DES = require('./des/des'); exports.CBC = require('./des/cbc'); exports.EDE = require('./des/ede'); },{"./des/cbc":89,"./des/cipher":90,"./des/des":91,"./des/ede":92,"./des/utils":93}],89:[function(require,module,exports){ 'use strict'; var assert = require('minimalistic-assert'); var inherits = require('inherits'); var proto = {}; function CBCState(iv) { assert.equal(iv.length, 8, 'Invalid IV length'); this.iv = new Array(8); for (var i = 0; i < this.iv.length; i++) this.iv[i] = iv[i]; } function instantiate(Base) { function CBC(options) { Base.call(this, options); this._cbcInit(); } inherits(CBC, Base); var keys = Object.keys(proto); for (var i = 0; i < keys.length; i++) { var key = keys[i]; CBC.prototype[key] = proto[key]; } CBC.create = function create(options) { return new CBC(options); }; return CBC; } exports.instantiate = instantiate; proto._cbcInit = function _cbcInit() { var state = new CBCState(this.options.iv); this._cbcState = state; }; proto._update = function _update(inp, inOff, out, outOff) { var state = this._cbcState; var superProto = this.constructor.super_.prototype; var iv = state.iv; if (this.type === 'encrypt') { for (var i = 0; i < this.blockSize; i++) iv[i] ^= inp[inOff + i]; superProto._update.call(this, iv, 0, out, outOff); for (var i = 0; i < this.blockSize; i++) iv[i] = out[outOff + i]; } else { superProto._update.call(this, inp, inOff, out, outOff); for (var i = 0; i < this.blockSize; i++) out[outOff + i] ^= iv[i]; for (var i = 0; i < this.blockSize; i++) iv[i] = inp[inOff + i]; } }; },{"inherits":203,"minimalistic-assert":215}],90:[function(require,module,exports){ 'use strict'; var assert = require('minimalistic-assert'); function Cipher(options) { this.options = options; this.type = this.options.type; this.blockSize = 8; this._init(); this.buffer = new Array(this.blockSize); this.bufferOff = 0; } module.exports = Cipher; Cipher.prototype._init = function _init() { // Might be overrided }; Cipher.prototype.update = function update(data) { if (data.length === 0) return []; if (this.type === 'decrypt') return this._updateDecrypt(data); else return this._updateEncrypt(data); }; Cipher.prototype._buffer = function _buffer(data, off) { // Append data to buffer var min = Math.min(this.buffer.length - this.bufferOff, data.length - off); for (var i = 0; i < min; i++) this.buffer[this.bufferOff + i] = data[off + i]; this.bufferOff += min; // Shift next return min; }; Cipher.prototype._flushBuffer = function _flushBuffer(out, off) { this._update(this.buffer, 0, out, off); this.bufferOff = 0; return this.blockSize; }; Cipher.prototype._updateEncrypt = function _updateEncrypt(data) { var inputOff = 0; var outputOff = 0; var count = ((this.bufferOff + data.length) / this.blockSize) | 0; var out = new Array(count * this.blockSize); if (this.bufferOff !== 0) { inputOff += this._buffer(data, inputOff); if (this.bufferOff === this.buffer.length) outputOff += this._flushBuffer(out, outputOff); } // Write blocks var max = data.length - ((data.length - inputOff) % this.blockSize); for (; inputOff < max; inputOff += this.blockSize) { this._update(data, inputOff, out, outputOff); outputOff += this.blockSize; } // Queue rest for (; inputOff < data.length; inputOff++, this.bufferOff++) this.buffer[this.bufferOff] = data[inputOff]; return out; }; Cipher.prototype._updateDecrypt = function _updateDecrypt(data) { var inputOff = 0; var outputOff = 0; var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1; var out = new Array(count * this.blockSize); // TODO(indutny): optimize it, this is far from optimal for (; count > 0; count--) { inputOff += this._buffer(data, inputOff); outputOff += this._flushBuffer(out, outputOff); } // Buffer rest of the input inputOff += this._buffer(data, inputOff); return out; }; Cipher.prototype.final = function final(buffer) { var first; if (buffer) first = this.update(buffer); var last; if (this.type === 'encrypt') last = this._finalEncrypt(); else last = this._finalDecrypt(); if (first) return first.concat(last); else return last; }; Cipher.prototype._pad = function _pad(buffer, off) { if (off === 0) return false; while (off < buffer.length) buffer[off++] = 0; return true; }; Cipher.prototype._finalEncrypt = function _finalEncrypt() { if (!this._pad(this.buffer, this.bufferOff)) return []; var out = new Array(this.blockSize); this._update(this.buffer, 0, out, 0); return out; }; Cipher.prototype._unpad = function _unpad(buffer) { return buffer; }; Cipher.prototype._finalDecrypt = function _finalDecrypt() { assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt'); var out = new Array(this.blockSize); this._flushBuffer(out, 0); return this._unpad(out); }; },{"minimalistic-assert":215}],91:[function(require,module,exports){ 'use strict'; var assert = require('minimalistic-assert'); var inherits = require('inherits'); var des = require('../des'); var utils = des.utils; var Cipher = des.Cipher; function DESState() { this.tmp = new Array(2); this.keys = null; } function DES(options) { Cipher.call(this, options); var state = new DESState(); this._desState = state; this.deriveKeys(state, options.key); } inherits(DES, Cipher); module.exports = DES; DES.create = function create(options) { return new DES(options); }; var shiftTable = [ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 ]; DES.prototype.deriveKeys = function deriveKeys(state, key) { state.keys = new Array(16 * 2); assert.equal(key.length, this.blockSize, 'Invalid key length'); var kL = utils.readUInt32BE(key, 0); var kR = utils.readUInt32BE(key, 4); utils.pc1(kL, kR, state.tmp, 0); kL = state.tmp[0]; kR = state.tmp[1]; for (var i = 0; i < state.keys.length; i += 2) { var shift = shiftTable[i >>> 1]; kL = utils.r28shl(kL, shift); kR = utils.r28shl(kR, shift); utils.pc2(kL, kR, state.keys, i); } }; DES.prototype._update = function _update(inp, inOff, out, outOff) { var state = this._desState; var l = utils.readUInt32BE(inp, inOff); var r = utils.readUInt32BE(inp, inOff + 4); // Initial Permutation utils.ip(l, r, state.tmp, 0); l = state.tmp[0]; r = state.tmp[1]; if (this.type === 'encrypt') this._encrypt(state, l, r, state.tmp, 0); else this._decrypt(state, l, r, state.tmp, 0); l = state.tmp[0]; r = state.tmp[1]; utils.writeUInt32BE(out, l, outOff); utils.writeUInt32BE(out, r, outOff + 4); }; DES.prototype._pad = function _pad(buffer, off) { var value = buffer.length - off; for (var i = off; i < buffer.length; i++) buffer[i] = value; return true; }; DES.prototype._unpad = function _unpad(buffer) { var pad = buffer[buffer.length - 1]; for (var i = buffer.length - pad; i < buffer.length; i++) assert.equal(buffer[i], pad); return buffer.slice(0, buffer.length - pad); }; DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) { var l = lStart; var r = rStart; // Apply f() x16 times for (var i = 0; i < state.keys.length; i += 2) { var keyL = state.keys[i]; var keyR = state.keys[i + 1]; // f(r, k) utils.expand(r, state.tmp, 0); keyL ^= state.tmp[0]; keyR ^= state.tmp[1]; var s = utils.substitute(keyL, keyR); var f = utils.permute(s); var t = r; r = (l ^ f) >>> 0; l = t; } // Reverse Initial Permutation utils.rip(r, l, out, off); }; DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) { var l = rStart; var r = lStart; // Apply f() x16 times for (var i = state.keys.length - 2; i >= 0; i -= 2) { var keyL = state.keys[i]; var keyR = state.keys[i + 1]; // f(r, k) utils.expand(l, state.tmp, 0); keyL ^= state.tmp[0]; keyR ^= state.tmp[1]; var s = utils.substitute(keyL, keyR); var f = utils.permute(s); var t = l; l = (r ^ f) >>> 0; r = t; } // Reverse Initial Permutation utils.rip(l, r, out, off); }; },{"../des":88,"inherits":203,"minimalistic-assert":215}],92:[function(require,module,exports){ 'use strict'; var assert = require('minimalistic-assert'); var inherits = require('inherits'); var des = require('../des'); var Cipher = des.Cipher; var DES = des.DES; function EDEState(type, key) { assert.equal(key.length, 24, 'Invalid key length'); var k1 = key.slice(0, 8); var k2 = key.slice(8, 16); var k3 = key.slice(16, 24); if (type === 'encrypt') { this.ciphers = [ DES.create({ type: 'encrypt', key: k1 }), DES.create({ type: 'decrypt', key: k2 }), DES.create({ type: 'encrypt', key: k3 }) ]; } else { this.ciphers = [ DES.create({ type: 'decrypt', key: k3 }), DES.create({ type: 'encrypt', key: k2 }), DES.create({ type: 'decrypt', key: k1 }) ]; } } function EDE(options) { Cipher.call(this, options); var state = new EDEState(this.type, this.options.key); this._edeState = state; } inherits(EDE, Cipher); module.exports = EDE; EDE.create = function create(options) { return new EDE(options); }; EDE.prototype._update = function _update(inp, inOff, out, outOff) { var state = this._edeState; state.ciphers[0]._update(inp, inOff, out, outOff); state.ciphers[1]._update(out, outOff, out, outOff); state.ciphers[2]._update(out, outOff, out, outOff); }; EDE.prototype._pad = DES.prototype._pad; EDE.prototype._unpad = DES.prototype._unpad; },{"../des":88,"inherits":203,"minimalistic-assert":215}],93:[function(require,module,exports){ 'use strict'; exports.readUInt32BE = function readUInt32BE(bytes, off) { var res = (bytes[0 + off] << 24) | (bytes[1 + off] << 16) | (bytes[2 + off] << 8) | bytes[3 + off]; return res >>> 0; }; exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) { bytes[0 + off] = value >>> 24; bytes[1 + off] = (value >>> 16) & 0xff; bytes[2 + off] = (value >>> 8) & 0xff; bytes[3 + off] = value & 0xff; }; exports.ip = function ip(inL, inR, out, off) { var outL = 0; var outR = 0; for (var i = 6; i >= 0; i -= 2) { for (var j = 0; j <= 24; j += 8) { outL <<= 1; outL |= (inR >>> (j + i)) & 1; } for (var j = 0; j <= 24; j += 8) { outL <<= 1; outL |= (inL >>> (j + i)) & 1; } } for (var i = 6; i >= 0; i -= 2) { for (var j = 1; j <= 25; j += 8) { outR <<= 1; outR |= (inR >>> (j + i)) & 1; } for (var j = 1; j <= 25; j += 8) { outR <<= 1; outR |= (inL >>> (j + i)) & 1; } } out[off + 0] = outL >>> 0; out[off + 1] = outR >>> 0; }; exports.rip = function rip(inL, inR, out, off) { var outL = 0; var outR = 0; for (var i = 0; i < 4; i++) { for (var j = 24; j >= 0; j -= 8) { outL <<= 1; outL |= (inR >>> (j + i)) & 1; outL <<= 1; outL |= (inL >>> (j + i)) & 1; } } for (var i = 4; i < 8; i++) { for (var j = 24; j >= 0; j -= 8) { outR <<= 1; outR |= (inR >>> (j + i)) & 1; outR <<= 1; outR |= (inL >>> (j + i)) & 1; } } out[off + 0] = outL >>> 0; out[off + 1] = outR >>> 0; }; exports.pc1 = function pc1(inL, inR, out, off) { var outL = 0; var outR = 0; // 7, 15, 23, 31, 39, 47, 55, 63 // 6, 14, 22, 30, 39, 47, 55, 63 // 5, 13, 21, 29, 39, 47, 55, 63 // 4, 12, 20, 28 for (var i = 7; i >= 5; i--) { for (var j = 0; j <= 24; j += 8) { outL <<= 1; outL |= (inR >> (j + i)) & 1; } for (var j = 0; j <= 24; j += 8) { outL <<= 1; outL |= (inL >> (j + i)) & 1; } } for (var j = 0; j <= 24; j += 8) { outL <<= 1; outL |= (inR >> (j + i)) & 1; } // 1, 9, 17, 25, 33, 41, 49, 57 // 2, 10, 18, 26, 34, 42, 50, 58 // 3, 11, 19, 27, 35, 43, 51, 59 // 36, 44, 52, 60 for (var i = 1; i <= 3; i++) { for (var j = 0; j <= 24; j += 8) { outR <<= 1; outR |= (inR >> (j + i)) & 1; } for (var j = 0; j <= 24; j += 8) { outR <<= 1; outR |= (inL >> (j + i)) & 1; } } for (var j = 0; j <= 24; j += 8) { outR <<= 1; outR |= (inL >> (j + i)) & 1; } out[off + 0] = outL >>> 0; out[off + 1] = outR >>> 0; }; exports.r28shl = function r28shl(num, shift) { return ((num << shift) & 0xfffffff) | (num >>> (28 - shift)); }; var pc2table = [ // inL => outL 14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, // inR => outR 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24 ]; exports.pc2 = function pc2(inL, inR, out, off) { var outL = 0; var outR = 0; var len = pc2table.length >>> 1; for (var i = 0; i < len; i++) { outL <<= 1; outL |= (inL >>> pc2table[i]) & 0x1; } for (var i = len; i < pc2table.length; i++) { outR <<= 1; outR |= (inR >>> pc2table[i]) & 0x1; } out[off + 0] = outL >>> 0; out[off + 1] = outR >>> 0; }; exports.expand = function expand(r, out, off) { var outL = 0; var outR = 0; outL = ((r & 1) << 5) | (r >>> 27); for (var i = 23; i >= 15; i -= 4) { outL <<= 6; outL |= (r >>> i) & 0x3f; } for (var i = 11; i >= 3; i -= 4) { outR |= (r >>> i) & 0x3f; outR <<= 6; } outR |= ((r & 0x1f) << 1) | (r >>> 31); out[off + 0] = outL >>> 0; out[off + 1] = outR >>> 0; }; var sTable = [ 14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11 ]; exports.substitute = function substitute(inL, inR) { var out = 0; for (var i = 0; i < 4; i++) { var b = (inL >>> (18 - i * 6)) & 0x3f; var sb = sTable[i * 0x40 + b]; out <<= 4; out |= sb; } for (var i = 0; i < 4; i++) { var b = (inR >>> (18 - i * 6)) & 0x3f; var sb = sTable[4 * 0x40 + i * 0x40 + b]; out <<= 4; out |= sb; } return out >>> 0; }; var permuteTable = [ 16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7 ]; exports.permute = function permute(num) { var out = 0; for (var i = 0; i < permuteTable.length; i++) { out <<= 1; out |= (num >>> permuteTable[i]) & 0x1; } return out >>> 0; }; exports.padSplit = function padSplit(num, size, group) { var str = num.toString(2); while (str.length < size) str = '0' + str; var out = []; for (var i = 0; i < size; i += group) out.push(str.slice(i, i + group)); return out.join(' '); }; },{}],94:[function(require,module,exports){ (function (Buffer){ var generatePrime = require('./lib/generatePrime') var primes = require('./lib/primes.json') var DH = require('./lib/dh') function getDiffieHellman (mod) { var prime = new Buffer(primes[mod].prime, 'hex') var gen = new Buffer(primes[mod].gen, 'hex') return new DH(prime, gen) } var ENCODINGS = { 'binary': true, 'hex': true, 'base64': true } function createDiffieHellman (prime, enc, generator, genc) { if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) { return createDiffieHellman(prime, 'binary', enc, generator) } enc = enc || 'binary' genc = genc || 'binary' generator = generator || new Buffer([2]) if (!Buffer.isBuffer(generator)) { generator = new Buffer(generator, genc) } if (typeof prime === 'number') { return new DH(generatePrime(prime, generator), generator, true) } if (!Buffer.isBuffer(prime)) { prime = new Buffer(prime, enc) } return new DH(prime, generator, true) } exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman }).call(this,require("buffer").Buffer) },{"./lib/dh":95,"./lib/generatePrime":96,"./lib/primes.json":97,"buffer":75}],95:[function(require,module,exports){ (function (Buffer){ var BN = require('bn.js'); var MillerRabin = require('miller-rabin'); var millerRabin = new MillerRabin(); var TWENTYFOUR = new BN(24); var ELEVEN = new BN(11); var TEN = new BN(10); var THREE = new BN(3); var SEVEN = new BN(7); var primes = require('./generatePrime'); var randomBytes = require('randombytes'); module.exports = DH; function setPublicKey(pub, enc) { enc = enc || 'utf8'; if (!Buffer.isBuffer(pub)) { pub = new Buffer(pub, enc); } this._pub = new BN(pub); return this; } function setPrivateKey(priv, enc) { enc = enc || 'utf8'; if (!Buffer.isBuffer(priv)) { priv = new Buffer(priv, enc); } this._priv = new BN(priv); return this; } var primeCache = {}; function checkPrime(prime, generator) { var gen = generator.toString('hex'); var hex = [gen, prime.toString(16)].join('_'); if (hex in primeCache) { return primeCache[hex]; } var error = 0; if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) { //not a prime so +1 error += 1; if (gen === '02' || gen === '05') { // we'd be able to check the generator // it would fail so +8 error += 8; } else { //we wouldn't be able to test the generator // so +4 error += 4; } primeCache[hex] = error; return error; } if (!millerRabin.test(prime.shrn(1))) { //not a safe prime error += 2; } var rem; switch (gen) { case '02': if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) { // unsuidable generator error += 8; } break; case '05': rem = prime.mod(TEN); if (rem.cmp(THREE) && rem.cmp(SEVEN)) { // prime mod 10 needs to equal 3 or 7 error += 8; } break; default: error += 4; } primeCache[hex] = error; return error; } function DH(prime, generator, malleable) { this.setGenerator(generator); this.__prime = new BN(prime); this._prime = BN.mont(this.__prime); this._primeLen = prime.length; this._pub = undefined; this._priv = undefined; this._primeCode = undefined; if (malleable) { this.setPublicKey = setPublicKey; this.setPrivateKey = setPrivateKey; } else { this._primeCode = 8; } } Object.defineProperty(DH.prototype, 'verifyError', { enumerable: true, get: function () { if (typeof this._primeCode !== 'number') { this._primeCode = checkPrime(this.__prime, this.__gen); } return this._primeCode; } }); DH.prototype.generateKeys = function () { if (!this._priv) { this._priv = new BN(randomBytes(this._primeLen)); } this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(); return this.getPublicKey(); }; DH.prototype.computeSecret = function (other) { other = new BN(other); other = other.toRed(this._prime); var secret = other.redPow(this._priv).fromRed(); var out = new Buffer(secret.toArray()); var prime = this.getPrime(); if (out.length < prime.length) { var front = new Buffer(prime.length - out.length); front.fill(0); out = Buffer.concat([front, out]); } return out; }; DH.prototype.getPublicKey = function getPublicKey(enc) { return formatReturnValue(this._pub, enc); }; DH.prototype.getPrivateKey = function getPrivateKey(enc) { return formatReturnValue(this._priv, enc); }; DH.prototype.getPrime = function (enc) { return formatReturnValue(this.__prime, enc); }; DH.prototype.getGenerator = function (enc) { return formatReturnValue(this._gen, enc); }; DH.prototype.setGenerator = function (gen, enc) { enc = enc || 'utf8'; if (!Buffer.isBuffer(gen)) { gen = new Buffer(gen, enc); } this.__gen = gen; this._gen = new BN(gen); return this; }; function formatReturnValue(bn, enc) { var buf = new Buffer(bn.toArray()); if (!enc) { return buf; } else { return buf.toString(enc); } } }).call(this,require("buffer").Buffer) },{"./generatePrime":96,"bn.js":41,"buffer":75,"miller-rabin":214,"randombytes":246}],96:[function(require,module,exports){ var randomBytes = require('randombytes'); module.exports = findPrime; findPrime.simpleSieve = simpleSieve; findPrime.fermatTest = fermatTest; var BN = require('bn.js'); var TWENTYFOUR = new BN(24); var MillerRabin = require('miller-rabin'); var millerRabin = new MillerRabin(); var ONE = new BN(1); var TWO = new BN(2); var FIVE = new BN(5); var SIXTEEN = new BN(16); var EIGHT = new BN(8); var TEN = new BN(10); var THREE = new BN(3); var SEVEN = new BN(7); var ELEVEN = new BN(11); var FOUR = new BN(4); var TWELVE = new BN(12); var primes = null; function _getPrimes() { if (primes !== null) return primes; var limit = 0x100000; var res = []; res[0] = 2; for (var i = 1, k = 3; k < limit; k += 2) { var sqrt = Math.ceil(Math.sqrt(k)); for (var j = 0; j < i && res[j] <= sqrt; j++) if (k % res[j] === 0) break; if (i !== j && res[j] <= sqrt) continue; res[i++] = k; } primes = res; return res; } function simpleSieve(p) { var primes = _getPrimes(); for (var i = 0; i < primes.length; i++) if (p.modn(primes[i]) === 0) { if (p.cmpn(primes[i]) === 0) { return true; } else { return false; } } return true; } function fermatTest(p) { var red = BN.mont(p); return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0; } function findPrime(bits, gen) { if (bits < 16) { // this is what openssl does if (gen === 2 || gen === 5) { return new BN([0x8c, 0x7b]); } else { return new BN([0x8c, 0x27]); } } gen = new BN(gen); var num, n2; while (true) { num = new BN(randomBytes(Math.ceil(bits / 8))); while (num.bitLength() > bits) { num.ishrn(1); } if (num.isEven()) { num.iadd(ONE); } if (!num.testn(1)) { num.iadd(TWO); } if (!gen.cmp(TWO)) { while (num.mod(TWENTYFOUR).cmp(ELEVEN)) { num.iadd(FOUR); } } else if (!gen.cmp(FIVE)) { while (num.mod(TEN).cmp(THREE)) { num.iadd(FOUR); } } n2 = num.shrn(1); if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) { return num; } } } },{"bn.js":41,"miller-rabin":214,"randombytes":246}],97:[function(require,module,exports){ module.exports={ "modp1": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, "modp2": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, "modp5": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, "modp14": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, "modp15": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, "modp16": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, "modp17": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, "modp18": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } } },{}],98:[function(require,module,exports){ (function (global,Buffer){ 'use strict'; var digibyte = module.exports; // module information digibyte.version = 'v' + require('./package.json').version; digibyte.versionGuard = function(version) { if (version !== undefined) { var message = 'More than one instance of digibyte found. ' + 'Please make sure to require digibyte and check that submodules do' + ' not also include their own digibyte dependency.'; throw new Error(message); } }; digibyte.versionGuard(global._digibyte); global._digibyte = digibyte.version; // crypto digibyte.crypto = {}; digibyte.crypto.BN = require('./lib/crypto/bn'); digibyte.crypto.ECDSA = require('./lib/crypto/ecdsa'); digibyte.crypto.Hash = require('./lib/crypto/hash'); digibyte.crypto.Random = require('./lib/crypto/random'); digibyte.crypto.Point = require('./lib/crypto/point'); digibyte.crypto.Signature = require('./lib/crypto/signature'); // encoding digibyte.encoding = {}; digibyte.encoding.Base58 = require('./lib/encoding/base58'); digibyte.encoding.Base58Check = require('./lib/encoding/base58check'); digibyte.encoding.BufferReader = require('./lib/encoding/bufferreader'); digibyte.encoding.BufferWriter = require('./lib/encoding/bufferwriter'); digibyte.encoding.Varint = require('./lib/encoding/varint'); // utilities digibyte.util = {}; digibyte.util.buffer = require('./lib/util/buffer'); digibyte.util.js = require('./lib/util/js'); digibyte.util.preconditions = require('./lib/util/preconditions'); // errors thrown by the library digibyte.errors = require('./lib/errors'); // main digibyte library digibyte.Address = require('./lib/address'); digibyte.Block = require('./lib/block'); digibyte.MerkleBlock = require('./lib/block/merkleblock'); digibyte.BlockHeader = require('./lib/block/blockheader'); digibyte.HDPrivateKey = require('./lib/hdprivatekey.js'); digibyte.HDPublicKey = require('./lib/hdpublickey.js'); digibyte.Networks = require('./lib/networks'); digibyte.Opcode = require('./lib/opcode'); digibyte.PrivateKey = require('./lib/privatekey'); digibyte.PublicKey = require('./lib/publickey'); digibyte.Script = require('./lib/script'); digibyte.Transaction = require('./lib/transaction'); digibyte.URI = require('./lib/uri'); digibyte.Unit = require('./lib/unit'); // dependencies, subject to change digibyte.deps = {}; digibyte.deps.bnjs = require('bn.js'); digibyte.deps.bs58 = require('bs58'); digibyte.deps.Buffer = Buffer; digibyte.deps.elliptic = require('elliptic'); digibyte.deps._ = require('lodash'); // Internal usage, exposed for testing/advanced tweaking digibyte.Transaction.sighash = require('./lib/transaction/sighash'); }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer) },{"./lib/address":99,"./lib/block":102,"./lib/block/blockheader":101,"./lib/block/merkleblock":103,"./lib/crypto/bn":104,"./lib/crypto/ecdsa":105,"./lib/crypto/hash":106,"./lib/crypto/point":107,"./lib/crypto/random":108,"./lib/crypto/signature":109,"./lib/encoding/base58":110,"./lib/encoding/base58check":111,"./lib/encoding/bufferreader":112,"./lib/encoding/bufferwriter":113,"./lib/encoding/varint":114,"./lib/errors":115,"./lib/hdprivatekey.js":117,"./lib/hdpublickey.js":118,"./lib/networks":119,"./lib/opcode":120,"./lib/privatekey":121,"./lib/publickey":122,"./lib/script":123,"./lib/transaction":126,"./lib/transaction/sighash":134,"./lib/unit":139,"./lib/uri":140,"./lib/util/buffer":141,"./lib/util/js":142,"./lib/util/preconditions":143,"./package.json":147,"bn.js":41,"bs58":144,"buffer":75,"elliptic":168,"lodash":146}],99:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var $ = require('./util/preconditions'); var errors = require('./errors'); var Base58Check = require('./encoding/base58check'); var Networks = require('./networks'); var Hash = require('./crypto/hash'); var JSUtil = require('./util/js'); var PublicKey = require('./publickey'); /** * Instantiate an address from an address String or Buffer, a public key or script hash Buffer, * or an instance of {@link PublicKey} or {@link Script}. * * This is an immutable class, and if the first parameter provided to this constructor is an * `Address` instance, the same argument will be returned. * * An address has two key properties: `network` and `type`. The type is either * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string) * or `Address.PayToScriptHash` (the string `'scripthash'`). The network is an instance of {@link Network}. * You can quickly check whether an address is of a given kind by using the methods * `isPayToPublicKeyHash` and `isPayToScriptHash` * * @example * ```javascript * // validate that an input field is valid * var error = Address.getValidationError(input, 'testnet'); * if (!error) { * var address = Address(input, 'testnet'); * } else { * // invalid network or checksum (typo?) * var message = error.messsage; * } * * // get an address from a public key * var address = Address(publicKey, 'testnet').toString(); * ``` * * @param {*} data - The encoded data in various formats * @param {Network|String|number=} network - The network: 'livenet' or 'testnet' * @param {string=} type - The type of address: 'script' or 'pubkey' * @returns {Address} A new valid and frozen instance of an Address * @constructor */ function Address(data, network, type) { /* jshint maxcomplexity: 12 */ /* jshint maxstatements: 20 */ if (!(this instanceof Address)) { return new Address(data, network, type); } if (_.isArray(data) && _.isNumber(network)) { return Address.createMultisig(data, network, type); } if (data instanceof Address) { // Immutable instance return data; } $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html'); if (network && !Networks.get(network)) { throw new TypeError('Second argument must be "livenet" or "testnet".'); } if (type && (type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash)) { throw new TypeError('Third argument must be "pubkeyhash" or "scripthash".'); } var info = this._classifyArguments(data, network, type); // set defaults if not set info.network = info.network || Networks.get(network) || Networks.defaultNetwork; info.type = info.type || type || Address.PayToPublicKeyHash; JSUtil.defineImmutable(this, { hashBuffer: info.hashBuffer, network: info.network, type: info.type }); return this; } /** * Internal function used to split different kinds of arguments of the constructor * @param {*} data - The encoded data in various formats * @param {Network|String|number=} network - The network: 'livenet' or 'testnet' * @param {string=} type - The type of address: 'script' or 'pubkey' * @returns {Object} An "info" object with "type", "network", and "hashBuffer" */ Address.prototype._classifyArguments = function(data, network, type) { /* jshint maxcomplexity: 10 */ // transform and validate input data if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) { return Address._transformHash(data); } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) { return Address._transformBuffer(data, network, type); } else if (data instanceof PublicKey) { return Address._transformPublicKey(data); } else if (data instanceof Script) { return Address._transformScript(data, network); } else if (typeof(data) === 'string') { return Address._transformString(data, network, type); } else if (_.isObject(data)) { return Address._transformObject(data); } else { throw new TypeError('First argument is an unrecognized data format.'); } }; /** @static */ Address.PayToPublicKeyHash = 'pubkeyhash'; /** @static */ Address.PayToScriptHash = 'scripthashTwo'; /** * @param {Buffer} hash - An instance of a hash Buffer * @returns {Object} An object with keys: hashBuffer * @private */ Address._transformHash = function(hash) { var info = {}; if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) { throw new TypeError('Address supplied is not a buffer.'); } if (hash.length !== 20) { throw new TypeError('Address hashbuffers must be exactly 20 bytes.'); } info.hashBuffer = hash; return info; }; /** * Deserializes an address serialized through `Address#toObject()` * @param {Object} data * @param {string} data.hash - the hash that this address encodes * @param {string} data.type - either 'pubkeyhash' or 'scripthash' * @param {Network=} data.network - the name of the network associated * @return {Address} */ Address._transformObject = function(data) { $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property'); $.checkArgument(data.type, 'Must provide a `type` property'); return { hashBuffer: data.hash ? new Buffer(data.hash, 'hex') : data.hashBuffer, network: Networks.get(data.network) || Networks.defaultNetwork, type: data.type }; }; /** * Internal function to discover the network and type based on the first data byte * * @param {Buffer} buffer - An instance of a hex encoded address Buffer * @returns {Object} An object with keys: network and type * @private */ Address._classifyFromVersion = function(buffer) { var version = {}; var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash'); var scripthashNetwork = Networks.get(buffer[0], 'scripthash'); var scripthashTwoNetwork = Networks.get(buffer[0], 'scripthashTwo'); if (pubkeyhashNetwork) { version.network = pubkeyhashNetwork; version.type = Address.PayToPublicKeyHash; } else if (scripthashNetwork || scripthashTwoNetwork) { version.network = scripthashNetwork || scripthashTwoNetwork; version.type = Address.PayToScriptHash; } return version; }; /** * Internal function to transform a bitcoin address buffer * * @param {Buffer} buffer - An instance of a hex encoded address Buffer * @param {string=} network - The network: 'livenet' or 'testnet' * @param {string=} type - The type: 'pubkeyhash' or 'scripthash' * @returns {Object} An object with keys: hashBuffer, network and type * @private */ Address._transformBuffer = function(buffer, network, type) { /* jshint maxcomplexity: 9 */ var info = {}; if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) { throw new TypeError('Address supplied is not a buffer.'); } if (buffer.length !== 1 + 20) { throw new TypeError('Address buffers must be exactly 21 bytes.'); } network = Networks.get(network); var bufferVersion = Address._classifyFromVersion(buffer); if (!bufferVersion.network || (network && network !== bufferVersion.network)) { throw new TypeError('Address has mismatched network type.'); } if (!bufferVersion.type || (type && type !== bufferVersion.type)) { throw new TypeError('Address has mismatched type.'); } info.hashBuffer = buffer.slice(1); info.network = bufferVersion.network; info.type = bufferVersion.type; return info; }; /** * Internal function to transform a {@link PublicKey} * * @param {PublicKey} pubkey - An instance of PublicKey * @returns {Object} An object with keys: hashBuffer, type * @private */ Address._transformPublicKey = function(pubkey) { var info = {}; if (!(pubkey instanceof PublicKey)) { throw new TypeError('Address must be an instance of PublicKey.'); } info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer()); info.type = Address.PayToPublicKeyHash; return info; }; /** * Internal function to transform a {@link Script} into a `info` object. * * @param {Script} script - An instance of Script * @returns {Object} An object with keys: hashBuffer, type * @private */ Address._transformScript = function(script, network) { $.checkArgument(script instanceof Script, 'script must be a Script instance'); var info = script.getAddressInfo(network); if (!info) { throw new errors.Script.CantDeriveAddress(script); } return info; }; /** * Creates a P2SH address from a set of public keys and a threshold. * * The addresses will be sorted lexicographically, as that is the trend in bitcoin. * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut} * interface. * * @param {Array} publicKeys - a set of public keys to create an address * @param {number} threshold - the number of signatures needed to release the funds * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet' * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness * @return {Address} */ Address.createMultisig = function(publicKeys, threshold, network, nestedWitness) { network = network || publicKeys[0].network || Networks.defaultNetwork; var redeemScript = Script.buildMultisigOut(publicKeys, threshold); if (nestedWitness) { return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network); } return Address.payingTo(redeemScript, network); }; /** * Internal function to transform a bitcoin address string * * @param {string} data * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet' * @param {string=} type - The type: 'pubkeyhash' or 'scripthash' * @returns {Object} An object with keys: hashBuffer, network and type * @private */ Address._transformString = function(data, network, type) { if (typeof(data) !== 'string') { throw new TypeError('data parameter supplied is not a string.'); } data = data.trim(); var addressBuffer = Base58Check.decode(data); var info = Address._transformBuffer(addressBuffer, network, type); return info; }; /** * Instantiate an address from a PublicKey instance * * @param {PublicKey} data * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet' * @returns {Address} A new valid and frozen instance of an Address */ Address.fromPublicKey = function(data, network) { var info = Address._transformPublicKey(data); network = network || Networks.defaultNetwork; return new Address(info.hashBuffer, network, info.type); }; /** * Instantiate an address from a ripemd160 public key hash * * @param {Buffer} hash - An instance of buffer of the hash * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet' * @returns {Address} A new valid and frozen instance of an Address */ Address.fromPublicKeyHash = function(hash, network) { var info = Address._transformHash(hash); return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash); }; /** * Instantiate an address from a ripemd160 script hash * * @param {Buffer} hash - An instance of buffer of the hash * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet' * @returns {Address} A new valid and frozen instance of an Address */ Address.fromScriptHash = function(hash, network) { $.checkArgument(hash, 'hash parameter is required'); var info = Address._transformHash(hash); return new Address(info.hashBuffer, network, Address.PayToScriptHash); }; /** * Builds a p2sh address paying to script. This will hash the script and * use that to create the address. * If you want to extract an address associated with a script instead, * see {{Address#fromScript}} * * @param {Script} script - An instance of Script * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet' * @returns {Address} A new valid and frozen instance of an Address */ Address.payingTo = function(script, network) { $.checkArgument(script, 'script is required'); $.checkArgument(script instanceof Script, 'script must be instance of Script'); return Address.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network); }; /** * Extract address from a Script. The script must be of one * of the following types: p2pkh input, p2pkh output, p2sh input * or p2sh output. * This will analyze the script and extract address information from it. * If you want to transform any script to a p2sh Address paying * to that script's hash instead, use {{Address#payingTo}} * * @param {Script} script - An instance of Script * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet' * @returns {Address} A new valid and frozen instance of an Address */ Address.fromScript = function(script, network) { $.checkArgument(script instanceof Script, 'script must be a Script instance'); var info = Address._transformScript(script, network); return new Address(info.hashBuffer, network, info.type); }; /** * Instantiate an address from a buffer of the address * * @param {Buffer} buffer - An instance of buffer of the address * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet' * @param {string=} type - The type of address: 'script' or 'pubkey' * @returns {Address} A new valid and frozen instance of an Address */ Address.fromBuffer = function(buffer, network, type) { var info = Address._transformBuffer(buffer, network, type); return new Address(info.hashBuffer, info.network, info.type); }; /** * Instantiate an address from an address string * * @param {string} str - An string of the bitcoin address * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet' * @param {string=} type - The type of address: 'script' or 'pubkey' * @returns {Address} A new valid and frozen instance of an Address */ Address.fromString = function(str, network, type) { var info = Address._transformString(str, network, type); return new Address(info.hashBuffer, info.network, info.type); }; /** * Instantiate an address from an Object * * @param {string} json - An JSON string or Object with keys: hash, network and type * @returns {Address} A new valid instance of an Address */ Address.fromObject = function fromObject(obj) { $.checkState( JSUtil.isHexa(obj.hash), 'Unexpected hash property, "' + obj.hash + '", expected to be hex.' ); var hashBuffer = new Buffer(obj.hash, 'hex'); return new Address(hashBuffer, obj.network, obj.type); }; /** * Will return a validation error if exists * * @example * ```javascript * // a network mismatch error * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet'); * ``` * * @param {string} data - The encoded data * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet' * @param {string} type - The type of address: 'script' or 'pubkey' * @returns {null|Error} The corresponding error message */ Address.getValidationError = function(data, network, type) { var error; try { /* jshint nonew: false */ new Address(data, network, type); } catch (e) { error = e; } return error; }; /** * Will return a boolean if an address is valid * * @example * ```javascript * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet')); * ``` * * @param {string} data - The encoded data * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet' * @param {string} type - The type of address: 'script' or 'pubkey' * @returns {boolean} The corresponding error message */ Address.isValid = function(data, network, type) { return !Address.getValidationError(data, network, type); }; /** * Returns true if an address is of pay to public key hash type * @return boolean */ Address.prototype.isPayToPublicKeyHash = function() { return this.type === Address.PayToPublicKeyHash; }; /** * Returns true if an address is of pay to script hash type * @return boolean */ Address.prototype.isPayToScriptHash = function() { return this.type === Address.PayToScriptHash; }; /** * Will return a buffer representation of the address * * @returns {Buffer} Bitcoin address buffer */ Address.prototype.toBuffer = function() { var version = new Buffer([this.network[this.type]]); var buf = Buffer.concat([version, this.hashBuffer]); return buf; }; /** * @returns {Object} A plain object with the address information */ Address.prototype.toObject = Address.prototype.toJSON = function toObject() { return { hash: this.hashBuffer.toString('hex'), type: this.type, network: this.network.toString() }; }; /** * Will return a the string representation of the address * * @returns {string} Bitcoin address */ Address.prototype.toString = function() { return Base58Check.encode(this.toBuffer()); }; /** * Will return a string formatted for the console * * @returns {string} Bitcoin address */ Address.prototype.inspect = function() { return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>'; }; module.exports = Address; var Script = require('./script'); }).call(this,require("buffer").Buffer) },{"./crypto/hash":106,"./encoding/base58check":111,"./errors":115,"./networks":119,"./publickey":122,"./script":123,"./util/js":142,"./util/preconditions":143,"buffer":75,"lodash":146}],100:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var BlockHeader = require('./blockheader'); var BN = require('../crypto/bn'); var BufferUtil = require('../util/buffer'); var BufferReader = require('../encoding/bufferreader'); var BufferWriter = require('../encoding/bufferwriter'); var Hash = require('../crypto/hash'); var Transaction = require('../transaction'); var $ = require('../util/preconditions'); /** * Instantiate a Block from a Buffer, JSON object, or Object with * the properties of the Block * * @param {*} - A Buffer, JSON string, or Object * @returns {Block} * @constructor */ function Block(arg) { if (!(this instanceof Block)) { return new Block(arg); } _.extend(this, Block._from(arg)); return this; } // https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14 Block.MAX_BLOCK_SIZE = 1000000; /** * @param {*} - A Buffer, JSON string or Object * @returns {Object} - An object representing block data * @throws {TypeError} - If the argument was not recognized * @private */ Block._from = function _from(arg) { var info = {}; if (BufferUtil.isBuffer(arg)) { info = Block._fromBufferReader(BufferReader(arg)); } else if (_.isObject(arg)) { info = Block._fromObject(arg); } else { throw new TypeError('Unrecognized argument for Block'); } return info; }; /** * @param {Object} - A plain JavaScript object * @returns {Object} - An object representing block data * @private */ Block._fromObject = function _fromObject(data) { var transactions = []; data.transactions.forEach(function(tx) { if (tx instanceof Transaction) { transactions.push(tx); } else { transactions.push(Transaction().fromObject(tx)); } }); var info = { header: BlockHeader.fromObject(data.header), transactions: transactions }; return info; }; /** * @param {Object} - A plain JavaScript object * @returns {Block} - An instance of block */ Block.fromObject = function fromObject(obj) { var info = Block._fromObject(obj); return new Block(info); }; /** * @param {BufferReader} - Block data * @returns {Object} - An object representing the block data * @private */ Block._fromBufferReader = function _fromBufferReader(br) { var info = {}; $.checkState(!br.finished(), 'No block data received'); info.header = BlockHeader.fromBufferReader(br); var transactions = br.readVarintNum(); info.transactions = []; for (var i = 0; i < transactions; i++) { info.transactions.push(Transaction().fromBufferReader(br)); } return info; }; /** * @param {BufferReader} - A buffer reader of the block * @returns {Block} - An instance of block */ Block.fromBufferReader = function fromBufferReader(br) { $.checkArgument(br, 'br is required'); var info = Block._fromBufferReader(br); return new Block(info); }; /** * @param {Buffer} - A buffer of the block * @returns {Block} - An instance of block */ Block.fromBuffer = function fromBuffer(buf) { return Block.fromBufferReader(new BufferReader(buf)); }; /** * @param {string} - str - A hex encoded string of the block * @returns {Block} - A hex encoded string of the block */ Block.fromString = function fromString(str) { var buf = new Buffer(str, 'hex'); return Block.fromBuffer(buf); }; /** * @param {Binary} - Raw block binary data or buffer * @returns {Block} - An instance of block */ Block.fromRawBlock = function fromRawBlock(data) { if (!BufferUtil.isBuffer(data)) { data = new Buffer(data, 'binary'); } var br = BufferReader(data); br.pos = Block.Values.START_OF_BLOCK; var info = Block._fromBufferReader(br); return new Block(info); }; /** * @returns {Object} - A plain object with the block properties */ Block.prototype.toObject = Block.prototype.toJSON = function toObject() { var transactions = []; this.transactions.forEach(function(tx) { transactions.push(tx.toObject()); }); return { header: this.header.toObject(), transactions: transactions }; }; /** * @returns {Buffer} - A buffer of the block */ Block.prototype.toBuffer = function toBuffer() { return this.toBufferWriter().concat(); }; /** * @returns {string} - A hex encoded string of the block */ Block.prototype.toString = function toString() { return this.toBuffer().toString('hex'); }; /** * @param {BufferWriter} - An existing instance of BufferWriter * @returns {BufferWriter} - An instance of BufferWriter representation of the Block */ Block.prototype.toBufferWriter = function toBufferWriter(bw) { if (!bw) { bw = new BufferWriter(); } bw.write(this.header.toBuffer()); bw.writeVarintNum(this.transactions.length); for (var i = 0; i < this.transactions.length; i++) { this.transactions[i].toBufferWriter(bw); } return bw; }; /** * Will iterate through each transaction and return an array of hashes * @returns {Array} - An array with transaction hashes */ Block.prototype.getTransactionHashes = function getTransactionHashes() { var hashes = []; if (this.transactions.length === 0) { return [Block.Values.NULL_HASH]; } for (var t = 0; t < this.transactions.length; t++) { hashes.push(this.transactions[t]._getHash()); } return hashes; }; /** * Will build a merkle tree of all the transactions, ultimately arriving at * a single point, the merkle root. * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees * @returns {Array} - An array with each level of the tree after the other. */ Block.prototype.getMerkleTree = function getMerkleTree() { var tree = this.getTransactionHashes(); var j = 0; for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) { for (var i = 0; i < size; i += 2) { var i2 = Math.min(i + 1, size - 1); var buf = Buffer.concat([tree[j + i], tree[j + i2]]); tree.push(Hash.sha256sha256(buf)); } j += size; } return tree; }; /** * Calculates the merkleRoot from the transactions. * @returns {Buffer} - A buffer of the merkle root hash */ Block.prototype.getMerkleRoot = function getMerkleRoot() { var tree = this.getMerkleTree(); return tree[tree.length - 1]; }; /** * Verifies that the transactions in the block match the header merkle root * @returns {Boolean} - If the merkle roots match */ Block.prototype.validMerkleRoot = function validMerkleRoot() { var h = new BN(this.header.merkleRoot.toString('hex'), 'hex'); var c = new BN(this.getMerkleRoot().toString('hex'), 'hex'); if (h.cmp(c) !== 0) { return false; } return true; }; /** * @returns {Buffer} - The little endian hash buffer of the header */ Block.prototype._getHash = function() { return this.header._getHash(); }; var idProperty = { configurable: false, enumerable: true, /** * @returns {string} - The big endian hash buffer of the header */ get: function() { if (!this._id) { this._id = this.header.id; } return this._id; }, set: _.noop }; Object.defineProperty(Block.prototype, 'id', idProperty); Object.defineProperty(Block.prototype, 'hash', idProperty); /** * @returns {string} - A string formatted for the console */ Block.prototype.inspect = function inspect() { return '<Block ' + this.id + '>'; }; Block.Values = { START_OF_BLOCK: 8, // Start of block in raw block data NULL_HASH: new Buffer('0000000000000000000000000000000000000000000000000000000000000000', 'hex') }; module.exports = Block; }).call(this,require("buffer").Buffer) },{"../crypto/bn":104,"../crypto/hash":106,"../encoding/bufferreader":112,"../encoding/bufferwriter":113,"../transaction":126,"../util/buffer":141,"../util/preconditions":143,"./blockheader":101,"buffer":75,"lodash":146}],101:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var BN = require('../crypto/bn'); var BufferUtil = require('../util/buffer'); var BufferReader = require('../encoding/bufferreader'); var BufferWriter = require('../encoding/bufferwriter'); var Hash = require('../crypto/hash'); var JSUtil = require('../util/js'); var $ = require('../util/preconditions'); var GENESIS_BITS = 0x1d00ffff; /** * Instantiate a BlockHeader from a Buffer, JSON object, or Object with * the properties of the BlockHeader * * @param {*} - A Buffer, JSON string, or Object * @returns {BlockHeader} - An instance of block header * @constructor */ var BlockHeader = function BlockHeader(arg) { if (!(this instanceof BlockHeader)) { return new BlockHeader(arg); } var info = BlockHeader._from(arg); this.version = info.version; this.prevHash = info.prevHash; this.merkleRoot = info.merkleRoot; this.time = info.time; this.timestamp = info.time; this.bits = info.bits; this.nonce = info.nonce; if (info.hash) { $.checkState( this.hash === info.hash, 'Argument object hash property does not match block hash.' ); } return this; }; /** * @param {*} - A Buffer, JSON string or Object * @returns {Object} - An object representing block header data * @throws {TypeError} - If the argument was not recognized * @private */ BlockHeader._from = function _from(arg) { var info = {}; if (BufferUtil.isBuffer(arg)) { info = BlockHeader._fromBufferReader(BufferReader(arg)); } else if (_.isObject(arg)) { info = BlockHeader._fromObject(arg); } else { throw new TypeError('Unrecognized argument for BlockHeader'); } return info; }; /** * @param {Object} - A JSON string * @returns {Object} - An object representing block header data * @private */ BlockHeader._fromObject = function _fromObject(data) { $.checkArgument(data, 'data is required'); var prevHash = data.prevHash; var merkleRoot = data.merkleRoot; if (_.isString(data.prevHash)) { prevHash = BufferUtil.reverse(new Buffer(data.prevHash, 'hex')); } if (_.isString(data.merkleRoot)) { merkleRoot = BufferUtil.reverse(new Buffer(data.merkleRoot, 'hex')); } var info = { hash: data.hash, version: data.version, prevHash: prevHash, merkleRoot: merkleRoot, time: data.time, timestamp: data.time, bits: data.bits, nonce: data.nonce }; return info; }; /** * @param {Object} - A plain JavaScript object * @returns {BlockHeader} - An instance of block header */ BlockHeader.fromObject = function fromObject(obj) { var info = BlockHeader._fromObject(obj); return new BlockHeader(info); }; /** * @param {Binary} - Raw block binary data or buffer * @returns {BlockHeader} - An instance of block header */ BlockHeader.fromRawBlock = function fromRawBlock(data) { if (!BufferUtil.isBuffer(data)) { data = new Buffer(data, 'binary'); } var br = BufferReader(data); br.pos = BlockHeader.Constants.START_OF_HEADER; var info = BlockHeader._fromBufferReader(br); return new BlockHeader(info); }; /** * @param {Buffer} - A buffer of the block header * @returns {BlockHeader} - An instance of block header */ BlockHeader.fromBuffer = function fromBuffer(buf) { var info = BlockHeader._fromBufferReader(BufferReader(buf)); return new BlockHeader(info); }; /** * @param {string} - A hex encoded buffer of the block header * @returns {BlockHeader} - An instance of block header */ BlockHeader.fromString = function fromString(str) { var buf = new Buffer(str, 'hex'); return BlockHeader.fromBuffer(buf); }; /** * @param {BufferReader} - A BufferReader of the block header * @returns {Object} - An object representing block header data * @private */ BlockHeader._fromBufferReader = function _fromBufferReader(br) { var info = {}; info.version = br.readInt32LE(); info.prevHash = br.read(32); info.merkleRoot = br.read(32); info.time = br.readUInt32LE(); info.bits = br.readUInt32LE(); info.nonce = br.readUInt32LE(); return info; }; /** * @param {BufferReader} - A BufferReader of the block header * @returns {BlockHeader} - An instance of block header */ BlockHeader.fromBufferReader = function fromBufferReader(br) { var info = BlockHeader._fromBufferReader(br); return new BlockHeader(info); }; /** * @returns {Object} - A plain object of the BlockHeader */ BlockHeader.prototype.toObject = BlockHeader.prototype.toJSON = function toObject() { return { hash: this.hash, version: this.version, prevHash: BufferUtil.reverse(this.prevHash).toString('hex'), merkleRoot: BufferUtil.reverse(this.merkleRoot).toString('hex'), time: this.time, bits: this.bits, nonce: this.nonce }; }; /** * @returns {Buffer} - A Buffer of the BlockHeader */ BlockHeader.prototype.toBuffer = function toBuffer() { return this.toBufferWriter().concat(); }; /** * @returns {string} - A hex encoded string of the BlockHeader */ BlockHeader.prototype.toString = function toString() { return this.toBuffer().toString('hex'); }; /** * @param {BufferWriter} - An existing instance BufferWriter * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader */ BlockHeader.prototype.toBufferWriter = function toBufferWriter(bw) { if (!bw) { bw = new BufferWriter(); } bw.writeInt32LE(this.version); bw.write(this.prevHash); bw.write(this.merkleRoot); bw.writeUInt32LE(this.time); bw.writeUInt32LE(this.bits); bw.writeUInt32LE(this.nonce); return bw; }; /** * Returns the target difficulty for this block * @param {Number} bits * @returns {BN} An instance of BN with the decoded difficulty bits */ BlockHeader.prototype.getTargetDifficulty = function getTargetDifficulty(bits) { bits = bits || this.bits; var target = new BN(bits & 0xffffff); var mov = 8 * ((bits >>> 24) - 3); while (mov-- > 0) { target = target.mul(new BN(2)); } return target; }; /** * @link https://en.bitcoin.it/wiki/Difficulty * @return {Number} */ BlockHeader.prototype.getDifficulty = function getDifficulty() { var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(Math.pow(10, 8))); var currentTargetBN = this.getTargetDifficulty(); var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10); var decimalPos = difficultyString.length - 8; difficultyString = difficultyString.slice(0, decimalPos) + '.' + difficultyString.slice(decimalPos); return parseFloat(difficultyString); }; /** * @returns {Buffer} - The little endian hash buffer of the header */ BlockHeader.prototype._getHash = function hash() { var buf = this.toBuffer(); return Hash.sha256sha256(buf); }; var idProperty = { configurable: false, enumerable: true, /** * @returns {string} - The big endian hash buffer of the header */ get: function() { if (!this._id) { this._id = BufferReader(this._getHash()).readReverse().toString('hex'); } return this._id; }, set: _.noop }; Object.defineProperty(BlockHeader.prototype, 'id', idProperty); Object.defineProperty(BlockHeader.prototype, 'hash', idProperty); /** * @returns {Boolean} - If timestamp is not too far in the future */ BlockHeader.prototype.validTimestamp = function validTimestamp() { var currentTime = Math.round(new Date().getTime() / 1000); if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) { return false; } return true; }; /** * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty */ BlockHeader.prototype.validProofOfWork = function validProofOfWork() { var pow = new BN(this.id, 'hex'); var target = this.getTargetDifficulty(); if (pow.cmp(target) > 0) { return false; } return true; }; /** * @returns {string} - A string formatted for the console */ BlockHeader.prototype.inspect = function inspect() { return '<BlockHeader ' + this.id + '>'; }; BlockHeader.Constants = { START_OF_HEADER: 8, // Start buffer position in raw block data MAX_TIME_OFFSET: 2 * 60 * 60, // The max a timestamp can be in the future LARGEST_HASH: new BN('10000000000000000000000000000000000000000000000000000000000000000', 'hex') }; module.exports = BlockHeader; }).call(this,require("buffer").Buffer) },{"../crypto/bn":104,"../crypto/hash":106,"../encoding/bufferreader":112,"../encoding/bufferwriter":113,"../util/buffer":141,"../util/js":142,"../util/preconditions":143,"buffer":75,"lodash":146}],102:[function(require,module,exports){ module.exports = require('./block'); module.exports.BlockHeader = require('./blockheader'); module.exports.MerkleBlock = require('./merkleblock'); },{"./block":100,"./blockheader":101,"./merkleblock":103}],103:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var BlockHeader = require('./blockheader'); var BufferUtil = require('../util/buffer'); var BufferReader = require('../encoding/bufferreader'); var BufferWriter = require('../encoding/bufferwriter'); var Hash = require('../crypto/hash'); var JSUtil = require('../util/js'); var Transaction = require('../transaction'); var $ = require('../util/preconditions'); /** * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with * the properties of the Block * * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock * @returns {MerkleBlock} * @constructor */ function MerkleBlock(arg) { /* jshint maxstatements: 18 */ if (!(this instanceof MerkleBlock)) { return new MerkleBlock(arg); } var info = {}; if (BufferUtil.isBuffer(arg)) { info = MerkleBlock._fromBufferReader(BufferReader(arg)); } else if (_.isObject(arg)) { var header; if(arg.header instanceof BlockHeader) { header = arg.header; } else { header = BlockHeader.fromObject(arg.header); } info = { /** * @name MerkleBlock#header * @type {BlockHeader} */ header: header, /** * @name MerkleBlock#numTransactions * @type {Number} */ numTransactions: arg.numTransactions, /** * @name MerkleBlock#hashes * @type {String[]} */ hashes: arg.hashes, /** * @name MerkleBlock#flags * @type {Number[]} */ flags: arg.flags }; } else { throw new TypeError('Unrecognized argument for MerkleBlock'); } _.extend(this,info); this._flagBitsUsed = 0; this._hashesUsed = 0; return this; } /** * @param {Buffer} - MerkleBlock data in a Buffer object * @returns {MerkleBlock} - A MerkleBlock object */ MerkleBlock.fromBuffer = function fromBuffer(buf) { return MerkleBlock.fromBufferReader(BufferReader(buf)); }; /** * @param {BufferReader} - MerkleBlock data in a BufferReader object * @returns {MerkleBlock} - A MerkleBlock object */ MerkleBlock.fromBufferReader = function fromBufferReader(br) { return new MerkleBlock(MerkleBlock._fromBufferReader(br)); }; /** * @returns {Buffer} - A buffer of the block */ MerkleBlock.prototype.toBuffer = function toBuffer() { return this.toBufferWriter().concat(); }; /** * @param {BufferWriter} - An existing instance of BufferWriter * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock */ MerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) { if (!bw) { bw = new BufferWriter(); } bw.write(this.header.toBuffer()); bw.writeUInt32LE(this.numTransactions); bw.writeVarintNum(this.hashes.length); for (var i = 0; i < this.hashes.length; i++) { bw.write(new Buffer(this.hashes[i], 'hex')); } bw.writeVarintNum(this.flags.length); for (i = 0; i < this.flags.length; i++) { bw.writeUInt8(this.flags[i]); } return bw; }; /** * @returns {Object} - A plain object with the MerkleBlock properties */ MerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() { return { header: this.header.toObject(), numTransactions: this.numTransactions, hashes: this.hashes, flags: this.flags }; }; /** * Verify that the MerkleBlock is valid * @returns {Boolean} - True/False whether this MerkleBlock is Valid */ MerkleBlock.prototype.validMerkleTree = function validMerkleTree() { $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array'); $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array'); // Can't have more hashes than numTransactions if(this.hashes.length > this.numTransactions) { return false; } // Can't have more flag bits than num hashes if(this.flags.length * 8 < this.hashes.length) { return false; } var height = this._calcTreeHeight(); var opts = { hashesUsed: 0, flagBitsUsed: 0 }; var root = this._traverseMerkleTree(height, 0, opts); if(opts.hashesUsed !== this.hashes.length) { return false; } return BufferUtil.equals(root, this.header.merkleRoot); }; /** * Traverse a the tree in this MerkleBlock, validating it along the way * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract() * @param {Number} - depth - Current height * @param {Number} - pos - Current position in the tree * @param {Object} - opts - Object with values that need to be mutated throughout the traversal * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0 * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0 * @param {Array} - opts.txs - Will finish populated by transactions found during traversal * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height * @private */ MerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts) { /* jshint maxcomplexity: 12*/ /* jshint maxstatements: 20 */ opts = opts || {}; opts.txs = opts.txs || []; opts.flagBitsUsed = opts.flagBitsUsed || 0; opts.hashesUsed = opts.hashesUsed || 0; if(opts.flagBitsUsed > this.flags.length * 8) { return null; } var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1; if(depth === 0 || !isParentOfMatch) { if(opts.hashesUsed >= this.hashes.length) { return null; } var hash = this.hashes[opts.hashesUsed++]; if(depth === 0 && isParentOfMatch) { opts.txs.push(hash); } return new Buffer(hash, 'hex'); } else { var left = this._traverseMerkleTree(depth-1, pos*2, opts); var right = left; if(pos*2+1 < this._calcTreeWidth(depth-1)) { right = this._traverseMerkleTree(depth-1, pos*2+1, opts); } return Hash.sha256sha256(new Buffer.concat([left, right])); } }; /** Calculates the width of a merkle tree at a given height. * Modeled after Bitcoin Core merkleblock.h CalcTreeWidth() * @param {Number} - Height at which we want the tree width * @returns {Number} - Width of the tree at a given height * @private */ MerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) { return (this.numTransactions + (1 << height) - 1) >> height; }; /** Calculates the height of the merkle tree in this MerkleBlock * @param {Number} - Height at which we want the tree width * @returns {Number} - Height of the merkle tree in this MerkleBlock * @private */ MerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() { var height = 0; while (this._calcTreeWidth(height) > 1) { height++; } return height; }; /** * @param {Transaction|String} - Transaction or Transaction ID Hash * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not * @private */ MerkleBlock.prototype.hasTransaction = function hasTransaction(tx) { $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined'); $.checkArgument(tx instanceof Transaction || typeof tx === 'string', 'Invalid tx given, tx must be a "string" or "Transaction"'); var hash = tx; if(tx instanceof Transaction) { // We need to reverse the id hash for the lookup hash = BufferUtil.reverse(new Buffer(tx.id, 'hex')).toString('hex'); } var txs = []; var height = this._calcTreeHeight(); this._traverseMerkleTree(height, 0, { txs: txs }); return txs.indexOf(hash) !== -1; }; /** * @param {Buffer} - MerkleBlock data * @returns {Object} - An Object representing merkleblock data * @private */ MerkleBlock._fromBufferReader = function _fromBufferReader(br) { $.checkState(!br.finished(), 'No merkleblock data received'); var info = {}; info.header = BlockHeader.fromBufferReader(br); info.numTransactions = br.readUInt32LE(); var numHashes = br.readVarintNum(); info.hashes = []; for (var i = 0; i < numHashes; i++) { info.hashes.push(br.read(32).toString('hex')); } var numFlags = br.readVarintNum(); info.flags = []; for (i = 0; i < numFlags; i++) { info.flags.push(br.readUInt8()); } return info; }; /** * @param {Object} - A plain JavaScript object * @returns {Block} - An instance of block */ MerkleBlock.fromObject = function fromObject(obj) { return new MerkleBlock(obj); }; module.exports = MerkleBlock; }).call(this,require("buffer").Buffer) },{"../crypto/hash":106,"../encoding/bufferreader":112,"../encoding/bufferwriter":113,"../transaction":126,"../util/buffer":141,"../util/js":142,"../util/preconditions":143,"./blockheader":101,"buffer":75,"lodash":146}],104:[function(require,module,exports){ (function (Buffer){ 'use strict'; var BN = require('bn.js'); var $ = require('../util/preconditions'); var _ = require('lodash'); var reversebuf = function(buf) { var buf2 = new Buffer(buf.length); for (var i = 0; i < buf.length; i++) { buf2[i] = buf[buf.length - 1 - i]; } return buf2; }; BN.Zero = new BN(0); BN.One = new BN(1); BN.Minus1 = new BN(-1); BN.fromNumber = function(n) { $.checkArgument(_.isNumber(n)); return new BN(n); }; BN.fromString = function(str, base) { $.checkArgument(_.isString(str)); return new BN(str, base); }; BN.fromBuffer = function(buf, opts) { if (typeof opts !== 'undefined' && opts.endian === 'little') { buf = reversebuf(buf); } var hex = buf.toString('hex'); var bn = new BN(hex, 16); return bn; }; /** * Instantiate a BigNumber from a "signed magnitude buffer" * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative)) */ BN.fromSM = function(buf, opts) { var ret; if (buf.length === 0) { return BN.fromBuffer(new Buffer([0])); } var endian = 'big'; if (opts) { endian = opts.endian; } if (endian === 'little') { buf = reversebuf(buf); } if (buf[0] & 0x80) { buf[0] = buf[0] & 0x7f; ret = BN.fromBuffer(buf); ret.neg().copy(ret); } else { ret = BN.fromBuffer(buf); } return ret; }; BN.prototype.toNumber = function() { return parseInt(this.toString(10), 10); }; BN.prototype.toBuffer = function(opts) { var buf, hex; if (opts && opts.size) { hex = this.toString(16, 2); var natlen = hex.length / 2; buf = new Buffer(hex, 'hex'); if (natlen === opts.size) { buf = buf; } else if (natlen > opts.size) { buf = BN.trim(buf, natlen); } else if (natlen < opts.size) { buf = BN.pad(buf, natlen, opts.size); } } else { hex = this.toString(16, 2); buf = new Buffer(hex, 'hex'); } if (typeof opts !== 'undefined' && opts.endian === 'little') { buf = reversebuf(buf); } return buf; }; BN.prototype.toSMBigEndian = function() { var buf; if (this.cmp(BN.Zero) === -1) { buf = this.neg().toBuffer(); if (buf[0] & 0x80) { buf = Buffer.concat([new Buffer([0x80]), buf]); } else { buf[0] = buf[0] | 0x80; } } else { buf = this.toBuffer(); if (buf[0] & 0x80) { buf = Buffer.concat([new Buffer([0x00]), buf]); } } if (buf.length === 1 & buf[0] === 0) { buf = new Buffer([]); } return buf; }; BN.prototype.toSM = function(opts) { var endian = opts ? opts.endian : 'big'; var buf = this.toSMBigEndian(); if (endian === 'little') { buf = reversebuf(buf); } return buf; }; /** * Create a BN from a "ScriptNum": * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in * bitcoind's script interpreter use CScriptNum, which is not really a proper * bignum. Instead, an error is thrown if trying to input a number bigger than * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to * extend the hard limit of 4 bytes, as some usages require more than 4 bytes. */ BN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) { var nMaxNumSize = size || 4; $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow')); if (fRequireMinimal && buf.length > 0) { // Check that the number is encoded with the minimum possible // number of bytes. // // If the most-significant-byte - excluding the sign bit - is zero // then we're not minimal. Note how this test also rejects the // negative-zero encoding, 0x80. if ((buf[buf.length - 1] & 0x7f) === 0) { // One exception: if there's more than one byte and the most // significant bit of the second-most-significant-byte is set // it would conflict with the sign bit. An example of this case // is +-255, which encode to 0xff00 and 0xff80 respectively. // (big-endian). if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) { throw new Error('non-minimally encoded script number'); } } } return BN.fromSM(buf, { endian: 'little' }); }; /** * The corollary to the above, with the notable exception that we do not throw * an error if the output is larger than four bytes. (Which can happen if * performing a numerical operation that results in an overflow to more than 4 * bytes). */ BN.prototype.toScriptNumBuffer = function() { return this.toSM({ endian: 'little' }); }; BN.prototype.gt = function(b) { return this.cmp(b) > 0; }; BN.prototype.gte = function(b) { return this.cmp(b) >= 0; }; BN.prototype.lt = function(b) { return this.cmp(b) < 0; }; BN.trim = function(buf, natlen) { return buf.slice(natlen - buf.length, buf.length); }; BN.pad = function(buf, natlen, size) { var rbuf = new Buffer(size); for (var i = 0; i < buf.length; i++) { rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i]; } for (i = 0; i < size - natlen; i++) { rbuf[i] = 0; } return rbuf; }; module.exports = BN; }).call(this,require("buffer").Buffer) },{"../util/preconditions":143,"bn.js":41,"buffer":75,"lodash":146}],105:[function(require,module,exports){ (function (Buffer){ 'use strict'; var BN = require('./bn'); var Point = require('./point'); var Signature = require('./signature'); var PublicKey = require('../publickey'); var Random = require('./random'); var Hash = require('./hash'); var BufferUtil = require('../util/buffer'); var _ = require('lodash'); var $ = require('../util/preconditions'); var ECDSA = function ECDSA(obj) { if (!(this instanceof ECDSA)) { return new ECDSA(obj); } if (obj) { this.set(obj); } }; /* jshint maxcomplexity: 9 */ ECDSA.prototype.set = function(obj) { this.hashbuf = obj.hashbuf || this.hashbuf; this.endian = obj.endian || this.endian; //the endianness of hashbuf this.privkey = obj.privkey || this.privkey; this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey); this.sig = obj.sig || this.sig; this.k = obj.k || this.k; this.verified = obj.verified || this.verified; return this; }; ECDSA.prototype.privkey2pubkey = function() { this.pubkey = this.privkey.toPublicKey(); }; ECDSA.prototype.calci = function() { for (var i = 0; i < 4; i++) { this.sig.i = i; var Qprime; try { Qprime = this.toPublicKey(); } catch (e) { console.error(e); continue; } if (Qprime.point.eq(this.pubkey.point)) { this.sig.compressed = this.pubkey.compressed; return this; } } this.sig.i = undefined; throw new Error('Unable to find valid recovery factor'); }; ECDSA.fromString = function(str) { var obj = JSON.parse(str); return new ECDSA(obj); }; ECDSA.prototype.randomK = function() { var N = Point.getN(); var k; do { k = BN.fromBuffer(Random.getRandomBuffer(32)); } while (!(k.lt(N) && k.gt(BN.Zero))); this.k = k; return this; }; // https://tools.ietf.org/html/rfc6979#section-3.2 ECDSA.prototype.deterministicK = function(badrs) { /* jshint maxstatements: 25 */ // if r or s were invalid when this function was used in signing, // we do not want to actually compute r, s here for efficiency, so, // we can increment badrs. explained at end of RFC 6979 section 3.2 if (_.isUndefined(badrs)) { badrs = 0; } var v = new Buffer(32); v.fill(0x01); var k = new Buffer(32); k.fill(0x00); var x = this.privkey.bn.toBuffer({ size: 32 }); var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00]), x, hashbuf]), k); v = Hash.sha256hmac(v, k); k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x01]), x, hashbuf]), k); v = Hash.sha256hmac(v, k); v = Hash.sha256hmac(v, k); var T = BN.fromBuffer(v); var N = Point.getN(); // also explained in 3.2, we must ensure T is in the proper range (0, N) for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) { k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00])]), k); v = Hash.sha256hmac(v, k); v = Hash.sha256hmac(v, k); T = BN.fromBuffer(v); } this.k = T; return this; }; // Information about public key recovery: // https://bitcointalk.org/index.php?topic=6430.0 // http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k ECDSA.prototype.toPublicKey = function() { /* jshint maxstatements: 25 */ var i = this.sig.i; $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3')); var e = BN.fromBuffer(this.hashbuf); var r = this.sig.r; var s = this.sig.s; // A set LSB signifies that the y-coordinate is odd var isYOdd = i & 1; // The more significant bit specifies whether we should use the // first or second candidate key. var isSecondKey = i >> 1; var n = Point.getN(); var G = Point.getG(); // 1.1 Let x = r + jn var x = isSecondKey ? r.add(n) : r; var R = Point.fromX(isYOdd, x); // 1.4 Check that nR is at infinity var nR = R.mul(n); if (!nR.isInfinity()) { throw new Error('nR is not a valid curve point'); } // Compute -e from e var eNeg = e.neg().umod(n); // 1.6.1 Compute Q = r^-1 (sR - eG) // Q = r^-1 (sR + -eG) var rInv = r.invm(n); //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv); var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv); var pubkey = PublicKey.fromPoint(Q, this.sig.compressed); return pubkey; }; ECDSA.prototype.sigError = function() { /* jshint maxstatements: 25 */ if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) { return 'hashbuf must be a 32 byte buffer'; } var r = this.sig.r; var s = this.sig.s; if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) { return 'r and s not in range'; } var e = BN.fromBuffer(this.hashbuf, this.endian ? { endian: this.endian } : undefined); var n = Point.getN(); var sinv = s.invm(n); var u1 = sinv.mul(e).umod(n); var u2 = sinv.mul(r).umod(n); var p = Point.getG().mulAdd(u1, this.pubkey.point, u2); if (p.isInfinity()) { return 'p is infinity'; } if (p.getX().umod(n).cmp(r) !== 0) { return 'Invalid signature'; } else { return false; } }; ECDSA.toLowS = function(s) { //enforce low s //see BIP 62, "low S values in signatures" if (s.gt(BN.fromBuffer(new Buffer('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) { s = Point.getN().sub(s); } return s; }; ECDSA.prototype._findSignature = function(d, e) { var N = Point.getN(); var G = Point.getG(); // try different values of k until r, s are valid var badrs = 0; var k, Q, r, s; do { if (!this.k || badrs > 0) { this.deterministicK(badrs); } badrs++; k = this.k; Q = G.mul(k); r = Q.x.umod(N); s = k.invm(N).mul(e.add(d.mul(r))).umod(N); } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0); s = ECDSA.toLowS(s); return { s: s, r: r }; }; ECDSA.prototype.sign = function() { var hashbuf = this.hashbuf; var privkey = this.privkey; var d = privkey.bn; $.checkState(hashbuf && privkey && d, new Error('invalid parameters')); $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer')); var e = BN.fromBuffer(hashbuf, this.endian ? { endian: this.endian } : undefined); var obj = this._findSignature(d, e); obj.compressed = this.pubkey.compressed; this.sig = new Signature(obj); return this; }; ECDSA.prototype.signRandomK = function() { this.randomK(); return this.sign(); }; ECDSA.prototype.toString = function() { var obj = {}; if (this.hashbuf) { obj.hashbuf = this.hashbuf.toString('hex'); } if (this.privkey) { obj.privkey = this.privkey.toString(); } if (this.pubkey) { obj.pubkey = this.pubkey.toString(); } if (this.sig) { obj.sig = this.sig.toString(); } if (this.k) { obj.k = this.k.toString(); } return JSON.stringify(obj); }; ECDSA.prototype.verify = function() { if (!this.sigError()) { this.verified = true; } else { this.verified = false; } return this; }; ECDSA.sign = function(hashbuf, privkey, endian) { return ECDSA().set({ hashbuf: hashbuf, endian: endian, privkey: privkey }).sign().sig; }; ECDSA.verify = function(hashbuf, sig, pubkey, endian) { return ECDSA().set({ hashbuf: hashbuf, endian: endian, sig: sig, pubkey: pubkey }).verify().verified; }; module.exports = ECDSA; }).call(this,require("buffer").Buffer) },{"../publickey":122,"../util/buffer":141,"../util/preconditions":143,"./bn":104,"./hash":106,"./point":107,"./random":108,"./signature":109,"buffer":75,"lodash":146}],106:[function(require,module,exports){ (function (Buffer){ 'use strict'; var crypto = require('crypto'); var BufferUtil = require('../util/buffer'); var $ = require('../util/preconditions'); var Hash = module.exports; Hash.sha1 = function(buf) { $.checkArgument(BufferUtil.isBuffer(buf)); return crypto.createHash('sha1').update(buf).digest(); }; Hash.sha1.blocksize = 512; Hash.sha256 = function(buf) { $.checkArgument(BufferUtil.isBuffer(buf)); return crypto.createHash('sha256').update(buf).digest(); }; Hash.sha256.blocksize = 512; Hash.sha256sha256 = function(buf) { $.checkArgument(BufferUtil.isBuffer(buf)); return Hash.sha256(Hash.sha256(buf)); }; Hash.ripemd160 = function(buf) { $.checkArgument(BufferUtil.isBuffer(buf)); return crypto.createHash('ripemd160').update(buf).digest(); }; Hash.sha256ripemd160 = function(buf) { $.checkArgument(BufferUtil.isBuffer(buf)); return Hash.ripemd160(Hash.sha256(buf)); }; Hash.sha512 = function(buf) { $.checkArgument(BufferUtil.isBuffer(buf)); return crypto.createHash('sha512').update(buf).digest(); }; Hash.sha512.blocksize = 1024; Hash.hmac = function(hashf, data, key) { //http://en.wikipedia.org/wiki/Hash-based_message_authentication_code //http://tools.ietf.org/html/rfc4868#section-2 $.checkArgument(BufferUtil.isBuffer(data)); $.checkArgument(BufferUtil.isBuffer(key)); $.checkArgument(hashf.blocksize); var blocksize = hashf.blocksize / 8; if (key.length > blocksize) { key = hashf(key); } else if (key < blocksize) { var fill = new Buffer(blocksize); fill.fill(0); key.copy(fill); key = fill; } var o_key = new Buffer(blocksize); o_key.fill(0x5c); var i_key = new Buffer(blocksize); i_key.fill(0x36); var o_key_pad = new Buffer(blocksize); var i_key_pad = new Buffer(blocksize); for (var i = 0; i < blocksize; i++) { o_key_pad[i] = o_key[i] ^ key[i]; i_key_pad[i] = i_key[i] ^ key[i]; } return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))])); }; Hash.sha256hmac = function(data, key) { return Hash.hmac(Hash.sha256, data, key); }; Hash.sha512hmac = function(data, key) { return Hash.hmac(Hash.sha512, data, key); }; }).call(this,require("buffer").Buffer) },{"../util/buffer":141,"../util/preconditions":143,"buffer":75,"crypto":87}],107:[function(require,module,exports){ (function (Buffer){ 'use strict'; var BN = require('./bn'); var BufferUtil = require('../util/buffer'); var EC = require('elliptic').ec; var ec = new EC('secp256k1'); var ecPoint = ec.curve.point.bind(ec.curve); var ecPointFromX = ec.curve.pointFromX.bind(ec.curve); /** * * Instantiate a valid secp256k1 Point from the X and Y coordinates. * * @param {BN|String} x - The X coordinate * @param {BN|String} y - The Y coordinate * @link https://github.com/indutny/elliptic * @augments elliptic.curve.point * @throws {Error} A validation error if exists * @returns {Point} An instance of Point * @constructor */ var Point = function Point(x, y, isRed) { try { var point = ecPoint(x, y, isRed); } catch (e) { throw new Error('Invalid Point'); } point.validate(); return point; }; Point.prototype = Object.getPrototypeOf(ec.curve.point()); /** * * Instantiate a valid secp256k1 Point from only the X coordinate * * @param {boolean} odd - If the Y coordinate is odd * @param {BN|String} x - The X coordinate * @throws {Error} A validation error if exists * @returns {Point} An instance of Point */ Point.fromX = function fromX(odd, x){ try { var point = ecPointFromX(x, odd); } catch (e) { throw new Error('Invalid X'); } point.validate(); return point; }; /** * * Will return a secp256k1 ECDSA base point. * * @link https://en.bitcoin.it/wiki/Secp256k1 * @returns {Point} An instance of the base point. */ Point.getG = function getG() { return ec.curve.g; }; /** * * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard. * * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys * @returns {BN} A BN instance of the number of points on the curve */ Point.getN = function getN() { return new BN(ec.curve.n.toArray()); }; Point.prototype._getX = Point.prototype.getX; /** * * Will return the X coordinate of the Point * * @returns {BN} A BN instance of the X coordinate */ Point.prototype.getX = function getX() { return new BN(this._getX().toArray()); }; Point.prototype._getY = Point.prototype.getY; /** * * Will return the Y coordinate of the Point * * @returns {BN} A BN instance of the Y coordinate */ Point.prototype.getY = function getY() { return new BN(this._getY().toArray()); }; /** * * Will determine if the point is valid * * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf * @param {Point} An instance of Point * @throws {Error} A validation error if exists * @returns {Point} An instance of the same Point */ Point.prototype.validate = function validate() { if (this.isInfinity()){ throw new Error('Point cannot be equal to Infinity'); } var p2; try { p2 = ecPointFromX(this.getX(), this.getY().isOdd()); } catch (e) { throw new Error('Point does not lie on the curve'); } if (p2.y.cmp(this.y) !== 0) { throw new Error('Invalid y value for curve.'); } //todo: needs test case if (!(this.mul(Point.getN()).isInfinity())) { throw new Error('Point times N must be infinity'); } return this; }; Point.pointToCompressed = function pointToCompressed(point) { var xbuf = point.getX().toBuffer({size: 32}); var ybuf = point.getY().toBuffer({size: 32}); var prefix; var odd = ybuf[ybuf.length - 1] % 2; if (odd) { prefix = new Buffer([0x03]); } else { prefix = new Buffer([0x02]); } return BufferUtil.concat([prefix, xbuf]); }; module.exports = Point; }).call(this,require("buffer").Buffer) },{"../util/buffer":141,"./bn":104,"buffer":75,"elliptic":168}],108:[function(require,module,exports){ (function (process,Buffer){ 'use strict'; function Random() { } /* secure random bytes that sometimes throws an error due to lack of entropy */ Random.getRandomBuffer = function(size) { if (process.browser) return Random.getRandomBufferBrowser(size); else return Random.getRandomBufferNode(size); }; Random.getRandomBufferNode = function(size) { var crypto = require('crypto'); return crypto.randomBytes(size); }; Random.getRandomBufferBrowser = function(size) { if (!window.crypto && !window.msCrypto) throw new Error('window.crypto not available'); if (window.crypto && window.crypto.getRandomValues) var crypto = window.crypto; else if (window.msCrypto && window.msCrypto.getRandomValues) //internet explorer var crypto = window.msCrypto; else throw new Error('window.crypto.getRandomValues not available'); var bbuf = new Uint8Array(size); crypto.getRandomValues(bbuf); var buf = new Buffer(bbuf); return buf; }; /* insecure random bytes, but it never fails */ Random.getPseudoRandomBuffer = function(size) { var b32 = 0x100000000; var b = new Buffer(size); var r; for (var i = 0; i <= size; i++) { var j = Math.floor(i / 4); var k = i - j * 4; if (k === 0) { r = Math.random() * b32; b[i] = r & 0xff; } else { b[i] = (r = r >>> 8) & 0xff; } } return b; }; module.exports = Random; }).call(this,require('_process'),require("buffer").Buffer) },{"_process":234,"buffer":75,"crypto":87}],109:[function(require,module,exports){ (function (Buffer){ 'use strict'; var BN = require('./bn'); var _ = require('lodash'); var $ = require('../util/preconditions'); var BufferUtil = require('../util/buffer'); var JSUtil = require('../util/js'); var Signature = function Signature(r, s) { if (!(this instanceof Signature)) { return new Signature(r, s); } if (r instanceof BN) { this.set({ r: r, s: s }); } else if (r) { var obj = r; this.set(obj); } }; /* jshint maxcomplexity: 7 */ Signature.prototype.set = function(obj) { this.r = obj.r || this.r || undefined; this.s = obj.s || this.s || undefined; this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3] this.compressed = typeof obj.compressed !== 'undefined' ? obj.compressed : this.compressed; //whether the recovered pubkey is compressed this.nhashtype = obj.nhashtype || this.nhashtype || undefined; return this; }; Signature.fromCompact = function(buf) { $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer'); var sig = new Signature(); var compressed = true; var i = buf.slice(0, 1)[0] - 27 - 4; if (i < 0) { compressed = false; i = i + 4; } var b2 = buf.slice(1, 33); var b3 = buf.slice(33, 65); $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3')); $.checkArgument(b2.length === 32, new Error('r must be 32 bytes')); $.checkArgument(b3.length === 32, new Error('s must be 32 bytes')); sig.compressed = compressed; sig.i = i; sig.r = BN.fromBuffer(b2); sig.s = BN.fromBuffer(b3); return sig; }; Signature.fromDER = Signature.fromBuffer = function(buf, strict) { var obj = Signature.parseDER(buf, strict); var sig = new Signature(); sig.r = obj.r; sig.s = obj.s; return sig; }; // The format used in a tx Signature.fromTxFormat = function(buf) { var nhashtype = buf.readUInt8(buf.length - 1); var derbuf = buf.slice(0, buf.length - 1); var sig = new Signature.fromDER(derbuf, false); sig.nhashtype = nhashtype; return sig; }; Signature.fromString = function(str) { var buf = new Buffer(str, 'hex'); return Signature.fromDER(buf); }; /** * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false. */ Signature.parseDER = function(buf, strict) { $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer')); if (_.isUndefined(strict)) { strict = true; } var header = buf[0]; $.checkArgument(header === 0x30, new Error('Header byte should be 0x30')); var length = buf[1]; var buflength = buf.slice(2).length; $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows')); length = length < buflength ? length : buflength; var rheader = buf[2 + 0]; $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02')); var rlength = buf[2 + 1]; var rbuf = buf.slice(2 + 2, 2 + 2 + rlength); var r = BN.fromBuffer(rbuf); var rneg = buf[2 + 1 + 1] === 0x00 ? true : false; $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect')); var sheader = buf[2 + 2 + rlength + 0]; $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02')); var slength = buf[2 + 2 + rlength + 1]; var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength); var s = BN.fromBuffer(sbuf); var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false; $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect')); var sumlength = 2 + 2 + rlength + 2 + slength; $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect')); var obj = { header: header, length: length, rheader: rheader, rlength: rlength, rneg: rneg, rbuf: rbuf, r: r, sheader: sheader, slength: slength, sneg: sneg, sbuf: sbuf, s: s }; return obj; }; Signature.prototype.toCompact = function(i, compressed) { i = typeof i === 'number' ? i : this.i; compressed = typeof compressed === 'boolean' ? compressed : this.compressed; if (!(i === 0 || i === 1 || i === 2 || i === 3)) { throw new Error('i must be equal to 0, 1, 2, or 3'); } var val = i + 27 + 4; if (compressed === false) { val = val - 4; } var b1 = new Buffer([val]); var b2 = this.r.toBuffer({ size: 32 }); var b3 = this.s.toBuffer({ size: 32 }); return Buffer.concat([b1, b2, b3]); }; Signature.prototype.toBuffer = Signature.prototype.toDER = function() { var rnbuf = this.r.toBuffer(); var snbuf = this.s.toBuffer(); var rneg = rnbuf[0] & 0x80 ? true : false; var sneg = snbuf[0] & 0x80 ? true : false; var rbuf = rneg ? Buffer.concat([new Buffer([0x00]), rnbuf]) : rnbuf; var sbuf = sneg ? Buffer.concat([new Buffer([0x00]), snbuf]) : snbuf; var rlength = rbuf.length; var slength = sbuf.length; var length = 2 + rlength + 2 + slength; var rheader = 0x02; var sheader = 0x02; var header = 0x30; var der = Buffer.concat([new Buffer([header, length, rheader, rlength]), rbuf, new Buffer([sheader, slength]), sbuf]); return der; }; Signature.prototype.toString = function() { var buf = this.toDER(); return buf.toString('hex'); }; /** * This function is translated from bitcoind's IsDERSignature and is used in * the script interpreter. This "DER" format actually includes an extra byte, * the nhashtype, at the end. It is really the tx format, not DER format. * * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype] * Where R and S are not negative (their first byte has its highest bit not set), and not * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows, * in which case a single 0 byte is necessary and even required). * * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623 */ Signature.isTxDER = function(buf) { if (buf.length < 9) { // Non-canonical signature: too short return false; } if (buf.length > 73) { // Non-canonical signature: too long return false; } if (buf[0] !== 0x30) { // Non-canonical signature: wrong type return false; } if (buf[1] !== buf.length - 3) { // Non-canonical signature: wrong length marker return false; } var nLenR = buf[3]; if (5 + nLenR >= buf.length) { // Non-canonical signature: S length misplaced return false; } var nLenS = buf[5 + nLenR]; if ((nLenR + nLenS + 7) !== buf.length) { // Non-canonical signature: R+S length mismatch return false; } var R = buf.slice(4); if (buf[4 - 2] !== 0x02) { // Non-canonical signature: R value type mismatch return false; } if (nLenR === 0) { // Non-canonical signature: R length is zero return false; } if (R[0] & 0x80) { // Non-canonical signature: R value negative return false; } if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) { // Non-canonical signature: R value excessively padded return false; } var S = buf.slice(6 + nLenR); if (buf[6 + nLenR - 2] !== 0x02) { // Non-canonical signature: S value type mismatch return false; } if (nLenS === 0) { // Non-canonical signature: S length is zero return false; } if (S[0] & 0x80) { // Non-canonical signature: S value negative return false; } if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) { // Non-canonical signature: S value excessively padded return false; } return true; }; /** * Compares to bitcoind's IsLowDERSignature * See also ECDSA signature algorithm which enforces this. * See also BIP 62, "low S values in signatures" */ Signature.prototype.hasLowS = function() { if (this.s.lt(new BN(1)) || this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) { return false; } return true; }; /** * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof. * Translated from bitcoind's IsDefinedHashtypeSignature */ Signature.prototype.hasDefinedHashtype = function() { if (!JSUtil.isNaturalNumber(this.nhashtype)) { return false; } // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY; if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) { return false; } return true; }; Signature.prototype.toTxFormat = function() { var derbuf = this.toDER(); var buf = new Buffer(1); buf.writeUInt8(this.nhashtype, 0); return Buffer.concat([derbuf, buf]); }; Signature.SIGHASH_ALL = 0x01; Signature.SIGHASH_NONE = 0x02; Signature.SIGHASH_SINGLE = 0x03; Signature.SIGHASH_ANYONECANPAY = 0x80; module.exports = Signature; }).call(this,require("buffer").Buffer) },{"../util/buffer":141,"../util/js":142,"../util/preconditions":143,"./bn":104,"buffer":75,"lodash":146}],110:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var bs58 = require('bs58'); var buffer = require('buffer'); var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split(''); var Base58 = function Base58(obj) { /* jshint maxcomplexity: 8 */ if (!(this instanceof Base58)) { return new Base58(obj); } if (Buffer.isBuffer(obj)) { var buf = obj; this.fromBuffer(buf); } else if (typeof obj === 'string') { var str = obj; this.fromString(str); } else if (obj) { this.set(obj); } }; Base58.validCharacters = function validCharacters(chars) { if (buffer.Buffer.isBuffer(chars)) { chars = chars.toString(); } return _.every(_.map(chars, function(char) { return _.includes(ALPHABET, char); })); }; Base58.prototype.set = function(obj) { this.buf = obj.buf || this.buf || undefined; return this; }; Base58.encode = function(buf) { if (!buffer.Buffer.isBuffer(buf)) { throw new Error('Input should be a buffer'); } return bs58.encode(buf); }; Base58.decode = function(str) { if (typeof str !== 'string') { throw new Error('Input should be a string'); } return new Buffer(bs58.decode(str)); }; Base58.prototype.fromBuffer = function(buf) { this.buf = buf; return this; }; Base58.prototype.fromString = function(str) { var buf = Base58.decode(str); this.buf = buf; return this; }; Base58.prototype.toBuffer = function() { return this.buf; }; Base58.prototype.toString = function() { return Base58.encode(this.buf); }; module.exports = Base58; }).call(this,require("buffer").Buffer) },{"bs58":144,"buffer":75,"lodash":146}],111:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var Base58 = require('./base58'); var buffer = require('buffer'); var sha256sha256 = require('../crypto/hash').sha256sha256; var Base58Check = function Base58Check(obj) { if (!(this instanceof Base58Check)) return new Base58Check(obj); if (Buffer.isBuffer(obj)) { var buf = obj; this.fromBuffer(buf); } else if (typeof obj === 'string') { var str = obj; this.fromString(str); } else if (obj) { this.set(obj); } }; Base58Check.prototype.set = function(obj) { this.buf = obj.buf || this.buf || undefined; return this; }; Base58Check.validChecksum = function validChecksum(data, checksum) { if (_.isString(data)) { data = new buffer.Buffer(Base58.decode(data)); } if (_.isString(checksum)) { checksum = new buffer.Buffer(Base58.decode(checksum)); } if (!checksum) { checksum = data.slice(-4); data = data.slice(0, -4); } return Base58Check.checksum(data).toString('hex') === checksum.toString('hex'); }; Base58Check.decode = function(s) { if (typeof s !== 'string') throw new Error('Input must be a string'); var buf = new Buffer(Base58.decode(s)); if (buf.length < 4) throw new Error("Input string too short"); var data = buf.slice(0, -4); var csum = buf.slice(-4); var hash = sha256sha256(data); var hash4 = hash.slice(0, 4); if (csum.toString('hex') !== hash4.toString('hex')) throw new Error("Checksum mismatch"); return data; }; Base58Check.checksum = function(buffer) { return sha256sha256(buffer).slice(0, 4); }; Base58Check.encode = function(buf) { if (!Buffer.isBuffer(buf)) throw new Error('Input must be a buffer'); var checkedBuf = new Buffer(buf.length + 4); var hash = Base58Check.checksum(buf); buf.copy(checkedBuf); hash.copy(checkedBuf, buf.length); return Base58.encode(checkedBuf); }; Base58Check.prototype.fromBuffer = function(buf) { this.buf = buf; return this; }; Base58Check.prototype.fromString = function(str) { var buf = Base58Check.decode(str); this.buf = buf; return this; }; Base58Check.prototype.toBuffer = function() { return this.buf; }; Base58Check.prototype.toString = function() { return Base58Check.encode(this.buf); }; module.exports = Base58Check; }).call(this,require("buffer").Buffer) },{"../crypto/hash":106,"./base58":110,"buffer":75,"lodash":146}],112:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var $ = require('../util/preconditions'); var BufferUtil = require('../util/buffer'); var BN = require('../crypto/bn'); var BufferReader = function BufferReader(buf) { if (!(this instanceof BufferReader)) { return new BufferReader(buf); } if (_.isUndefined(buf)) { return; } if (Buffer.isBuffer(buf)) { this.set({ buf: buf }); } else if (_.isString(buf)) { this.set({ buf: new Buffer(buf, 'hex'), }); } else if (_.isObject(buf)) { var obj = buf; this.set(obj); } else { throw new TypeError('Unrecognized argument for BufferReader'); } }; BufferReader.prototype.set = function(obj) { this.buf = obj.buf || this.buf || undefined; this.pos = obj.pos || this.pos || 0; return this; }; BufferReader.prototype.eof = function() { return this.pos >= this.buf.length; }; BufferReader.prototype.finished = BufferReader.prototype.eof; BufferReader.prototype.read = function(len) { $.checkArgument(!_.isUndefined(len), 'Must specify a length'); var buf = this.buf.slice(this.pos, this.pos + len); this.pos = this.pos + len; return buf; }; BufferReader.prototype.readAll = function() { var buf = this.buf.slice(this.pos, this.buf.length); this.pos = this.buf.length; return buf; }; BufferReader.prototype.readUInt8 = function() { var val = this.buf.readUInt8(this.pos); this.pos = this.pos + 1; return val; }; BufferReader.prototype.readUInt16BE = function() { var val = this.buf.readUInt16BE(this.pos); this.pos = this.pos + 2; return val; }; BufferReader.prototype.readUInt16LE = function() { var val = this.buf.readUInt16LE(this.pos); this.pos = this.pos + 2; return val; }; BufferReader.prototype.readUInt32BE = function() { var val = this.buf.readUInt32BE(this.pos); this.pos = this.pos + 4; return val; }; BufferReader.prototype.readUInt32LE = function() { var val = this.buf.readUInt32LE(this.pos); this.pos = this.pos + 4; return val; }; BufferReader.prototype.readInt32LE = function() { var val = this.buf.readInt32LE(this.pos); this.pos = this.pos + 4; return val; }; BufferReader.prototype.readUInt64BEBN = function() { var buf = this.buf.slice(this.pos, this.pos + 8); var bn = BN.fromBuffer(buf); this.pos = this.pos + 8; return bn; }; BufferReader.prototype.readUInt64LEBN = function() { var second = this.buf.readUInt32LE(this.pos); var first = this.buf.readUInt32LE(this.pos + 4); var combined = (first * 0x100000000) + second; // Instantiating an instance of BN with a number is faster than with an // array or string. However, the maximum safe number for a double precision // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use // non-floating point numbers less than this amount (52 bits). And in the case // that the number is larger, we can instatiate an instance of BN by passing // an array from the buffer (slower) and specifying the endianness. var bn; if (combined <= 0x1fffffffffffff) { bn = new BN(combined); } else { var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8); bn = new BN(data, 10, 'le'); } this.pos = this.pos + 8; return bn; }; BufferReader.prototype.readVarintNum = function() { var first = this.readUInt8(); switch (first) { case 0xFD: return this.readUInt16LE(); case 0xFE: return this.readUInt32LE(); case 0xFF: var bn = this.readUInt64LEBN(); var n = bn.toNumber(); if (n <= Math.pow(2, 53)) { return n; } else { throw new Error('number too large to retain precision - use readVarintBN'); } break; default: return first; } }; /** * reads a length prepended buffer */ BufferReader.prototype.readVarLengthBuffer = function() { var len = this.readVarintNum(); var buf = this.read(len); $.checkState(buf.length === len, 'Invalid length while reading varlength buffer. ' + 'Expected to read: ' + len + ' and read ' + buf.length); return buf; }; BufferReader.prototype.readVarintBuf = function() { var first = this.buf.readUInt8(this.pos); switch (first) { case 0xFD: return this.read(1 + 2); case 0xFE: return this.read(1 + 4); case 0xFF: return this.read(1 + 8); default: return this.read(1); } }; BufferReader.prototype.readVarintBN = function() { var first = this.readUInt8(); switch (first) { case 0xFD: return new BN(this.readUInt16LE()); case 0xFE: return new BN(this.readUInt32LE()); case 0xFF: return this.readUInt64LEBN(); default: return new BN(first); } }; BufferReader.prototype.reverse = function() { var buf = new Buffer(this.buf.length); for (var i = 0; i < buf.length; i++) { buf[i] = this.buf[this.buf.length - 1 - i]; } this.buf = buf; return this; }; BufferReader.prototype.readReverse = function(len) { if (_.isUndefined(len)) { len = this.buf.length; } var buf = this.buf.slice(this.pos, this.pos + len); this.pos = this.pos + len; return BufferUtil.reverse(buf); }; module.exports = BufferReader; }).call(this,require("buffer").Buffer) },{"../crypto/bn":104,"../util/buffer":141,"../util/preconditions":143,"buffer":75,"lodash":146}],113:[function(require,module,exports){ (function (Buffer){ 'use strict'; var bufferUtil = require('../util/buffer'); var assert = require('assert'); var BufferWriter = function BufferWriter(obj) { if (!(this instanceof BufferWriter)) return new BufferWriter(obj); if (obj) this.set(obj); else this.bufs = []; }; BufferWriter.prototype.set = function(obj) { this.bufs = obj.bufs || this.bufs || []; return this; }; BufferWriter.prototype.toBuffer = function() { return this.concat(); }; BufferWriter.prototype.concat = function() { return Buffer.concat(this.bufs); }; BufferWriter.prototype.write = function(buf) { assert(bufferUtil.isBuffer(buf)); this.bufs.push(buf); return this; }; BufferWriter.prototype.writeReverse = function(buf) { assert(bufferUtil.isBuffer(buf)); this.bufs.push(bufferUtil.reverse(buf)); return this; }; BufferWriter.prototype.writeUInt8 = function(n) { var buf = new Buffer(1); buf.writeUInt8(n, 0); this.write(buf); return this; }; BufferWriter.prototype.writeUInt16BE = function(n) { var buf = new Buffer(2); buf.writeUInt16BE(n, 0); this.write(buf); return this; }; BufferWriter.prototype.writeUInt16LE = function(n) { var buf = new Buffer(2); buf.writeUInt16LE(n, 0); this.write(buf); return this; }; BufferWriter.prototype.writeUInt32BE = function(n) { var buf = new Buffer(4); buf.writeUInt32BE(n, 0); this.write(buf); return this; }; BufferWriter.prototype.writeInt32LE = function(n) { var buf = new Buffer(4); buf.writeInt32LE(n, 0); this.write(buf); return this; }; BufferWriter.prototype.writeUInt32LE = function(n) { var buf = new Buffer(4); buf.writeUInt32LE(n, 0); this.write(buf); return this; }; BufferWriter.prototype.writeUInt64BEBN = function(bn) { var buf = bn.toBuffer({size: 8}); this.write(buf); return this; }; BufferWriter.prototype.writeUInt64LEBN = function(bn) { var buf = bn.toBuffer({size: 8}); this.writeReverse(buf); return this; }; BufferWriter.prototype.writeVarintNum = function(n) { var buf = BufferWriter.varintBufNum(n); this.write(buf); return this; }; BufferWriter.prototype.writeVarintBN = function(bn) { var buf = BufferWriter.varintBufBN(bn); this.write(buf); return this; }; BufferWriter.varintBufNum = function(n) { var buf = undefined; if (n < 253) { buf = new Buffer(1); buf.writeUInt8(n, 0); } else if (n < 0x10000) { buf = new Buffer(1 + 2); buf.writeUInt8(253, 0); buf.writeUInt16LE(n, 1); } else if (n < 0x100000000) { buf = new Buffer(1 + 4); buf.writeUInt8(254, 0); buf.writeUInt32LE(n, 1); } else { buf = new Buffer(1 + 8); buf.writeUInt8(255, 0); buf.writeInt32LE(n & -1, 1); buf.writeUInt32LE(Math.floor(n / 0x100000000), 5); } return buf; }; BufferWriter.varintBufBN = function(bn) { var buf = undefined; var n = bn.toNumber(); if (n < 253) { buf = new Buffer(1); buf.writeUInt8(n, 0); } else if (n < 0x10000) { buf = new Buffer(1 + 2); buf.writeUInt8(253, 0); buf.writeUInt16LE(n, 1); } else if (n < 0x100000000) { buf = new Buffer(1 + 4); buf.writeUInt8(254, 0); buf.writeUInt32LE(n, 1); } else { var bw = new BufferWriter(); bw.writeUInt8(255); bw.writeUInt64LEBN(bn); var buf = bw.concat(); } return buf; }; module.exports = BufferWriter; }).call(this,require("buffer").Buffer) },{"../util/buffer":141,"assert":29,"buffer":75}],114:[function(require,module,exports){ (function (Buffer){ 'use strict'; var BufferWriter = require('./bufferwriter'); var BufferReader = require('./bufferreader'); var BN = require('../crypto/bn'); var Varint = function Varint(buf) { if (!(this instanceof Varint)) return new Varint(buf); if (Buffer.isBuffer(buf)) { this.buf = buf; } else if (typeof buf === 'number') { var num = buf; this.fromNumber(num); } else if (buf instanceof BN) { var bn = buf; this.fromBN(bn); } else if (buf) { var obj = buf; this.set(obj); } }; Varint.prototype.set = function(obj) { this.buf = obj.buf || this.buf; return this; }; Varint.prototype.fromString = function(str) { this.set({ buf: new Buffer(str, 'hex') }); return this; }; Varint.prototype.toString = function() { return this.buf.toString('hex'); }; Varint.prototype.fromBuffer = function(buf) { this.buf = buf; return this; }; Varint.prototype.fromBufferReader = function(br) { this.buf = br.readVarintBuf(); return this; }; Varint.prototype.fromBN = function(bn) { this.buf = BufferWriter().writeVarintBN(bn).concat(); return this; }; Varint.prototype.fromNumber = function(num) { this.buf = BufferWriter().writeVarintNum(num).concat(); return this; }; Varint.prototype.toBuffer = function() { return this.buf; }; Varint.prototype.toBN = function() { return BufferReader(this.buf).readVarintBN(); }; Varint.prototype.toNumber = function() { return BufferReader(this.buf).readVarintNum(); }; module.exports = Varint; }).call(this,require("buffer").Buffer) },{"../crypto/bn":104,"./bufferreader":112,"./bufferwriter":113,"buffer":75}],115:[function(require,module,exports){ 'use strict'; var _ = require('lodash'); function format(message, args) { return message .replace('{0}', args[0]) .replace('{1}', args[1]) .replace('{2}', args[2]); } var traverseNode = function(parent, errorDefinition) { var NodeError = function() { if (_.isString(errorDefinition.message)) { this.message = format(errorDefinition.message, arguments); } else if (_.isFunction(errorDefinition.message)) { this.message = errorDefinition.message.apply(null, arguments); } else { throw new Error('Invalid error definition for ' + errorDefinition.name); } this.stack = this.message + '\n' + (new Error()).stack; }; NodeError.prototype = Object.create(parent.prototype); NodeError.prototype.name = parent.prototype.name + errorDefinition.name; parent[errorDefinition.name] = NodeError; if (errorDefinition.errors) { childDefinitions(NodeError, errorDefinition.errors); } return NodeError; }; /* jshint latedef: false */ var childDefinitions = function(parent, childDefinitions) { _.each(childDefinitions, function(childDefinition) { traverseNode(parent, childDefinition); }); }; /* jshint latedef: true */ var traverseRoot = function(parent, errorsDefinition) { childDefinitions(parent, errorsDefinition); return parent; }; var digibyte = {}; digibyte.Error = function() { this.message = 'Internal error'; this.stack = this.message + '\n' + (new Error()).stack; }; digibyte.Error.prototype = Object.create(Error.prototype); digibyte.Error.prototype.name = 'digibyte.Error'; var data = require('./spec'); traverseRoot(digibyte.Error, data); module.exports = digibyte.Error; module.exports.extend = function(spec) { return traverseNode(digibyte.Error, spec); }; },{"./spec":116,"lodash":146}],116:[function(require,module,exports){ 'use strict'; var docsURL = 'http://bitcore.io/'; module.exports = [{ name: 'InvalidB58Char', message: 'Invalid Base58 character: {0} in {1}' }, { name: 'InvalidB58Checksum', message: 'Invalid Base58 checksum for {0}' }, { name: 'InvalidNetwork', message: 'Invalid version for network: got {0}' }, { name: 'InvalidState', message: 'Invalid state: {0}' }, { name: 'NotImplemented', message: 'Function {0} was not implemented yet' }, { name: 'InvalidNetworkArgument', message: 'Invalid network: must be "livenet" or "testnet", got {0}' }, { name: 'InvalidArgument', message: function() { return 'Invalid Argument' + (arguments[0] ? (': ' + arguments[0]) : '') + (arguments[1] ? (' Documentation: ' + docsURL + arguments[1]) : ''); } }, { name: 'AbstractMethodInvoked', message: 'Abstract Method Invocation: {0}' }, { name: 'InvalidArgumentType', message: function() { return 'Invalid Argument for ' + arguments[2] + ', expected ' + arguments[1] + ' but got ' + typeof arguments[0]; } }, { name: 'Unit', message: 'Internal Error on Unit {0}', errors: [{ 'name': 'UnknownCode', 'message': 'Unrecognized unit code: {0}' }, { 'name': 'InvalidRate', 'message': 'Invalid exchange rate: {0}' }] }, { name: 'Transaction', message: 'Internal Error on Transaction {0}', errors: [{ name: 'Input', message: 'Internal Error on Input {0}', errors: [{ name: 'MissingScript', message: 'Need a script to create an input' }, { name: 'UnsupportedScript', message: 'Unsupported input script type: {0}' }, { name: 'MissingPreviousOutput', message: 'No previous output information.' }] }, { name: 'NeedMoreInfo', message: '{0}' }, { name: 'InvalidSorting', message: 'The sorting function provided did not return the change output as one of the array elements' }, { name: 'InvalidOutputAmountSum', message: '{0}' }, { name: 'MissingSignatures', message: 'Some inputs have not been fully signed' }, { name: 'InvalidIndex', message: 'Invalid index: {0} is not between 0, {1}' }, { name: 'UnableToVerifySignature', message: 'Unable to verify signature: {0}' }, { name: 'DustOutputs', message: 'Dust amount detected in one output' }, { name: 'InvalidSatoshis', message: 'Output satoshis are invalid', }, { name: 'FeeError', message: 'Internal Error on Fee {0}', errors: [{ name: 'TooSmall', message: 'Fee is too small: {0}', }, { name: 'TooLarge', message: 'Fee is too large: {0}', }, { name: 'Different', message: 'Unspent value is different from specified fee: {0}', }] }, { name: 'ChangeAddressMissing', message: 'Change address is missing' }, { name: 'BlockHeightTooHigh', message: 'Block Height can be at most 2^32 -1' }, { name: 'NLockTimeOutOfRange', message: 'Block Height can only be between 0 and 499 999 999' }, { name: 'LockTimeTooEarly', message: 'Lock Time can\'t be earlier than UNIX date 500 000 000' }] }, { name: 'Script', message: 'Internal Error on Script {0}', errors: [{ name: 'UnrecognizedAddress', message: 'Expected argument {0} to be an address' }, { name: 'CantDeriveAddress', message: 'Can\'t derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out.' }, { name: 'InvalidBuffer', message: 'Invalid script buffer: can\'t parse valid script from given buffer {0}' }] }, { name: 'HDPrivateKey', message: 'Internal Error on HDPrivateKey {0}', errors: [{ name: 'InvalidDerivationArgument', message: 'Invalid derivation argument {0}, expected string, or number and boolean' }, { name: 'InvalidEntropyArgument', message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}', errors: [{ name: 'TooMuchEntropy', message: 'Invalid entropy: more than 512 bits is non standard, got "{0}"' }, { name: 'NotEnoughEntropy', message: 'Invalid entropy: at least 128 bits needed, got "{0}"' }] }, { name: 'InvalidLength', message: 'Invalid length for xprivkey string in {0}' }, { name: 'InvalidPath', message: 'Invalid derivation path: {0}' }, { name: 'UnrecognizedArgument', message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got "{0}"' }] }, { name: 'HDPublicKey', message: 'Internal Error on HDPublicKey {0}', errors: [{ name: 'ArgumentIsPrivateExtended', message: 'Argument is an extended private key: {0}' }, { name: 'InvalidDerivationArgument', message: 'Invalid derivation argument: got {0}' }, { name: 'InvalidLength', message: 'Invalid length for xpubkey: got "{0}"' }, { name: 'InvalidPath', message: 'Invalid derivation path, it should look like: "m/1/100", got "{0}"' }, { name: 'InvalidIndexCantDeriveHardened', message: 'Invalid argument: creating a hardened path requires an HDPrivateKey' }, { name: 'MustSupplyArgument', message: 'Must supply an argument to create a HDPublicKey' }, { name: 'UnrecognizedArgument', message: 'Invalid argument for creation, must be string, json, buffer, or object' }] }]; },{}],117:[function(require,module,exports){ (function (Buffer){ 'use strict'; var assert = require('assert'); var buffer = require('buffer'); var _ = require('lodash'); var $ = require('./util/preconditions'); var BN = require('./crypto/bn'); var Base58 = require('./encoding/base58'); var Base58Check = require('./encoding/base58check'); var Hash = require('./crypto/hash'); var Network = require('./networks'); var Point = require('./crypto/point'); var PrivateKey = require('./privatekey'); var Random = require('./crypto/random'); var errors = require('./errors'); var hdErrors = errors.HDPrivateKey; var BufferUtil = require('./util/buffer'); var JSUtil = require('./util/js'); var MINIMUM_ENTROPY_BITS = 128; var BITS_TO_BYTES = 1 / 8; var MAXIMUM_ENTROPY_BITS = 512; /** * Represents an instance of an hierarchically derived private key. * * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki * * @constructor * @param {string|Buffer|Object} arg */ function HDPrivateKey(arg) { /* jshint maxcomplexity: 10 */ if (arg instanceof HDPrivateKey) { return arg; } if (!(this instanceof HDPrivateKey)) { return new HDPrivateKey(arg); } if (!arg) { return this._generateRandomly(); } if (Network.get(arg)) { return this._generateRandomly(arg); } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) { if (HDPrivateKey.isValidSerialized(arg)) { this._buildFromSerialized(arg); } else if (JSUtil.isValidJSON(arg)) { this._buildFromJSON(arg); } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) { this._buildFromSerialized(arg.toString()); } else { throw HDPrivateKey.getSerializedError(arg); } } else if (_.isObject(arg)) { this._buildFromObject(arg); } else { throw new hdErrors.UnrecognizedArgument(arg); } } /** * Verifies that a given path is valid. * * @param {string|number} arg * @param {boolean?} hardened * @return {boolean} */ HDPrivateKey.isValidPath = function(arg, hardened) { if (_.isString(arg)) { var indexes = HDPrivateKey._getDerivationIndexes(arg); return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath); } if (_.isNumber(arg)) { if (arg < HDPrivateKey.Hardened && hardened === true) { arg += HDPrivateKey.Hardened; } return arg >= 0 && arg < HDPrivateKey.MaxIndex; } return false; }; /** * Internal function that splits a string path into a derivation index array. * It will return null if the string path is malformed. * It does not validate if indexes are in bounds. * * @param {string} path * @return {Array} */ HDPrivateKey._getDerivationIndexes = function(path) { var steps = path.split('/'); // Special cases: if (_.includes(HDPrivateKey.RootElementAlias, path)) { return []; } if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) { return null; } var indexes = steps.slice(1).map(function(step) { var isHardened = step.slice(-1) === '\''; if (isHardened) { step = step.slice(0, -1); } if (!step || step[0] === '-') { return NaN; } var index = +step; // cast to number if (isHardened) { index += HDPrivateKey.Hardened; } return index; }); return _.some(indexes, isNaN) ? null : indexes; }; /** * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant * * * Get a derived child based on a string or number. * * If the first argument is a string, it's parsed as the full path of * derivation. Valid values for this argument include "m" (which returns the * same private key), "m/0/1/40/2'/1000", where the ' quote means a hardened * derivation. * * If the first argument is a number, the child with that index will be * derived. If the second argument is truthy, the hardened version will be * derived. See the example usage for clarification. * * @example * ```javascript * var parent = new HDPrivateKey('xprv...'); * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true); * var copy_of_child_0_1_2h = parent.derive("m/0/1/2'"); * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h); * ``` * * @param {string|number} arg * @param {boolean?} hardened */ HDPrivateKey.prototype.derive = function(arg, hardened) { return this.deriveNonCompliantChild(arg, hardened); }; /** * WARNING: This method will not be officially supported until v1.0.0. * * * Get a derived child based on a string or number. * * If the first argument is a string, it's parsed as the full path of * derivation. Valid values for this argument include "m" (which returns the * same private key), "m/0/1/40/2'/1000", where the ' quote means a hardened * derivation. * * If the first argument is a number, the child with that index will be * derived. If the second argument is truthy, the hardened version will be * derived. See the example usage for clarification. * * WARNING: The `nonCompliant` option should NOT be used, except for older implementation * that used a derivation strategy that used a non-zero padded private key. * * @example * ```javascript * var parent = new HDPrivateKey('xprv...'); * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true); * var copy_of_child_0_1_2h = parent.deriveChild("m/0/1/2'"); * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h); * ``` * * @param {string|number} arg * @param {boolean?} hardened */ HDPrivateKey.prototype.deriveChild = function(arg, hardened) { if (_.isNumber(arg)) { return this._deriveWithNumber(arg, hardened); } else if (_.isString(arg)) { return this._deriveFromString(arg); } else { throw new hdErrors.InvalidDerivationArgument(arg); } }; /** * WARNING: This method will not be officially supported until v1.0.0 * * * WARNING: If this is a new implementation you should NOT use this method, you should be using * `derive` instead. * * This method is explicitly for use and compatibility with an implementation that * was not compliant with BIP32 regarding the derivation algorithm. The private key * must be 32 bytes hashing, and this implementation will use the non-zero padded * serialization of a private key, such that it's still possible to derive the privateKey * to recover those funds. * * @param {string|number} arg * @param {boolean?} hardened */ HDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) { if (_.isNumber(arg)) { return this._deriveWithNumber(arg, hardened, true); } else if (_.isString(arg)) { return this._deriveFromString(arg, true); } else { throw new hdErrors.InvalidDerivationArgument(arg); } }; HDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) { /* jshint maxstatements: 20 */ /* jshint maxcomplexity: 10 */ if (!HDPrivateKey.isValidPath(index, hardened)) { throw new hdErrors.InvalidPath(index); } hardened = index >= HDPrivateKey.Hardened ? true : hardened; if (index < HDPrivateKey.Hardened && hardened === true) { index += HDPrivateKey.Hardened; } var indexBuffer = BufferUtil.integerAsBuffer(index); var data; if (hardened && nonCompliant) { // The private key serialization in this case will not be exactly 32 bytes and can be // any value less, and the value is not zero-padded. var nonZeroPadded = this.privateKey.bn.toBuffer(); data = BufferUtil.concat([new buffer.Buffer([0]), nonZeroPadded, indexBuffer]); } else if (hardened) { // This will use a 32 byte zero padded serialization of the private key var privateKeyBuffer = this.privateKey.bn.toBuffer({size: 32}); assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes'); data = BufferUtil.concat([new buffer.Buffer([0]), privateKeyBuffer, indexBuffer]); } else { data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]); } var hash = Hash.sha512hmac(data, this._buffers.chainCode); var leftPart = BN.fromBuffer(hash.slice(0, 32), { size: 32 }); var chainCode = hash.slice(32, 64); var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({ size: 32 }); if (!PrivateKey.isValid(privateKey)) { // Index at this point is already hardened, we can pass null as the hardened arg return this._deriveWithNumber(index + 1, null, nonCompliant); } var derived = new HDPrivateKey({ network: this.network, depth: this.depth + 1, parentFingerPrint: this.fingerPrint, childIndex: index, chainCode: chainCode, privateKey: privateKey }); return derived; }; HDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) { if (!HDPrivateKey.isValidPath(path)) { throw new hdErrors.InvalidPath(path); } var indexes = HDPrivateKey._getDerivationIndexes(path); var derived = indexes.reduce(function(prev, index) { return prev._deriveWithNumber(index, null, nonCompliant); }, this); return derived; }; /** * Verifies that a given serialized private key in base58 with checksum format * is valid. * * @param {string|Buffer} data - the serialized private key * @param {string|Network=} network - optional, if present, checks that the * network provided matches the network serialized. * @return {boolean} */ HDPrivateKey.isValidSerialized = function(data, network) { return !HDPrivateKey.getSerializedError(data, network); }; /** * Checks what's the error that causes the validation of a serialized private key * in base58 with checksum to fail. * * @param {string|Buffer} data - the serialized private key * @param {string|Network=} network - optional, if present, checks that the * network provided matches the network serialized. * @return {errors.InvalidArgument|null} */ HDPrivateKey.getSerializedError = function(data, network) { /* jshint maxcomplexity: 10 */ if (!(_.isString(data) || BufferUtil.isBuffer(data))) { return new hdErrors.UnrecognizedArgument('Expected string or buffer'); } if (!Base58.validCharacters(data)) { return new errors.InvalidB58Char('(unknown)', data); } try { data = Base58Check.decode(data); } catch (e) { return new errors.InvalidB58Checksum(data); } if (data.length !== HDPrivateKey.DataLength) { return new hdErrors.InvalidLength(data); } if (!_.isUndefined(network)) { var error = HDPrivateKey._validateNetwork(data, network); if (error) { return error; } } return null; }; HDPrivateKey._validateNetwork = function(data, networkArg) { var network = Network.get(networkArg); if (!network) { return new errors.InvalidNetworkArgument(networkArg); } var version = data.slice(0, 4); if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) { return new errors.InvalidNetwork(version); } return null; }; HDPrivateKey.fromString = function(arg) { $.checkArgument(_.isString(arg), 'No valid string was provided'); return new HDPrivateKey(arg); }; HDPrivateKey.fromObject = function(arg) { $.checkArgument(_.isObject(arg), 'No valid argument was provided'); return new HDPrivateKey(arg); }; HDPrivateKey.prototype._buildFromJSON = function(arg) { return this._buildFromObject(JSON.parse(arg)); }; HDPrivateKey.prototype._buildFromObject = function(arg) { /* jshint maxcomplexity: 12 */ // TODO: Type validation var buffers = { version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version, depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth, parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint, childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex, chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode, privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? BufferUtil.hexToBuffer(arg.privateKey) : arg.privateKey, checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined }; return this._buildFromBuffers(buffers); }; HDPrivateKey.prototype._buildFromSerialized = function(arg) { var decoded = Base58Check.decode(arg); var buffers = { version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd), depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd), parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart, HDPrivateKey.ParentFingerPrintEnd), childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd), chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd), privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd), checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd), xprivkey: arg }; return this._buildFromBuffers(buffers); }; HDPrivateKey.prototype._generateRandomly = function(network) { return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network); }; /** * Generate a private key from a seed, as described in BIP32 * * @param {string|Buffer} hexa * @param {*} network * @return HDPrivateKey */ HDPrivateKey.fromSeed = function(hexa, network) { /* jshint maxcomplexity: 8 */ if (JSUtil.isHexaString(hexa)) { hexa = BufferUtil.hexToBuffer(hexa); } if (!Buffer.isBuffer(hexa)) { throw new hdErrors.InvalidEntropyArgument(hexa); } if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) { throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa); } if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) { throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa); } var hash = Hash.sha512hmac(hexa, new buffer.Buffer('Bitcoin seed')); return new HDPrivateKey({ network: Network.get(network) || Network.defaultNetwork, depth: 0, parentFingerPrint: 0, childIndex: 0, privateKey: hash.slice(0, 32), chainCode: hash.slice(32, 64) }); }; HDPrivateKey.prototype._calcHDPublicKey = function() { if (!this._hdPublicKey) { var HDPublicKey = require('./hdpublickey'); this._hdPublicKey = new HDPublicKey(this); } }; /** * Receives a object with buffers in all the properties and populates the * internal structure * * @param {Object} arg * @param {buffer.Buffer} arg.version * @param {buffer.Buffer} arg.depth * @param {buffer.Buffer} arg.parentFingerPrint * @param {buffer.Buffer} arg.childIndex * @param {buffer.Buffer} arg.chainCode * @param {buffer.Buffer} arg.privateKey * @param {buffer.Buffer} arg.checksum * @param {string=} arg.xprivkey - if set, don't recalculate the base58 * representation * @return {HDPrivateKey} this */ HDPrivateKey.prototype._buildFromBuffers = function(arg) { /* jshint maxcomplexity: 8 */ /* jshint maxstatements: 20 */ HDPrivateKey._validateBufferArguments(arg); JSUtil.defineImmutable(this, { _buffers: arg }); var sequence = [ arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, BufferUtil.emptyBuffer(1), arg.privateKey ]; var concat = buffer.Buffer.concat(sequence); if (!arg.checksum || !arg.checksum.length) { arg.checksum = Base58Check.checksum(concat); } else { if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) { throw new errors.InvalidB58Checksum(concat); } } var network = Network.get(BufferUtil.integerFromBuffer(arg.version)); var xprivkey; xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence)); arg.xprivkey = new Buffer(xprivkey); var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network); var publicKey = privateKey.toPublicKey(); var size = HDPrivateKey.ParentFingerPrintSize; var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size); JSUtil.defineImmutable(this, { xprivkey: xprivkey, network: network, depth: BufferUtil.integerFromSingleByteBuffer(arg.depth), privateKey: privateKey, publicKey: publicKey, fingerPrint: fingerPrint }); this._hdPublicKey = null; Object.defineProperty(this, 'hdPublicKey', { configurable: false, enumerable: true, get: function() { this._calcHDPublicKey(); return this._hdPublicKey; } }); Object.defineProperty(this, 'xpubkey', { configurable: false, enumerable: true, get: function() { this._calcHDPublicKey(); return this._hdPublicKey.xpubkey; } }); return this; }; HDPrivateKey._validateBufferArguments = function(arg) { var checkBuffer = function(name, size) { var buff = arg[name]; assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer'); assert( buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size ); }; checkBuffer('version', HDPrivateKey.VersionSize); checkBuffer('depth', HDPrivateKey.DepthSize); checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize); checkBuffer('childIndex', HDPrivateKey.ChildIndexSize); checkBuffer('chainCode', HDPrivateKey.ChainCodeSize); checkBuffer('privateKey', HDPrivateKey.PrivateKeySize); if (arg.checksum && arg.checksum.length) { checkBuffer('checksum', HDPrivateKey.CheckSumSize); } }; /** * Returns the string representation of this private key (a string starting * with "xprv..." * * @return string */ HDPrivateKey.prototype.toString = function() { return this.xprivkey; }; /** * Returns the console representation of this extended private key. * @return string */ HDPrivateKey.prototype.inspect = function() { return '<HDPrivateKey: ' + this.xprivkey + '>'; }; /** * Returns a plain object with a representation of this private key. * * Fields include:<ul> * <li> network: either 'livenet' or 'testnet' * <li> depth: a number ranging from 0 to 255 * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the * <li> associated public key * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash * <li> of this parent's associated public key or zero. * <li> childIndex: the index from which this child was derived (or zero) * <li> chainCode: an hexa string representing a number used in the derivation * <li> privateKey: the private key associated, in hexa representation * <li> xprivkey: the representation of this extended private key in checksum * <li> base58 format * <li> checksum: the base58 checksum of xprivkey * </ul> * @return {Object} */ HDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() { return { network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name, depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth), fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint), parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint), childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex), chainCode: BufferUtil.bufferToHex(this._buffers.chainCode), privateKey: this.privateKey.toBuffer().toString('hex'), checksum: BufferUtil.integerFromBuffer(this._buffers.checksum), xprivkey: this.xprivkey }; }; /** * Build a HDPrivateKey from a buffer * * @param {Buffer} arg * @return {HDPrivateKey} */ HDPrivateKey.fromBuffer = function(arg) { return new HDPrivateKey(arg.toString()); }; /** * Returns a buffer representation of the HDPrivateKey * * @return {string} */ HDPrivateKey.prototype.toBuffer = function() { return BufferUtil.copy(this._buffers.xprivkey); }; HDPrivateKey.DefaultDepth = 0; HDPrivateKey.DefaultFingerprint = 0; HDPrivateKey.DefaultChildIndex = 0; HDPrivateKey.Hardened = 0x80000000; HDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened; HDPrivateKey.RootElementAlias = ['m', 'M', 'm\'', 'M\'']; HDPrivateKey.VersionSize = 4; HDPrivateKey.DepthSize = 1; HDPrivateKey.ParentFingerPrintSize = 4; HDPrivateKey.ChildIndexSize = 4; HDPrivateKey.ChainCodeSize = 32; HDPrivateKey.PrivateKeySize = 32; HDPrivateKey.CheckSumSize = 4; HDPrivateKey.DataLength = 78; HDPrivateKey.SerializedByteSize = 82; HDPrivateKey.VersionStart = 0; HDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize; HDPrivateKey.DepthStart = HDPrivateKey.VersionEnd; HDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize; HDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd; HDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize; HDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd; HDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize; HDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd; HDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize; HDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1; HDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize; HDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd; HDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize; assert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize); module.exports = HDPrivateKey; }).call(this,require("buffer").Buffer) },{"./crypto/bn":104,"./crypto/hash":106,"./crypto/point":107,"./crypto/random":108,"./encoding/base58":110,"./encoding/base58check":111,"./errors":115,"./hdpublickey":118,"./networks":119,"./privatekey":121,"./util/buffer":141,"./util/js":142,"./util/preconditions":143,"assert":29,"buffer":75,"lodash":146}],118:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var $ = require('./util/preconditions'); var BN = require('./crypto/bn'); var Base58 = require('./encoding/base58'); var Base58Check = require('./encoding/base58check'); var Hash = require('./crypto/hash'); var HDPrivateKey = require('./hdprivatekey'); var Network = require('./networks'); var Point = require('./crypto/point'); var PublicKey = require('./publickey'); var digibyteErrors = require('./errors'); var errors = digibyteErrors; var hdErrors = digibyteErrors.HDPublicKey; var assert = require('assert'); var JSUtil = require('./util/js'); var BufferUtil = require('./util/buffer'); /** * The representation of an hierarchically derived public key. * * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki * * @constructor * @param {Object|string|Buffer} arg */ function HDPublicKey(arg) { /* jshint maxcomplexity: 12 */ /* jshint maxstatements: 20 */ if (arg instanceof HDPublicKey) { return arg; } if (!(this instanceof HDPublicKey)) { return new HDPublicKey(arg); } if (arg) { if (_.isString(arg) || BufferUtil.isBuffer(arg)) { var error = HDPublicKey.getSerializedError(arg); if (!error) { return this._buildFromSerialized(arg); } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) { return this._buildFromSerialized(arg.toString()); } else { if (error instanceof hdErrors.ArgumentIsPrivateExtended) { return new HDPrivateKey(arg).hdPublicKey; } throw error; } } else { if (_.isObject(arg)) { if (arg instanceof HDPrivateKey) { return this._buildFromPrivate(arg); } else { return this._buildFromObject(arg); } } else { throw new hdErrors.UnrecognizedArgument(arg); } } } else { throw new hdErrors.MustSupplyArgument(); } } /** * Verifies that a given path is valid. * * @param {string|number} arg * @return {boolean} */ HDPublicKey.isValidPath = function(arg) { if (_.isString(arg)) { var indexes = HDPrivateKey._getDerivationIndexes(arg); return indexes !== null && _.every(indexes, HDPublicKey.isValidPath); } if (_.isNumber(arg)) { return arg >= 0 && arg < HDPublicKey.Hardened; } return false; }; /** * WARNING: This method is deprecated. Use deriveChild instead. * * * Get a derivated child based on a string or number. * * If the first argument is a string, it's parsed as the full path of * derivation. Valid values for this argument include "m" (which returns the * same public key), "m/0/1/40/2/1000". * * Note that hardened keys can't be derived from a public extended key. * * If the first argument is a number, the child with that index will be * derived. See the example usage for clarification. * * @example * ```javascript * var parent = new HDPublicKey('xpub...'); * var child_0_1_2 = parent.derive(0).derive(1).derive(2); * var copy_of_child_0_1_2 = parent.derive("m/0/1/2"); * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2); * ``` * * @param {string|number} arg */ HDPublicKey.prototype.derive = function(arg, hardened) { return this.deriveChild(arg, hardened); }; /** * WARNING: This method will not be officially supported until v1.0.0. * * * Get a derivated child based on a string or number. * * If the first argument is a string, it's parsed as the full path of * derivation. Valid values for this argument include "m" (which returns the * same public key), "m/0/1/40/2/1000". * * Note that hardened keys can't be derived from a public extended key. * * If the first argument is a number, the child with that index will be * derived. See the example usage for clarification. * * @example * ```javascript * var parent = new HDPublicKey('xpub...'); * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2); * var copy_of_child_0_1_2 = parent.deriveChild("m/0/1/2"); * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2); * ``` * * @param {string|number} arg */ HDPublicKey.prototype.deriveChild = function(arg, hardened) { if (_.isNumber(arg)) { return this._deriveWithNumber(arg, hardened); } else if (_.isString(arg)) { return this._deriveFromString(arg); } else { throw new hdErrors.InvalidDerivationArgument(arg); } }; HDPublicKey.prototype._deriveWithNumber = function(index, hardened) { if (index >= HDPublicKey.Hardened || hardened) { throw new hdErrors.InvalidIndexCantDeriveHardened(); } if (index < 0) { throw new hdErrors.InvalidPath(index); } var indexBuffer = BufferUtil.integerAsBuffer(index); var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]); var hash = Hash.sha512hmac(data, this._buffers.chainCode); var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32}); var chainCode = hash.slice(32, 64); var publicKey; try { publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point)); } catch (e) { return this._deriveWithNumber(index + 1); } var derived = new HDPublicKey({ network: this.network, depth: this.depth + 1, parentFingerPrint: this.fingerPrint, childIndex: index, chainCode: chainCode, publicKey: publicKey }); return derived; }; HDPublicKey.prototype._deriveFromString = function(path) { /* jshint maxcomplexity: 8 */ if (_.includes(path, "'")) { throw new hdErrors.InvalidIndexCantDeriveHardened(); } else if (!HDPublicKey.isValidPath(path)) { throw new hdErrors.InvalidPath(path); } var indexes = HDPrivateKey._getDerivationIndexes(path); var derived = indexes.reduce(function(prev, index) { return prev._deriveWithNumber(index); }, this); return derived; }; /** * Verifies that a given serialized public key in base58 with checksum format * is valid. * * @param {string|Buffer} data - the serialized public key * @param {string|Network=} network - optional, if present, checks that the * network provided matches the network serialized. * @return {boolean} */ HDPublicKey.isValidSerialized = function(data, network) { return _.isNull(HDPublicKey.getSerializedError(data, network)); }; /** * Checks what's the error that causes the validation of a serialized public key * in base58 with checksum to fail. * * @param {string|Buffer} data - the serialized public key * @param {string|Network=} network - optional, if present, checks that the * network provided matches the network serialized. * @return {errors|null} */ HDPublicKey.getSerializedError = function(data, network) { /* jshint maxcomplexity: 10 */ /* jshint maxstatements: 20 */ if (!(_.isString(data) || BufferUtil.isBuffer(data))) { return new hdErrors.UnrecognizedArgument('expected buffer or string'); } if (!Base58.validCharacters(data)) { return new errors.InvalidB58Char('(unknown)', data); } try { data = Base58Check.decode(data); } catch (e) { return new errors.InvalidB58Checksum(data); } if (data.length !== HDPublicKey.DataSize) { return new hdErrors.InvalidLength(data); } if (!_.isUndefined(network)) { var error = HDPublicKey._validateNetwork(data, network); if (error) { return error; } } var version = BufferUtil.integerFromBuffer(data.slice(0, 4)); if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) { return new hdErrors.ArgumentIsPrivateExtended(); } return null; }; HDPublicKey._validateNetwork = function(data, networkArg) { var network = Network.get(networkArg); if (!network) { return new errors.InvalidNetworkArgument(networkArg); } var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd); if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) { return new errors.InvalidNetwork(version); } return null; }; HDPublicKey.prototype._buildFromPrivate = function (arg) { var args = _.clone(arg._buffers); var point = Point.getG().mul(BN.fromBuffer(args.privateKey)); args.publicKey = Point.pointToCompressed(point); args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey); args.privateKey = undefined; args.checksum = undefined; args.xprivkey = undefined; return this._buildFromBuffers(args); }; HDPublicKey.prototype._buildFromObject = function(arg) { /* jshint maxcomplexity: 10 */ // TODO: Type validation var buffers = { version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version, depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth, parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint, childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex, chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode, publicKey: _.isString(arg.publicKey) ? BufferUtil.hexToBuffer(arg.publicKey) : BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(), checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum }; return this._buildFromBuffers(buffers); }; HDPublicKey.prototype._buildFromSerialized = function(arg) { var decoded = Base58Check.decode(arg); var buffers = { version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd), depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd), parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart, HDPublicKey.ParentFingerPrintEnd), childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd), chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd), publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd), checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd), xpubkey: arg }; return this._buildFromBuffers(buffers); }; /** * Receives a object with buffers in all the properties and populates the * internal structure * * @param {Object} arg * @param {buffer.Buffer} arg.version * @param {buffer.Buffer} arg.depth * @param {buffer.Buffer} arg.parentFingerPrint * @param {buffer.Buffer} arg.childIndex * @param {buffer.Buffer} arg.chainCode * @param {buffer.Buffer} arg.publicKey * @param {buffer.Buffer} arg.checksum * @param {string=} arg.xpubkey - if set, don't recalculate the base58 * representation * @return {HDPublicKey} this */ HDPublicKey.prototype._buildFromBuffers = function(arg) { /* jshint maxcomplexity: 8 */ /* jshint maxstatements: 20 */ HDPublicKey._validateBufferArguments(arg); JSUtil.defineImmutable(this, { _buffers: arg }); var sequence = [ arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, arg.publicKey ]; var concat = BufferUtil.concat(sequence); var checksum = Base58Check.checksum(concat); if (!arg.checksum || !arg.checksum.length) { arg.checksum = checksum; } else { if (arg.checksum.toString('hex') !== checksum.toString('hex')) { throw new errors.InvalidB58Checksum(concat, checksum); } } var network = Network.get(BufferUtil.integerFromBuffer(arg.version)); var xpubkey; xpubkey = Base58Check.encode(BufferUtil.concat(sequence)); arg.xpubkey = new Buffer(xpubkey); var publicKey = new PublicKey(arg.publicKey, {network: network}); var size = HDPublicKey.ParentFingerPrintSize; var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size); JSUtil.defineImmutable(this, { xpubkey: xpubkey, network: network, depth: BufferUtil.integerFromSingleByteBuffer(arg.depth), publicKey: publicKey, fingerPrint: fingerPrint }); return this; }; HDPublicKey._validateBufferArguments = function(arg) { var checkBuffer = function(name, size) { var buff = arg[name]; assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\'s ' + typeof buff); assert( buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size ); }; checkBuffer('version', HDPublicKey.VersionSize); checkBuffer('depth', HDPublicKey.DepthSize); checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize); checkBuffer('childIndex', HDPublicKey.ChildIndexSize); checkBuffer('chainCode', HDPublicKey.ChainCodeSize); checkBuffer('publicKey', HDPublicKey.PublicKeySize); if (arg.checksum && arg.checksum.length) { checkBuffer('checksum', HDPublicKey.CheckSumSize); } }; HDPublicKey.fromString = function(arg) { $.checkArgument(_.isString(arg), 'No valid string was provided'); return new HDPublicKey(arg); }; HDPublicKey.fromObject = function(arg) { $.checkArgument(_.isObject(arg), 'No valid argument was provided'); return new HDPublicKey(arg); }; /** * Returns the base58 checked representation of the public key * @return {string} a string starting with "xpub..." in livenet */ HDPublicKey.prototype.toString = function() { return this.xpubkey; }; /** * Returns the console representation of this extended public key. * @return string */ HDPublicKey.prototype.inspect = function() { return '<HDPublicKey: ' + this.xpubkey + '>'; }; /** * Returns a plain JavaScript object with information to reconstruct a key. * * Fields are: <ul> * <li> network: 'livenet' or 'testnet' * <li> depth: a number from 0 to 255, the depth to the master extended key * <li> fingerPrint: a number of 32 bits taken from the hash of the public key * <li> fingerPrint: a number of 32 bits taken from the hash of this key's * <li> parent's public key * <li> childIndex: index with which this key was derived * <li> chainCode: string in hexa encoding used for derivation * <li> publicKey: string, hexa encoded, in compressed key format * <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum), * <li> xpubkey: the string with the base58 representation of this extended key * <li> checksum: the base58 checksum of xpubkey * </ul> */ HDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() { return { network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name, depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth), fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint), parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint), childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex), chainCode: BufferUtil.bufferToHex(this._buffers.chainCode), publicKey: this.publicKey.toString(), checksum: BufferUtil.integerFromBuffer(this._buffers.checksum), xpubkey: this.xpubkey }; }; /** * Create a HDPublicKey from a buffer argument * * @param {Buffer} arg * @return {HDPublicKey} */ HDPublicKey.fromBuffer = function(arg) { return new HDPublicKey(arg); }; /** * Return a buffer representation of the xpubkey * * @return {Buffer} */ HDPublicKey.prototype.toBuffer = function() { return BufferUtil.copy(this._buffers.xpubkey); }; HDPublicKey.Hardened = 0x80000000; HDPublicKey.RootElementAlias = ['m', 'M']; HDPublicKey.VersionSize = 4; HDPublicKey.DepthSize = 1; HDPublicKey.ParentFingerPrintSize = 4; HDPublicKey.ChildIndexSize = 4; HDPublicKey.ChainCodeSize = 32; HDPublicKey.PublicKeySize = 33; HDPublicKey.CheckSumSize = 4; HDPublicKey.DataSize = 78; HDPublicKey.SerializedByteSize = 82; HDPublicKey.VersionStart = 0; HDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize; HDPublicKey.DepthStart = HDPublicKey.VersionEnd; HDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize; HDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd; HDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize; HDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd; HDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize; HDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd; HDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize; HDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd; HDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize; HDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd; HDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize; assert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize); assert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize); module.exports = HDPublicKey; }).call(this,require("buffer").Buffer) },{"./crypto/bn":104,"./crypto/hash":106,"./crypto/point":107,"./encoding/base58":110,"./encoding/base58check":111,"./errors":115,"./hdprivatekey":117,"./networks":119,"./publickey":122,"./util/buffer":141,"./util/js":142,"./util/preconditions":143,"assert":29,"buffer":75,"lodash":146}],119:[function(require,module,exports){ 'use strict'; var _ = require('lodash'); var BufferUtil = require('./util/buffer'); var JSUtil = require('./util/js'); var networks = []; var networkMaps = {}; /** * A network is merely a map containing values that correspond to version * numbers for each bitcoin network. Currently only supporting "livenet" * (a.k.a. "mainnet") and "testnet". * @constructor */ function Network() {} Network.prototype.toString = function toString() { return this.name; }; /** * @function * @member Networks#get * Retrieves the network associated with a magic number or string. * @param {string|number|Network} arg * @param {string|Array} keys - if set, only check if the magic number associated with this name matches * @return Network */ function get(arg, keys) { if (~networks.indexOf(arg)) { return arg; } if (keys) { if (!_.isArray(keys)) { keys = [keys]; } var containsArg = function(key) { return networks[index][key] === arg; }; for (var index in networks) { if (_.some(keys, containsArg)) { return networks[index]; } } return undefined; } return networkMaps[arg]; } /** * @function * @member Networks#add * Will add a custom Network * @param {Object} data * @param {string} data.name - The name of the network * @param {string} data.alias - The aliased name of the network * @param {Number} data.pubkeyhash - The publickey hash prefix * @param {Number} data.privatekey - The privatekey prefix * @param {Number} data.scripthash - The scripthash prefix * @param {Number} data.xpubkey - The extended public key magic * @param {Number} data.xprivkey - The extended private key magic * @param {Number} data.networkMagic - The network magic number * @param {Number} data.port - The network port * @param {Array} data.dnsSeeds - An array of dns seeds * @return Network */ function addNetwork(data) { var network = new Network(); JSUtil.defineImmutable(network, { name: data.name, alias: data.alias, pubkeyhash: data.pubkeyhash, privatekey: data.privatekey, privatekeyOld: data.privatekeyOld, scripthash: data.scripthash, scripthashTwo: data.scripthashTwo || '', xpubkey: data.xpubkey, xprivkey: data.xprivkey }); if (data.networkMagic) { JSUtil.defineImmutable(network, { networkMagic: BufferUtil.integerAsBuffer(data.networkMagic) }); } if (data.port) { JSUtil.defineImmutable(network, { port: data.port }); } if (data.dnsSeeds) { JSUtil.defineImmutable(network, { dnsSeeds: data.dnsSeeds }); } _.each(network, function(value) { if (!_.isUndefined(value) && !_.isObject(value)) { networkMaps[value] = network; } }); networks.push(network); return network; } /** * @function * @member Networks#remove * Will remove a custom network * @param {Network} network */ function removeNetwork(network) { for (var i = 0; i < networks.length; i++) { if (networks[i] === network) { networks.splice(i, 1); } } for (var key in networkMaps) { if (networkMaps[key] === network) { delete networkMaps[key]; } } } addNetwork({ name: 'livenet', alias: 'mainnet', pubkeyhash: 0x1e, privatekey: 0x80, privatekeyOld: 0x9e, scripthash: 0x3f, scripthashTwo: 0x05, xpubkey: 0x0488b21e, xprivkey: 0x0488ade4, networkMagic: 0xfac3b6da, port: 12024, dnsSeeds: [ 'seed.digibyte.co', 'seed.digibyte.io', 'digiexplorer.info' ] }); /** * @instance * @member Networks#livenet */ var livenet = get('livenet'); addNetwork({ name: 'testnet', alias: 'regtest', pubkeyhash: 0x6f, privatekey: 0xef, scripthash: 0xc4, xpubkey: 0x043587cf, xprivkey: 0x04358394 }); /** * @instance * @member Networks#testnet */ var testnet = get('testnet'); // Add configurable values for testnet/regtest var TESTNET = { PORT: 18333, NETWORK_MAGIC: BufferUtil.integerAsBuffer(0x0b110907), DNS_SEEDS: [ 'testnet-seed.bitcoin.petertodd.org', 'testnet-seed.bluematt.me', 'testnet-seed.alexykot.me', 'testnet-seed.bitcoin.schildbach.de' ] }; for (var key in TESTNET) { if (!_.isObject(TESTNET[key])) { networkMaps[TESTNET[key]] = testnet; } } var REGTEST = { PORT: 18444, NETWORK_MAGIC: BufferUtil.integerAsBuffer(0xfabfb5da), DNS_SEEDS: [] }; for (var key in REGTEST) { if (!_.isObject(REGTEST[key])) { networkMaps[REGTEST[key]] = testnet; } } Object.defineProperty(testnet, 'port', { enumerable: true, configurable: false, get: function() { if (this.regtestEnabled) { return REGTEST.PORT; } else { return TESTNET.PORT; } } }); Object.defineProperty(testnet, 'networkMagic', { enumerable: true, configurable: false, get: function() { if (this.regtestEnabled) { return REGTEST.NETWORK_MAGIC; } else { return TESTNET.NETWORK_MAGIC; } } }); Object.defineProperty(testnet, 'dnsSeeds', { enumerable: true, configurable: false, get: function() { if (this.regtestEnabled) { return REGTEST.DNS_SEEDS; } else { return TESTNET.DNS_SEEDS; } } }); /** * @function * @member Networks#enableRegtest * Will enable regtest features for testnet */ function enableRegtest() { testnet.regtestEnabled = true; } /** * @function * @member Networks#disableRegtest * Will disable regtest features for testnet */ function disableRegtest() { testnet.regtestEnabled = false; } /** * @namespace Networks */ module.exports = { add: addNetwork, remove: removeNetwork, defaultNetwork: livenet, livenet: livenet, mainnet: livenet, testnet: testnet, get: get, enableRegtest: enableRegtest, disableRegtest: disableRegtest }; },{"./util/buffer":141,"./util/js":142,"lodash":146}],120:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var $ = require('./util/preconditions'); var BufferUtil = require('./util/buffer'); var JSUtil = require('./util/js'); function Opcode(num) { if (!(this instanceof Opcode)) { return new Opcode(num); } var value; if (_.isNumber(num)) { value = num; } else if (_.isString(num)) { value = Opcode.map[num]; } else { throw new TypeError('Unrecognized num type: "' + typeof(num) + '" for Opcode'); } JSUtil.defineImmutable(this, { num: value }); return this; } Opcode.fromBuffer = function(buf) { $.checkArgument(BufferUtil.isBuffer(buf)); return new Opcode(Number('0x' + buf.toString('hex'))); }; Opcode.fromNumber = function(num) { $.checkArgument(_.isNumber(num)); return new Opcode(num); }; Opcode.fromString = function(str) { $.checkArgument(_.isString(str)); var value = Opcode.map[str]; if (typeof value === 'undefined') { throw new TypeError('Invalid opcodestr'); } return new Opcode(value); }; Opcode.prototype.toHex = function() { return this.num.toString(16); }; Opcode.prototype.toBuffer = function() { return new Buffer(this.toHex(), 'hex'); }; Opcode.prototype.toNumber = function() { return this.num; }; Opcode.prototype.toString = function() { var str = Opcode.reverseMap[this.num]; if (typeof str === 'undefined') { throw new Error('Opcode does not have a string representation'); } return str; }; Opcode.smallInt = function(n) { $.checkArgument(_.isNumber(n), 'Invalid Argument: n should be number'); $.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16'); if (n === 0) { return Opcode('OP_0'); } return new Opcode(Opcode.map.OP_1 + n - 1); }; Opcode.map = { // push value OP_FALSE: 0, OP_0: 0, OP_PUSHDATA1: 76, OP_PUSHDATA2: 77, OP_PUSHDATA4: 78, OP_1NEGATE: 79, OP_RESERVED: 80, OP_TRUE: 81, OP_1: 81, OP_2: 82, OP_3: 83, OP_4: 84, OP_5: 85, OP_6: 86, OP_7: 87, OP_8: 88, OP_9: 89, OP_10: 90, OP_11: 91, OP_12: 92, OP_13: 93, OP_14: 94, OP_15: 95, OP_16: 96, // control OP_NOP: 97, OP_VER: 98, OP_IF: 99, OP_NOTIF: 100, OP_VERIF: 101, OP_VERNOTIF: 102, OP_ELSE: 103, OP_ENDIF: 104, OP_VERIFY: 105, OP_RETURN: 106, // stack ops OP_TOALTSTACK: 107, OP_FROMALTSTACK: 108, OP_2DROP: 109, OP_2DUP: 110, OP_3DUP: 111, OP_2OVER: 112, OP_2ROT: 113, OP_2SWAP: 114, OP_IFDUP: 115, OP_DEPTH: 116, OP_DROP: 117, OP_DUP: 118, OP_NIP: 119, OP_OVER: 120, OP_PICK: 121, OP_ROLL: 122, OP_ROT: 123, OP_SWAP: 124, OP_TUCK: 125, // splice ops OP_CAT: 126, OP_SUBSTR: 127, OP_LEFT: 128, OP_RIGHT: 129, OP_SIZE: 130, // bit logic OP_INVERT: 131, OP_AND: 132, OP_OR: 133, OP_XOR: 134, OP_EQUAL: 135, OP_EQUALVERIFY: 136, OP_RESERVED1: 137, OP_RESERVED2: 138, // numeric OP_1ADD: 139, OP_1SUB: 140, OP_2MUL: 141, OP_2DIV: 142, OP_NEGATE: 143, OP_ABS: 144, OP_NOT: 145, OP_0NOTEQUAL: 146, OP_ADD: 147, OP_SUB: 148, OP_MUL: 149, OP_DIV: 150, OP_MOD: 151, OP_LSHIFT: 152, OP_RSHIFT: 153, OP_BOOLAND: 154, OP_BOOLOR: 155, OP_NUMEQUAL: 156, OP_NUMEQUALVERIFY: 157, OP_NUMNOTEQUAL: 158, OP_LESSTHAN: 159, OP_GREATERTHAN: 160, OP_LESSTHANOREQUAL: 161, OP_GREATERTHANOREQUAL: 162, OP_MIN: 163, OP_MAX: 164, OP_WITHIN: 165, // crypto OP_RIPEMD160: 166, OP_SHA1: 167, OP_SHA256: 168, OP_HASH160: 169, OP_HASH256: 170, OP_CODESEPARATOR: 171, OP_CHECKSIG: 172, OP_CHECKSIGVERIFY: 173, OP_CHECKMULTISIG: 174, OP_CHECKMULTISIGVERIFY: 175, OP_CHECKLOCKTIMEVERIFY: 177, // expansion OP_NOP1: 176, OP_NOP2: 177, OP_NOP3: 178, OP_NOP4: 179, OP_NOP5: 180, OP_NOP6: 181, OP_NOP7: 182, OP_NOP8: 183, OP_NOP9: 184, OP_NOP10: 185, // template matching params OP_PUBKEYHASH: 253, OP_PUBKEY: 254, OP_INVALIDOPCODE: 255 }; Opcode.reverseMap = []; for (var k in Opcode.map) { Opcode.reverseMap[Opcode.map[k]] = k; } // Easier access to opcodes _.extend(Opcode, Opcode.map); /** * @returns true if opcode is one of OP_0, OP_1, ..., OP_16 */ Opcode.isSmallIntOp = function(opcode) { if (opcode instanceof Opcode) { opcode = opcode.toNumber(); } return ((opcode === Opcode.map.OP_0) || ((opcode >= Opcode.map.OP_1) && (opcode <= Opcode.map.OP_16))); }; /** * Will return a string formatted for the console * * @returns {string} Script opcode */ Opcode.prototype.inspect = function() { return '<Opcode: ' + this.toString() + ', hex: '+this.toHex()+', decimal: '+this.num+'>'; }; module.exports = Opcode; }).call(this,require("buffer").Buffer) },{"./util/buffer":141,"./util/js":142,"./util/preconditions":143,"buffer":75,"lodash":146}],121:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var Address = require('./address'); var Base58Check = require('./encoding/base58check'); var BN = require('./crypto/bn'); var JSUtil = require('./util/js'); var Networks = require('./networks'); var Point = require('./crypto/point'); var PublicKey = require('./publickey'); var Random = require('./crypto/random'); var $ = require('./util/preconditions'); /** * Instantiate a PrivateKey from a BN, Buffer and WIF. * * @example * ```javascript * // generate a new random key * var key = PrivateKey(); * * // get the associated address * var address = key.toAddress(); * * // encode into wallet export format * var exported = key.toWIF(); * * // instantiate from the exported (and saved) private key * var imported = PrivateKey.fromWIF(exported); * ``` * * @param {string} data - The encoded data in various formats * @param {Network|string=} network - a {@link Network} object, or a string with the network name * @returns {PrivateKey} A new valid instance of an PrivateKey * @constructor */ function PrivateKey(data, network) { /* jshint maxstatements: 20 */ /* jshint maxcomplexity: 8 */ if (!(this instanceof PrivateKey)) { return new PrivateKey(data, network); } if (data instanceof PrivateKey) { return data; } var info = this._classifyArguments(data, network); // validation if (!info.bn || info.bn.cmp(new BN(0)) === 0){ throw new TypeError('Number can not be equal to zero, undefined, null or false'); } if (!info.bn.lt(Point.getN())) { throw new TypeError('Number must be less than N'); } if (typeof(info.network) === 'undefined') { throw new TypeError('Must specify the network ("livenet" or "testnet")'); } JSUtil.defineImmutable(this, { bn: info.bn, compressed: info.compressed, network: info.network }); Object.defineProperty(this, 'publicKey', { configurable: false, enumerable: true, get: this.toPublicKey.bind(this) }); return this; }; /** * Internal helper to instantiate PrivateKey internal `info` object from * different kinds of arguments passed to the constructor. * * @param {*} data * @param {Network|string=} network - a {@link Network} object, or a string with the network name * @return {Object} */ PrivateKey.prototype._classifyArguments = function(data, network) { /* jshint maxcomplexity: 10 */ var info = { compressed: true, network: network ? Networks.get(network) : Networks.defaultNetwork }; // detect type of data if (_.isUndefined(data) || _.isNull(data)){ info.bn = PrivateKey._getRandomBN(); } else if (data instanceof BN) { info.bn = data; } else if (data instanceof Buffer || data instanceof Uint8Array) { info = PrivateKey._transformBuffer(data, network); } else if (data.bn && data.network){ info = PrivateKey._transformObject(data); } else if (!network && Networks.get(data)) { info.bn = PrivateKey._getRandomBN(); info.network = Networks.get(data); } else if (typeof(data) === 'string'){ if (JSUtil.isHexa(data)) { info.bn = new BN(new Buffer(data, 'hex')); } else { info = PrivateKey._transformWIF(data, network); } } else { throw new TypeError('First argument is an unrecognized data type.'); } return info; }; /** * Internal function to get a random Big Number (BN) * * @returns {BN} A new randomly generated BN * @private */ PrivateKey._getRandomBN = function(){ var condition; var bn; do { var privbuf = Random.getRandomBuffer(32); bn = BN.fromBuffer(privbuf); condition = bn.lt(Point.getN()); } while (!condition); return bn; }; /** * Internal function to transform a WIF Buffer into a private key * * @param {Buffer} buf - An WIF string * @param {Network|string=} network - a {@link Network} object, or a string with the network name * @returns {Object} An object with keys: bn, network and compressed * @private */ PrivateKey._transformBuffer = function(buf, network) { var info = {}; if (buf.length === 32) { return PrivateKey._transformBNBuffer(buf, network); } info.network = Networks.get(buf[0], 'privatekey') || Networks.get(buf[0], 'privatekeyOld'); if (!info.network) { throw new Error('Invalid network'); } if (network && info.network !== Networks.get(network)) { throw new TypeError('Private key network mismatch'); } if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) { info.compressed = true; } else if (buf.length === 1 + 32) { info.compressed = false; } else { throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)'); } info.bn = BN.fromBuffer(buf.slice(1, 32 + 1)); return info; }; /** * Internal function to transform a BN buffer into a private key * * @param {Buffer} buf * @param {Network|string=} network - a {@link Network} object, or a string with the network name * @returns {object} an Object with keys: bn, network, and compressed * @private */ PrivateKey._transformBNBuffer = function(buf, network) { var info = {}; info.network = Networks.get(network) || Networks.defaultNetwork; info.bn = BN.fromBuffer(buf); info.compressed = false; return info; }; /** * Internal function to transform a WIF string into a private key * * @param {string} buf - An WIF string * @returns {Object} An object with keys: bn, network and compressed * @private */ PrivateKey._transformWIF = function(str, network) { return PrivateKey._transformBuffer(Base58Check.decode(str), network); }; /** * Instantiate a PrivateKey from a Buffer with the DER or WIF representation * * @param {Buffer} arg * @param {Network} network * @return {PrivateKey} */ PrivateKey.fromBuffer = function(arg, network) { return new PrivateKey(arg, network); }; /** * Internal function to transform a JSON string on plain object into a private key * return this. * * @param {string} json - A JSON string or plain object * @returns {Object} An object with keys: bn, network and compressed * @private */ PrivateKey._transformObject = function(json) { var bn = new BN(json.bn, 'hex'); var network = Networks.get(json.network); return { bn: bn, network: network, compressed: json.compressed }; }; /** * Instantiate a PrivateKey from a WIF string * * @param {string} str - The WIF encoded private key string * @returns {PrivateKey} A new valid instance of PrivateKey */ PrivateKey.fromString = PrivateKey.fromWIF = function(str) { $.checkArgument(_.isString(str), 'First argument is expected to be a string.'); return new PrivateKey(str); }; /** * Instantiate a PrivateKey from a plain JavaScript object * * @param {Object} obj - The output from privateKey.toObject() */ PrivateKey.fromObject = function(obj) { $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.'); return new PrivateKey(obj); }; /** * Instantiate a PrivateKey from random bytes * * @param {string=} network - Either "livenet" or "testnet" * @returns {PrivateKey} A new valid instance of PrivateKey */ PrivateKey.fromRandom = function(network) { var bn = PrivateKey._getRandomBN(); return new PrivateKey(bn, network); }; /** * Check if there would be any errors when initializing a PrivateKey * * @param {string} data - The encoded data in various formats * @param {string=} network - Either "livenet" or "testnet" * @returns {null|Error} An error if exists */ PrivateKey.getValidationError = function(data, network) { var error; try { /* jshint nonew: false */ new PrivateKey(data, network); } catch (e) { error = e; } return error; }; /** * Check if the parameters are valid * * @param {string} data - The encoded data in various formats * @param {string=} network - Either "livenet" or "testnet" * @returns {Boolean} If the private key is would be valid */ PrivateKey.isValid = function(data, network){ if (!data) { return false; } return !PrivateKey.getValidationError(data, network); }; /** * Will output the PrivateKey encoded as hex string * * @returns {string} */ PrivateKey.prototype.toString = function() { return this.toBuffer().toString('hex'); }; /** * Will output the PrivateKey to a WIF string * * @returns {string} A WIP representation of the private key */ PrivateKey.prototype.toWIF = function() { var network = this.network; var compressed = this.compressed; var buf; if (compressed) { buf = Buffer.concat([new Buffer([network.privatekey]), this.bn.toBuffer({size: 32}), new Buffer([0x01])]); } else { buf = Buffer.concat([new Buffer([network.privatekey]), this.bn.toBuffer({size: 32})]); } return Base58Check.encode(buf); }; /** * Will return the private key as a BN instance * * @returns {BN} A BN instance of the private key */ PrivateKey.prototype.toBigNumber = function(){ return this.bn; }; /** * Will return the private key as a BN buffer * * @returns {Buffer} A buffer of the private key */ PrivateKey.prototype.toBuffer = function(){ // TODO: use `return this.bn.toBuffer({ size: 32 })` in v1.0.0 return this.bn.toBuffer(); }; /** * WARNING: This method will not be officially supported until v1.0.0. * * * Will return the private key as a BN buffer without leading zero padding * * @returns {Buffer} A buffer of the private key */ PrivateKey.prototype.toBufferNoPadding = function() { return this.bn.toBuffer(); }; /** * Will return the corresponding public key * * @returns {PublicKey} A public key generated from the private key */ PrivateKey.prototype.toPublicKey = function(){ if (!this._pubkey) { this._pubkey = PublicKey.fromPrivateKey(this); } return this._pubkey; }; /** * Will return an address for the private key * @param {Network=} network - optional parameter specifying * the desired network for the address * * @returns {Address} An address generated from the private key */ PrivateKey.prototype.toAddress = function(network) { var pubkey = this.toPublicKey(); return Address.fromPublicKey(pubkey, network || this.network); }; /** * @returns {Object} A plain object representation */ PrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() { return { bn: this.bn.toString('hex'), compressed: this.compressed, network: this.network.toString() }; }; /** * Will return a string formatted for the console * * @returns {string} Private key */ PrivateKey.prototype.inspect = function() { var uncompressed = !this.compressed ? ', uncompressed' : ''; return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>'; }; module.exports = PrivateKey; }).call(this,require("buffer").Buffer) },{"./address":99,"./crypto/bn":104,"./crypto/point":107,"./crypto/random":108,"./encoding/base58check":111,"./networks":119,"./publickey":122,"./util/js":142,"./util/preconditions":143,"buffer":75,"lodash":146}],122:[function(require,module,exports){ (function (Buffer){ 'use strict'; var BN = require('./crypto/bn'); var Point = require('./crypto/point'); var Hash = require('./crypto/hash'); var JSUtil = require('./util/js'); var Network = require('./networks'); var _ = require('lodash'); var $ = require('./util/preconditions'); /** * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`. * * There are two internal properties, `network` and `compressed`, that deal with importing * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey} * * @example * ```javascript * // instantiate from a private key * var key = PublicKey(privateKey, true); * * // export to as a DER hex encoded string * var exported = key.toString(); * * // import the public key * var imported = PublicKey.fromString(exported); * ``` * * @param {string} data - The encoded data in various formats * @param {Object} extra - additional options * @param {Network=} extra.network - Which network should the address for this public key be for * @param {String=} extra.compressed - If the public key is compressed * @returns {PublicKey} A new valid instance of an PublicKey * @constructor */ function PublicKey(data, extra) { if (!(this instanceof PublicKey)) { return new PublicKey(data, extra); } $.checkArgument(data, 'First argument is required, please include public key data.'); if (data instanceof PublicKey) { // Return copy, but as it's an immutable object, return same argument return data; } extra = extra || {}; var info = this._classifyArgs(data, extra); // validation info.point.validate(); JSUtil.defineImmutable(this, { point: info.point, compressed: info.compressed, network: info.network || Network.defaultNetwork }); return this; }; /** * Internal function to differentiate between arguments passed to the constructor * @param {*} data * @param {Object} extra */ PublicKey.prototype._classifyArgs = function(data, extra) { /* jshint maxcomplexity: 10 */ var info = { compressed: _.isUndefined(extra.compressed) || extra.compressed }; // detect type of data if (data instanceof Point) { info.point = data; } else if (data.x && data.y) { info = PublicKey._transformObject(data); } else if (typeof(data) === 'string') { info = PublicKey._transformDER(new Buffer(data, 'hex')); } else if (PublicKey._isBuffer(data)) { info = PublicKey._transformDER(data); } else if (PublicKey._isPrivateKey(data)) { info = PublicKey._transformPrivateKey(data); } else { throw new TypeError('First argument is an unrecognized data format.'); } if (!info.network) { info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network); } return info; }; /** * Internal function to detect if an object is a {@link PrivateKey} * * @param {*} param - object to test * @returns {boolean} * @private */ PublicKey._isPrivateKey = function(param) { var PrivateKey = require('./privatekey'); return param instanceof PrivateKey; }; /** * Internal function to detect if an object is a Buffer * * @param {*} param - object to test * @returns {boolean} * @private */ PublicKey._isBuffer = function(param) { return (param instanceof Buffer) || (param instanceof Uint8Array); }; /** * Internal function to transform a private key into a public key point * * @param {PrivateKey} privkey - An instance of PrivateKey * @returns {Object} An object with keys: point and compressed * @private */ PublicKey._transformPrivateKey = function(privkey) { $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey'); var info = {}; info.point = Point.getG().mul(privkey.bn); info.compressed = privkey.compressed; info.network = privkey.network; return info; }; /** * Internal function to transform DER into a public key point * * @param {Buffer} buf - An hex encoded buffer * @param {bool=} strict - if set to false, will loosen some conditions * @returns {Object} An object with keys: point and compressed * @private */ PublicKey._transformDER = function(buf, strict) { /* jshint maxstatements: 30 */ /* jshint maxcomplexity: 12 */ $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key'); var info = {}; strict = _.isUndefined(strict) ? true : strict; var x; var y; var xbuf; var ybuf; if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) { xbuf = buf.slice(1, 33); ybuf = buf.slice(33, 65); if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) { throw new TypeError('Length of x and y must be 32 bytes'); } x = new BN(xbuf); y = new BN(ybuf); info.point = new Point(x, y); info.compressed = false; } else if (buf[0] === 0x03) { xbuf = buf.slice(1); x = new BN(xbuf); info = PublicKey._transformX(true, x); info.compressed = true; } else if (buf[0] === 0x02) { xbuf = buf.slice(1); x = new BN(xbuf); info = PublicKey._transformX(false, x); info.compressed = true; } else { throw new TypeError('Invalid DER format public key'); } return info; }; /** * Internal function to transform X into a public key point * * @param {Boolean} odd - If the point is above or below the x axis * @param {Point} x - The x point * @returns {Object} An object with keys: point and compressed * @private */ PublicKey._transformX = function(odd, x) { $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)'); var info = {}; info.point = Point.fromX(odd, x); return info; }; /** * Internal function to transform a JSON into a public key point * * @param {String|Object} json - a JSON string or plain object * @returns {Object} An object with keys: point and compressed * @private */ PublicKey._transformObject = function(json) { var x = new BN(json.x, 'hex'); var y = new BN(json.y, 'hex'); var point = new Point(x, y); return new PublicKey(point, { compressed: json.compressed }); }; /** * Instantiate a PublicKey from a PrivateKey * * @param {PrivateKey} privkey - An instance of PrivateKey * @returns {PublicKey} A new valid instance of PublicKey */ PublicKey.fromPrivateKey = function(privkey) { $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey'); var info = PublicKey._transformPrivateKey(privkey); return new PublicKey(info.point, { compressed: info.compressed, network: info.network }); }; /** * Instantiate a PublicKey from a Buffer * @param {Buffer} buf - A DER hex buffer * @param {bool=} strict - if set to false, will loosen some conditions * @returns {PublicKey} A new valid instance of PublicKey */ PublicKey.fromDER = PublicKey.fromBuffer = function(buf, strict) { $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key'); var info = PublicKey._transformDER(buf, strict); return new PublicKey(info.point, { compressed: info.compressed }); }; /** * Instantiate a PublicKey from a Point * * @param {Point} point - A Point instance * @param {boolean=} compressed - whether to store this public key as compressed format * @returns {PublicKey} A new valid instance of PublicKey */ PublicKey.fromPoint = function(point, compressed) { $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.'); return new PublicKey(point, { compressed: compressed }); }; /** * Instantiate a PublicKey from a DER hex encoded string * * @param {string} str - A DER hex string * @param {String=} encoding - The type of string encoding * @returns {PublicKey} A new valid instance of PublicKey */ PublicKey.fromString = function(str, encoding) { var buf = new Buffer(str, encoding || 'hex'); var info = PublicKey._transformDER(buf); return new PublicKey(info.point, { compressed: info.compressed }); }; /** * Instantiate a PublicKey from an X Point * * @param {Boolean} odd - If the point is above or below the x axis * @param {Point} x - The x point * @returns {PublicKey} A new valid instance of PublicKey */ PublicKey.fromX = function(odd, x) { var info = PublicKey._transformX(odd, x); return new PublicKey(info.point, { compressed: info.compressed }); }; /** * Check if there would be any errors when initializing a PublicKey * * @param {string} data - The encoded data in various formats * @returns {null|Error} An error if exists */ PublicKey.getValidationError = function(data) { var error; try { /* jshint nonew: false */ new PublicKey(data); } catch (e) { error = e; } return error; }; /** * Check if the parameters are valid * * @param {string} data - The encoded data in various formats * @returns {Boolean} If the public key would be valid */ PublicKey.isValid = function(data) { return !PublicKey.getValidationError(data); }; /** * @returns {Object} A plain object of the PublicKey */ PublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() { return { x: this.point.getX().toString('hex', 2), y: this.point.getY().toString('hex', 2), compressed: this.compressed }; }; /** * Will output the PublicKey to a DER Buffer * * @returns {Buffer} A DER hex encoded buffer */ PublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() { var x = this.point.getX(); var y = this.point.getY(); var xbuf = x.toBuffer({ size: 32 }); var ybuf = y.toBuffer({ size: 32 }); var prefix; if (!this.compressed) { prefix = new Buffer([0x04]); return Buffer.concat([prefix, xbuf, ybuf]); } else { var odd = ybuf[ybuf.length - 1] % 2; if (odd) { prefix = new Buffer([0x03]); } else { prefix = new Buffer([0x02]); } return Buffer.concat([prefix, xbuf]); } }; /** * Will return a sha256 + ripemd160 hash of the serialized public key * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141 * @returns {Buffer} */ PublicKey.prototype._getID = function _getID() { return Hash.sha256ripemd160(this.toBuffer()); }; /** * Will return an address for the public key * * @param {String|Network=} network - Which network should the address be for * @returns {Address} An address generated from the public key */ PublicKey.prototype.toAddress = function(network) { var Address = require('./address'); return Address.fromPublicKey(this, network || this.network); }; /** * Will output the PublicKey to a DER encoded hex string * * @returns {string} A DER hex encoded string */ PublicKey.prototype.toString = function() { return this.toDER().toString('hex'); }; /** * Will return a string formatted for the console * * @returns {string} Public key */ PublicKey.prototype.inspect = function() { return '<PublicKey: ' + this.toString() + (this.compressed ? '' : ', uncompressed') + '>'; }; module.exports = PublicKey; }).call(this,require("buffer").Buffer) },{"./address":99,"./crypto/bn":104,"./crypto/hash":106,"./crypto/point":107,"./networks":119,"./privatekey":121,"./util/js":142,"./util/preconditions":143,"buffer":75,"lodash":146}],123:[function(require,module,exports){ module.exports = require('./script'); module.exports.Interpreter = require('./interpreter'); },{"./interpreter":124,"./script":125}],124:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var Script = require('./script'); var Opcode = require('../opcode'); var BN = require('../crypto/bn'); var Hash = require('../crypto/hash'); var Signature = require('../crypto/signature'); var PublicKey = require('../publickey'); /** * Bitcoin transactions contain scripts. Each input has a script called the * scriptSig, and each output has a script called the scriptPubkey. To validate * an input, the input's script is concatenated with the referenced output script, * and the result is executed. If at the end of execution the stack contains a * "true" value, then the transaction is valid. * * The primary way to use this class is via the verify function. * e.g., Interpreter().verify( ... ); */ var Interpreter = function Interpreter(obj) { if (!(this instanceof Interpreter)) { return new Interpreter(obj); } if (obj) { this.initialize(); this.set(obj); } else { this.initialize(); } }; Interpreter.prototype.verifyWitnessProgram = function(version, program, witness, satoshis, flags) { var scriptPubKey = new Script(); var stack = []; if (version === 0) { if (program.length == 32) { if (witness.length == 0) { this.errstr = 'v0 scripthash program empty'; return false; } var scriptPubKeyBuffer = witness[witness.length - 1]; scriptPubKey = new Script(scriptPubKeyBuffer); var hash = Hash.sha256(scriptPubKeyBuffer); if (hash.toString('hex') !== program.toString('hex')) { this.errstr = 'witness program mismatch'; return false; } stack = witness.slice(0, -1); } else if (program.length == 20) { if (witness.length != 2) { this.errstr = 'witness program mismatch'; return false; } scriptPubKey.add(Opcode.OP_DUP).add(Opcode.OP_HASH160).add(program.script).add(Opcode.OP_EQUALVERIFY).add(Opcode.OP_CHECKSIG); stack = witness; } else { this.errstr = 'Witness program wrong length'; return false; } } else if ((flags & this.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)) { this.errstr = 'Upgradeable witness program discouraged'; return false; } else { return true; } this.initialize(); this.set({ script: scriptPubKey, stack: stack, sigversion: 1, satoshis: satoshis }); if (!this.evaluate()) { return false; } if (this.stack.length !== 1) { this.errstr = 'SCRIPT_ERR_EVAL_FALSE'; return false; } var buf = this.stack[this.stack.length - 1]; if (!Interpreter.castToBool(buf)) { this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK'; return false; } return true; }; /** * Verifies a Script by executing it and returns true if it is valid. * This function needs to be provided with the scriptSig and the scriptPubkey * separately. * @param {Script} scriptSig - the script's first part (corresponding to the tx input) * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output) * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used * to check signature validity for some opcodes like OP_CHECKSIG) * @param {number} nin - index of the transaction input containing the scriptSig verified. * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants * @param {number} witness - array of witness data * @param {number} satoshis - number of satoshis created by this output * * Translated from bitcoind's VerifyScript */ Interpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) { var Transaction = require('../transaction'); if (_.isUndefined(tx)) { tx = new Transaction(); } if (_.isUndefined(nin)) { nin = 0; } if (_.isUndefined(flags)) { flags = 0; } if (_.isUndefined(witness)) { witness = null; } if (_.isUndefined(satoshis)) { satoshis = 0; } this.set({ script: scriptSig, tx: tx, nin: nin, sigversion: 0, satoshis: 0, flags: flags }); var stackCopy; if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) { this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY'; return false; } // evaluate scriptSig if (!this.evaluate()) { return false; } if (flags & Interpreter.SCRIPT_VERIFY_P2SH) { stackCopy = this.stack.slice(); } var stack = this.stack; this.initialize(); this.set({ script: scriptPubkey, stack: stack, tx: tx, nin: nin, flags: flags }); // evaluate scriptPubkey if (!this.evaluate()) { return false; } if (this.stack.length === 0) { this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT'; return false; } var buf = this.stack[this.stack.length - 1]; if (!Interpreter.castToBool(buf)) { this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK'; return false; } var hadWitness = false; var version, program; if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) { var witnessValues = {}; if (scriptPubkey.isWitnessProgram(witnessValues)) { hadWitness = true; if (scriptSig.toBuffer().length != 0) { return false; } if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, flags)) { return false; } } } // Additional validation for spend-to-script-hash transactions: if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) { // scriptSig must be literals-only or validation fails if (!scriptSig.isPushOnly()) { this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY'; return false; } // stackCopy cannot be empty here, because if it was the // P2SH HASH <> EQUAL scriptPubKey would be evaluated with // an empty stack and the EvalScript above would return false. if (stackCopy.length === 0) { throw new Error('internal error - stack copy empty'); } var redeemScriptSerialized = stackCopy[stackCopy.length - 1]; var redeemScript = Script.fromBuffer(redeemScriptSerialized); stackCopy.pop(); this.initialize(); this.set({ script: redeemScript, stack: stackCopy, tx: tx, nin: nin, flags: flags }); // evaluate redeemScript if (!this.evaluate()) { return false; } if (stackCopy.length === 0) { this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK'; return false; } if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) { this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK'; return false; } if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) { var witnessValues = {}; if (redeemScript.isWitnessProgram(witnessValues)) { hadWitness = true; var redeemScriptPush = new Script(); redeemScriptPush.add(redeemScript.toBuffer()); if (scriptSig.toHex() !== redeemScriptPush.toHex()) { this.errstr = 'Malleated scriptSig'; return false; } if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, flags)) { return false; } stack = [stack[0]]; } } if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) { if (!hadWitness && witness.length > 0) { this.errstr = 'Witness unexpected'; return false; } } } return true; }; module.exports = Interpreter; Interpreter.prototype.initialize = function(obj) { this.stack = []; this.altstack = []; this.pc = 0; this.satoshis = 0; this.sigversion = 0; this.pbegincodehash = 0; this.nOpCount = 0; this.vfExec = []; this.errstr = ''; this.flags = 0; }; Interpreter.prototype.set = function(obj) { this.script = obj.script || this.script; this.tx = obj.tx || this.tx; this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin; this.stack = obj.stack || this.stack; this.altstack = obj.altack || this.altstack; this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc; this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash; this.sigversion = typeof obj.sigversion !== 'undefined' ? obj.sigversion : this.sigversion; this.satoshis = typeof obj.satoshis !== 'undefined' ? obj.satoshis : this.satoshis; this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount; this.vfExec = obj.vfExec || this.vfExec; this.errstr = obj.errstr || this.errstr; this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags; }; Interpreter.true = new Buffer([1]); Interpreter.false = new Buffer([]); Interpreter.MAX_SCRIPT_ELEMENT_SIZE = 520; Interpreter.LOCKTIME_THRESHOLD = 500000000; Interpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD); // flags taken from bitcoind // bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104 Interpreter.SCRIPT_VERIFY_NONE = 0; // Making v1-v16 witness program non-standard Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = (1 << 12); // Evaluate P2SH subscripts (softfork safe, BIP16). Interpreter.SCRIPT_VERIFY_P2SH = (1 << 0); // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure. // Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be // skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT). Interpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1); // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1) Interpreter.SCRIPT_VERIFY_DERSIG = (1 << 2); // Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure // (softfork safe, BIP62 rule 5). Interpreter.SCRIPT_VERIFY_LOW_S = (1 << 3); // verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7). Interpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4); // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2). Interpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5); // Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct // pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating // any other push causes the script to fail (BIP62 rule 3). // In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4). // (softfork safe) Interpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6); // Discourage use of NOPs reserved for upgrades (NOP1-10) // // Provided so that nodes can avoid accepting or mining transactions // containing executed NOP's whose meaning may change after a soft-fork, // thus rendering the script invalid; with this flag set executing // discouraged NOPs fails the script. This verification flag will never be // a mandatory flag applied to scripts in a block. NOPs that are not // executed, e.g. within an unexecuted IF ENDIF block, are *not* rejected. Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7); // CLTV See BIP65 for details. Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9); Interpreter.SCRIPT_VERIFY_WITNESS = (1 << 10); Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 11); Interpreter.castToBool = function(buf) { for (var i = 0; i < buf.length; i++) { if (buf[i] !== 0) { // can be negative zero if (i === buf.length - 1 && buf[i] === 0x80) { return false; } return true; } } return false; }; /** * Translated from bitcoind's CheckSignatureEncoding */ Interpreter.prototype.checkSignatureEncoding = function(buf) { var sig; if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) { this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT'; return false; } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) { sig = Signature.fromTxFormat(buf); if (!sig.hasLowS()) { this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S'; return false; } } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) { sig = Signature.fromTxFormat(buf); if (!sig.hasDefinedHashtype()) { this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE'; return false; } } return true; }; /** * Translated from bitcoind's CheckPubKeyEncoding */ Interpreter.prototype.checkPubkeyEncoding = function(buf) { if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) { this.errstr = 'SCRIPT_ERR_PUBKEYTYPE'; return false; } return true; }; /** * Based on bitcoind's EvalScript function, with the inner loop moved to * Interpreter.prototype.step() * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104 */ Interpreter.prototype.evaluate = function() { if (this.script.toBuffer().length > 10000) { this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE'; return false; } try { while (this.pc < this.script.chunks.length) { var fSuccess = this.step(); if (!fSuccess) { return false; } } // Size limits if (this.stack.length + this.altstack.length > 1000) { this.errstr = 'SCRIPT_ERR_STACK_SIZE'; return false; } } catch (e) { this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e; return false; } if (this.vfExec.length > 0) { this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL'; return false; } return true; }; /** * Checks a locktime parameter with the transaction's locktime. * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime, * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000 * * See the corresponding code on bitcoin core: * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129 * * @param {BN} nLockTime the locktime read from the script * @return {boolean} true if the transaction's locktime is less than or equal to * the transaction's locktime */ Interpreter.prototype.checkLockTime = function(nLockTime) { // We want to compare apples to apples, so fail the script // unless the type of nLockTime being tested is the same as // the nLockTime in the transaction. if (!( (this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) || (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN)) )) { return false; } // Now that we know we're comparing apples-to-apples, the // comparison is a simple numeric one. if (nLockTime.gt(new BN(this.tx.nLockTime))) { return false; } // Finally the nLockTime feature can be disabled and thus // CHECKLOCKTIMEVERIFY bypassed if every txin has been // finalized by setting nSequence to maxint. The // transaction would be allowed into the blockchain, making // the opcode ineffective. // // Testing if this vin is not final is sufficient to // prevent this condition. Alternatively we could test all // inputs, but testing just this input minimizes the data // required to prove correct CHECKLOCKTIMEVERIFY execution. if (!this.tx.inputs[this.nin].isFinal()) { return false; } return true; } /** * Based on the inner loop of bitcoind's EvalScript function * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104 */ Interpreter.prototype.step = function() { var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0; //bool fExec = !count(vfExec.begin(), vfExec.end(), false); var fExec = (this.vfExec.indexOf(false) === -1); var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript; var sig, pubkey; var fValue, fSuccess; // Read instruction var chunk = this.script.chunks[this.pc]; this.pc++; var opcodenum = chunk.opcodenum; if (_.isUndefined(opcodenum)) { this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE'; return false; } if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) { this.errstr = 'SCRIPT_ERR_PUSH_SIZE'; return false; } // Note how Opcode.OP_RESERVED does not count towards the opcode limit. if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) { this.errstr = 'SCRIPT_ERR_OP_COUNT'; return false; } if (opcodenum === Opcode.OP_CAT || opcodenum === Opcode.OP_SUBSTR || opcodenum === Opcode.OP_LEFT || opcodenum === Opcode.OP_RIGHT || opcodenum === Opcode.OP_INVERT || opcodenum === Opcode.OP_AND || opcodenum === Opcode.OP_OR || opcodenum === Opcode.OP_XOR || opcodenum === Opcode.OP_2MUL || opcodenum === Opcode.OP_2DIV || opcodenum === Opcode.OP_MUL || opcodenum === Opcode.OP_DIV || opcodenum === Opcode.OP_MOD || opcodenum === Opcode.OP_LSHIFT || opcodenum === Opcode.OP_RSHIFT) { this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE'; return false; } if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) { if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) { this.errstr = 'SCRIPT_ERR_MINIMALDATA'; return false; } if (!chunk.buf) { this.stack.push(Interpreter.false); } else if (chunk.len !== chunk.buf.length) { throw new Error('Length of push value not equal to length of data'); } else { this.stack.push(chunk.buf); } } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) { switch (opcodenum) { // Push value case Opcode.OP_1NEGATE: case Opcode.OP_1: case Opcode.OP_2: case Opcode.OP_3: case Opcode.OP_4: case Opcode.OP_5: case Opcode.OP_6: case Opcode.OP_7: case Opcode.OP_8: case Opcode.OP_9: case Opcode.OP_10: case Opcode.OP_11: case Opcode.OP_12: case Opcode.OP_13: case Opcode.OP_14: case Opcode.OP_15: case Opcode.OP_16: { // ( -- value) // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1)); n = opcodenum - (Opcode.OP_1 - 1); buf = new BN(n).toScriptNumBuffer(); this.stack.push(buf); // The result of these opcodes should always be the minimal way to push the data // they push, so no need for a CheckMinimalPush here. } break; // // Control // case Opcode.OP_NOP: break; case Opcode.OP_NOP2: case Opcode.OP_CHECKLOCKTIMEVERIFY: if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) { // not enabled; treat as a NOP2 if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) { this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS'; return false; } break; } if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } // Note that elsewhere numeric opcodes are limited to // operands in the range -2**31+1 to 2**31-1, however it is // legal for opcodes to produce results exceeding that // range. This limitation is implemented by CScriptNum's // default 4-byte limit. // // If we kept to that limit we'd have a year 2038 problem, // even though the nLockTime field in transactions // themselves is uint32 which only becomes meaningless // after the year 2106. // // Thus as a special case we tell CScriptNum to accept up // to 5-byte bignums, which are good until 2**39-1, well // beyond the 2**32-1 limit of the nLockTime field itself. var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5); // In the rare event that the argument may be < 0 due to // some arithmetic being done first, you can always use // 0 MAX CHECKLOCKTIMEVERIFY. if (nLockTime.lt(new BN(0))) { this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME'; return false; } // Actually compare the specified lock time with the transaction. if (!this.checkLockTime(nLockTime)) { this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME'; return false; } break; case Opcode.OP_NOP1: case Opcode.OP_NOP3: case Opcode.OP_NOP4: case Opcode.OP_NOP5: case Opcode.OP_NOP6: case Opcode.OP_NOP7: case Opcode.OP_NOP8: case Opcode.OP_NOP9: case Opcode.OP_NOP10: { if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) { this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS'; return false; } } break; case Opcode.OP_IF: case Opcode.OP_NOTIF: { // <expression> if [statements] [else [statements]] endif // bool fValue = false; fValue = false; if (fExec) { if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL'; return false; } buf = this.stack.pop(); fValue = Interpreter.castToBool(buf); if (opcodenum === Opcode.OP_NOTIF) { fValue = !fValue; } } this.vfExec.push(fValue); } break; case Opcode.OP_ELSE: { if (this.vfExec.length === 0) { this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL'; return false; } this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1]; } break; case Opcode.OP_ENDIF: { if (this.vfExec.length === 0) { this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL'; return false; } this.vfExec.pop(); } break; case Opcode.OP_VERIFY: { // (true -- ) or // (false -- false) and return if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } buf = this.stack[this.stack.length - 1]; fValue = Interpreter.castToBool(buf); if (fValue) { this.stack.pop(); } else { this.errstr = 'SCRIPT_ERR_VERIFY'; return false; } } break; case Opcode.OP_RETURN: { this.errstr = 'SCRIPT_ERR_OP_RETURN'; return false; } break; // // Stack ops // case Opcode.OP_TOALTSTACK: { if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } this.altstack.push(this.stack.pop()); } break; case Opcode.OP_FROMALTSTACK: { if (this.altstack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION'; return false; } this.stack.push(this.altstack.pop()); } break; case Opcode.OP_2DROP: { // (x1 x2 -- ) if (this.stack.length < 2) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } this.stack.pop(); this.stack.pop(); } break; case Opcode.OP_2DUP: { // (x1 x2 -- x1 x2 x1 x2) if (this.stack.length < 2) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } buf1 = this.stack[this.stack.length - 2]; buf2 = this.stack[this.stack.length - 1]; this.stack.push(buf1); this.stack.push(buf2); } break; case Opcode.OP_3DUP: { // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3) if (this.stack.length < 3) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } buf1 = this.stack[this.stack.length - 3]; buf2 = this.stack[this.stack.length - 2]; var buf3 = this.stack[this.stack.length - 1]; this.stack.push(buf1); this.stack.push(buf2); this.stack.push(buf3); } break; case Opcode.OP_2OVER: { // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2) if (this.stack.length < 4) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } buf1 = this.stack[this.stack.length - 4]; buf2 = this.stack[this.stack.length - 3]; this.stack.push(buf1); this.stack.push(buf2); } break; case Opcode.OP_2ROT: { // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2) if (this.stack.length < 6) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } spliced = this.stack.splice(this.stack.length - 6, 2); this.stack.push(spliced[0]); this.stack.push(spliced[1]); } break; case Opcode.OP_2SWAP: { // (x1 x2 x3 x4 -- x3 x4 x1 x2) if (this.stack.length < 4) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } spliced = this.stack.splice(this.stack.length - 4, 2); this.stack.push(spliced[0]); this.stack.push(spliced[1]); } break; case Opcode.OP_IFDUP: { // (x - 0 | x x) if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } buf = this.stack[this.stack.length - 1]; fValue = Interpreter.castToBool(buf); if (fValue) { this.stack.push(buf); } } break; case Opcode.OP_DEPTH: { // -- stacksize buf = new BN(this.stack.length).toScriptNumBuffer(); this.stack.push(buf); } break; case Opcode.OP_DROP: { // (x -- ) if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } this.stack.pop(); } break; case Opcode.OP_DUP: { // (x -- x x) if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } this.stack.push(this.stack[this.stack.length - 1]); } break; case Opcode.OP_NIP: { // (x1 x2 -- x2) if (this.stack.length < 2) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } this.stack.splice(this.stack.length - 2, 1); } break; case Opcode.OP_OVER: { // (x1 x2 -- x1 x2 x1) if (this.stack.length < 2) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } this.stack.push(this.stack[this.stack.length - 2]); } break; case Opcode.OP_PICK: case Opcode.OP_ROLL: { // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn) // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn) if (this.stack.length < 2) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } buf = this.stack[this.stack.length - 1]; bn = BN.fromScriptNumBuffer(buf, fRequireMinimal); n = bn.toNumber(); this.stack.pop(); if (n < 0 || n >= this.stack.length) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } buf = this.stack[this.stack.length - n - 1]; if (opcodenum === Opcode.OP_ROLL) { this.stack.splice(this.stack.length - n - 1, 1); } this.stack.push(buf); } break; case Opcode.OP_ROT: { // (x1 x2 x3 -- x2 x3 x1) // x2 x1 x3 after first swap // x2 x3 x1 after second swap if (this.stack.length < 3) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } x1 = this.stack[this.stack.length - 3]; x2 = this.stack[this.stack.length - 2]; var x3 = this.stack[this.stack.length - 1]; this.stack[this.stack.length - 3] = x2; this.stack[this.stack.length - 2] = x3; this.stack[this.stack.length - 1] = x1; } break; case Opcode.OP_SWAP: { // (x1 x2 -- x2 x1) if (this.stack.length < 2) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } x1 = this.stack[this.stack.length - 2]; x2 = this.stack[this.stack.length - 1]; this.stack[this.stack.length - 2] = x2; this.stack[this.stack.length - 1] = x1; } break; case Opcode.OP_TUCK: { // (x1 x2 -- x2 x1 x2) if (this.stack.length < 2) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]); } break; case Opcode.OP_SIZE: { // (in -- in size) if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } bn = new BN(this.stack[this.stack.length - 1].length); this.stack.push(bn.toScriptNumBuffer()); } break; // // Bitwise logic // case Opcode.OP_EQUAL: case Opcode.OP_EQUALVERIFY: //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL { // (x1 x2 - bool) if (this.stack.length < 2) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } buf1 = this.stack[this.stack.length - 2]; buf2 = this.stack[this.stack.length - 1]; var fEqual = buf1.toString('hex') === buf2.toString('hex'); this.stack.pop(); this.stack.pop(); this.stack.push(fEqual ? Interpreter.true : Interpreter.false); if (opcodenum === Opcode.OP_EQUALVERIFY) { if (fEqual) { this.stack.pop(); } else { this.errstr = 'SCRIPT_ERR_EQUALVERIFY'; return false; } } } break; // // Numeric // case Opcode.OP_1ADD: case Opcode.OP_1SUB: case Opcode.OP_NEGATE: case Opcode.OP_ABS: case Opcode.OP_NOT: case Opcode.OP_0NOTEQUAL: { // (in -- out) if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } buf = this.stack[this.stack.length - 1]; bn = BN.fromScriptNumBuffer(buf, fRequireMinimal); switch (opcodenum) { case Opcode.OP_1ADD: bn = bn.add(BN.One); break; case Opcode.OP_1SUB: bn = bn.sub(BN.One); break; case Opcode.OP_NEGATE: bn = bn.neg(); break; case Opcode.OP_ABS: if (bn.cmp(BN.Zero) < 0) { bn = bn.neg(); } break; case Opcode.OP_NOT: bn = new BN((bn.cmp(BN.Zero) === 0) + 0); break; case Opcode.OP_0NOTEQUAL: bn = new BN((bn.cmp(BN.Zero) !== 0) + 0); break; //default: assert(!'invalid opcode'); break; // TODO: does this ever occur? } this.stack.pop(); this.stack.push(bn.toScriptNumBuffer()); } break; case Opcode.OP_ADD: case Opcode.OP_SUB: case Opcode.OP_BOOLAND: case Opcode.OP_BOOLOR: case Opcode.OP_NUMEQUAL: case Opcode.OP_NUMEQUALVERIFY: case Opcode.OP_NUMNOTEQUAL: case Opcode.OP_LESSTHAN: case Opcode.OP_GREATERTHAN: case Opcode.OP_LESSTHANOREQUAL: case Opcode.OP_GREATERTHANOREQUAL: case Opcode.OP_MIN: case Opcode.OP_MAX: { // (x1 x2 -- out) if (this.stack.length < 2) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal); bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal); bn = new BN(0); switch (opcodenum) { case Opcode.OP_ADD: bn = bn1.add(bn2); break; case Opcode.OP_SUB: bn = bn1.sub(bn2); break; // case Opcode.OP_BOOLAND: bn = (bn1 != bnZero && bn2 != bnZero); break; case Opcode.OP_BOOLAND: bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0); break; // case Opcode.OP_BOOLOR: bn = (bn1 != bnZero || bn2 != bnZero); break; case Opcode.OP_BOOLOR: bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0); break; // case Opcode.OP_NUMEQUAL: bn = (bn1 == bn2); break; case Opcode.OP_NUMEQUAL: bn = new BN((bn1.cmp(bn2) === 0) + 0); break; // case Opcode.OP_NUMEQUALVERIFY: bn = (bn1 == bn2); break; case Opcode.OP_NUMEQUALVERIFY: bn = new BN((bn1.cmp(bn2) === 0) + 0); break; // case Opcode.OP_NUMNOTEQUAL: bn = (bn1 != bn2); break; case Opcode.OP_NUMNOTEQUAL: bn = new BN((bn1.cmp(bn2) !== 0) + 0); break; // case Opcode.OP_LESSTHAN: bn = (bn1 < bn2); break; case Opcode.OP_LESSTHAN: bn = new BN((bn1.cmp(bn2) < 0) + 0); break; // case Opcode.OP_GREATERTHAN: bn = (bn1 > bn2); break; case Opcode.OP_GREATERTHAN: bn = new BN((bn1.cmp(bn2) > 0) + 0); break; // case Opcode.OP_LESSTHANOREQUAL: bn = (bn1 <= bn2); break; case Opcode.OP_LESSTHANOREQUAL: bn = new BN((bn1.cmp(bn2) <= 0) + 0); break; // case Opcode.OP_GREATERTHANOREQUAL: bn = (bn1 >= bn2); break; case Opcode.OP_GREATERTHANOREQUAL: bn = new BN((bn1.cmp(bn2) >= 0) + 0); break; case Opcode.OP_MIN: bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2); break; case Opcode.OP_MAX: bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2); break; // default: assert(!'invalid opcode'); break; //TODO: does this ever occur? } this.stack.pop(); this.stack.pop(); this.stack.push(bn.toScriptNumBuffer()); if (opcodenum === Opcode.OP_NUMEQUALVERIFY) { // if (CastToBool(stacktop(-1))) if (Interpreter.castToBool(this.stack[this.stack.length - 1])) { this.stack.pop(); } else { this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY'; return false; } } } break; case Opcode.OP_WITHIN: { // (x min max -- out) if (this.stack.length < 3) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal); bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal); var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal); //bool fValue = (bn2 <= bn1 && bn1 < bn3); fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0); this.stack.pop(); this.stack.pop(); this.stack.pop(); this.stack.push(fValue ? Interpreter.true : Interpreter.false); } break; // // Crypto // case Opcode.OP_RIPEMD160: case Opcode.OP_SHA1: case Opcode.OP_SHA256: case Opcode.OP_HASH160: case Opcode.OP_HASH256: { // (in -- hash) if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } buf = this.stack[this.stack.length - 1]; //valtype vchHash((opcode == Opcode.OP_RIPEMD160 || // opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32); var bufHash; if (opcodenum === Opcode.OP_RIPEMD160) { bufHash = Hash.ripemd160(buf); } else if (opcodenum === Opcode.OP_SHA1) { bufHash = Hash.sha1(buf); } else if (opcodenum === Opcode.OP_SHA256) { bufHash = Hash.sha256(buf); } else if (opcodenum === Opcode.OP_HASH160) { bufHash = Hash.sha256ripemd160(buf); } else if (opcodenum === Opcode.OP_HASH256) { bufHash = Hash.sha256sha256(buf); } this.stack.pop(); this.stack.push(bufHash); } break; case Opcode.OP_CODESEPARATOR: { // Hash starts after the code separator this.pbegincodehash = this.pc; } break; case Opcode.OP_CHECKSIG: case Opcode.OP_CHECKSIGVERIFY: { // (sig pubkey -- bool) if (this.stack.length < 2) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } bufSig = this.stack[this.stack.length - 2]; bufPubkey = this.stack[this.stack.length - 1]; // Subset of script starting at the most recent codeseparator // CScript scriptCode(pbegincodehash, pend); subscript = new Script().set({ chunks: this.script.chunks.slice(this.pbegincodehash) }); // Drop the signature, since there's no way for a signature to sign itself var tmpScript = new Script().add(bufSig); subscript.findAndDelete(tmpScript); if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) { return false; } try { sig = Signature.fromTxFormat(bufSig); pubkey = PublicKey.fromBuffer(bufPubkey, false); fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion); } catch (e) { //invalid sig or pubkey fSuccess = false; } this.stack.pop(); this.stack.pop(); // stack.push_back(fSuccess ? vchTrue : vchFalse); this.stack.push(fSuccess ? Interpreter.true : Interpreter.false); if (opcodenum === Opcode.OP_CHECKSIGVERIFY) { if (fSuccess) { this.stack.pop(); } else { this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY'; return false; } } } break; case Opcode.OP_CHECKMULTISIG: case Opcode.OP_CHECKMULTISIGVERIFY: { // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool) var i = 1; if (this.stack.length < i) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber(); if (nKeysCount < 0 || nKeysCount > 20) { this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT'; return false; } this.nOpCount += nKeysCount; if (this.nOpCount > 201) { this.errstr = 'SCRIPT_ERR_OP_COUNT'; return false; } // int ikey = ++i; var ikey = ++i; i += nKeysCount; if (this.stack.length < i) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber(); if (nSigsCount < 0 || nSigsCount > nKeysCount) { this.errstr = 'SCRIPT_ERR_SIG_COUNT'; return false; } // int isig = ++i; var isig = ++i; i += nSigsCount; if (this.stack.length < i) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } // Subset of script starting at the most recent codeseparator subscript = new Script().set({ chunks: this.script.chunks.slice(this.pbegincodehash) }); // Drop the signatures, since there's no way for a signature to sign itself for (var k = 0; k < nSigsCount; k++) { bufSig = this.stack[this.stack.length - isig - k]; subscript.findAndDelete(new Script().add(bufSig)); } fSuccess = true; while (fSuccess && nSigsCount > 0) { // valtype& vchSig = stacktop(-isig); bufSig = this.stack[this.stack.length - isig]; // valtype& vchPubKey = stacktop(-ikey); bufPubkey = this.stack[this.stack.length - ikey]; if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) { return false; } var fOk; try { sig = Signature.fromTxFormat(bufSig); pubkey = PublicKey.fromBuffer(bufPubkey, false); fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion); } catch (e) { //invalid sig or pubkey fOk = false; } if (fOk) { isig++; nSigsCount--; } ikey++; nKeysCount--; // If there are more signatures left than keys left, // then too many signatures have failed if (nSigsCount > nKeysCount) { fSuccess = false; } } // Clean up stack of actual arguments while (i-- > 1) { this.stack.pop(); } // A bug causes CHECKMULTISIG to consume one extra argument // whose contents were not checked in any way. // // Unfortunately this is a potential source of mutability, // so optionally verify it is exactly equal to zero prior // to removing it from the stack. if (this.stack.length < 1) { this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION'; return false; } if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) { this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY'; return false; } this.stack.pop(); this.stack.push(fSuccess ? Interpreter.true : Interpreter.false); if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) { if (fSuccess) { this.stack.pop(); } else { this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY'; return false; } } } break; default: this.errstr = 'SCRIPT_ERR_BAD_OPCODE'; return false; } } return true; }; }).call(this,require("buffer").Buffer) },{"../crypto/bn":104,"../crypto/hash":106,"../crypto/signature":109,"../opcode":120,"../publickey":122,"../transaction":126,"./script":125,"buffer":75,"lodash":146}],125:[function(require,module,exports){ (function (Buffer){ 'use strict'; var Address = require('../address'); var BufferReader = require('../encoding/bufferreader'); var BufferWriter = require('../encoding/bufferwriter'); var Hash = require('../crypto/hash'); var Opcode = require('../opcode'); var PublicKey = require('../publickey'); var Signature = require('../crypto/signature'); var Networks = require('../networks'); var $ = require('../util/preconditions'); var _ = require('lodash'); var errors = require('../errors'); var buffer = require('buffer'); var BufferUtil = require('../util/buffer'); var JSUtil = require('../util/js'); /** * A bitcoin transaction script. Each transaction's inputs and outputs * has a script that is evaluated to validate it's spending. * * See https://en.bitcoin.it/wiki/Script * * @constructor * @param {Object|string|Buffer=} from optional data to populate script */ var Script = function Script(from) { if (!(this instanceof Script)) { return new Script(from); } this.chunks = []; if (BufferUtil.isBuffer(from)) { return Script.fromBuffer(from); } else if (from instanceof Address) { return Script.fromAddress(from); } else if (from instanceof Script) { return Script.fromBuffer(from.toBuffer()); } else if (typeof from === 'string') { return Script.fromString(from); } else if (typeof from !== 'undefined') { this.set(from); } }; Script.prototype.set = function(obj) { this.chunks = obj.chunks || this.chunks; return this; }; Script.fromBuffer = function(buffer) { var script = new Script(); script.chunks = []; var br = new BufferReader(buffer); while (!br.finished()) { try { var opcodenum = br.readUInt8(); var len, buf; if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) { len = opcodenum; script.chunks.push({ buf: br.read(len), len: len, opcodenum: opcodenum }); } else if (opcodenum === Opcode.OP_PUSHDATA1) { len = br.readUInt8(); buf = br.read(len); script.chunks.push({ buf: buf, len: len, opcodenum: opcodenum }); } else if (opcodenum === Opcode.OP_PUSHDATA2) { len = br.readUInt16LE(); buf = br.read(len); script.chunks.push({ buf: buf, len: len, opcodenum: opcodenum }); } else if (opcodenum === Opcode.OP_PUSHDATA4) { len = br.readUInt32LE(); buf = br.read(len); script.chunks.push({ buf: buf, len: len, opcodenum: opcodenum }); } else { script.chunks.push({ opcodenum: opcodenum }); } } catch (e) { if (e instanceof RangeError) { throw new errors.Script.InvalidBuffer(buffer.toString('hex')); } throw e; } } return script; }; Script.prototype.toBuffer = function() { var bw = new BufferWriter(); for (var i = 0; i < this.chunks.length; i++) { var chunk = this.chunks[i]; var opcodenum = chunk.opcodenum; bw.writeUInt8(chunk.opcodenum); if (chunk.buf) { if (opcodenum < Opcode.OP_PUSHDATA1) { bw.write(chunk.buf); } else if (opcodenum === Opcode.OP_PUSHDATA1) { bw.writeUInt8(chunk.len); bw.write(chunk.buf); } else if (opcodenum === Opcode.OP_PUSHDATA2) { bw.writeUInt16LE(chunk.len); bw.write(chunk.buf); } else if (opcodenum === Opcode.OP_PUSHDATA4) { bw.writeUInt32LE(chunk.len); bw.write(chunk.buf); } } } return bw.concat(); }; Script.fromASM = function(str) { var script = new Script(); script.chunks = []; var tokens = str.split(' '); var i = 0; while (i < tokens.length) { var token = tokens[i]; var opcode = Opcode(token); var opcodenum = opcode.toNumber(); if (_.isUndefined(opcodenum)) { var buf = new Buffer(tokens[i], 'hex'); script.chunks.push({ buf: buf, len: buf.length, opcodenum: buf.length }); i = i + 1; } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) { script.chunks.push({ buf: new Buffer(tokens[i + 2], 'hex'), len: parseInt(tokens[i + 1]), opcodenum: opcodenum }); i = i + 3; } else { script.chunks.push({ opcodenum: opcodenum }); i = i + 1; } } return script; }; Script.fromHex = function(str) { return new Script(new buffer.Buffer(str, 'hex')); }; Script.fromString = function(str) { if (JSUtil.isHexa(str) || str.length === 0) { return new Script(new buffer.Buffer(str, 'hex')); } var script = new Script(); script.chunks = []; var tokens = str.split(' '); var i = 0; while (i < tokens.length) { var token = tokens[i]; var opcode = Opcode(token); var opcodenum = opcode.toNumber(); if (_.isUndefined(opcodenum)) { opcodenum = parseInt(token); if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) { script.chunks.push({ buf: new Buffer(tokens[i + 1].slice(2), 'hex'), len: opcodenum, opcodenum: opcodenum }); i = i + 2; } else { throw new Error('Invalid script: ' + JSON.stringify(str)); } } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) { if (tokens[i + 2].slice(0, 2) !== '0x') { throw new Error('Pushdata data must start with 0x'); } script.chunks.push({ buf: new Buffer(tokens[i + 2].slice(2), 'hex'), len: parseInt(tokens[i + 1]), opcodenum: opcodenum }); i = i + 3; } else { script.chunks.push({ opcodenum: opcodenum }); i = i + 1; } } return script; }; Script.prototype._chunkToString = function(chunk, type) { var opcodenum = chunk.opcodenum; var asm = (type === 'asm'); var str = ''; if (!chunk.buf) { // no data chunk if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') { str = str + ' ' + Opcode(opcodenum).toString(); } else { var numstr = opcodenum.toString(16); if (numstr.length % 2 !== 0) { numstr = '0' + numstr; } if (asm) { str = str + ' ' + numstr; } else { str = str + ' ' + '0x' + numstr; } } } else { // data chunk if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) { str = str + ' ' + Opcode(opcodenum).toString(); } if (chunk.len > 0) { if (asm) { str = str + ' ' + chunk.buf.toString('hex'); } else { str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex'); } } } return str; }; Script.prototype.toASM = function() { var str = ''; for (var i = 0; i < this.chunks.length; i++) { var chunk = this.chunks[i]; str += this._chunkToString(chunk, 'asm'); } return str.substr(1); }; Script.prototype.toString = function() { var str = ''; for (var i = 0; i < this.chunks.length; i++) { var chunk = this.chunks[i]; str += this._chunkToString(chunk); } return str.substr(1); }; Script.prototype.toHex = function() { return this.toBuffer().toString('hex'); }; Script.prototype.inspect = function() { return '<Script: ' + this.toString() + '>'; }; // script classification methods /** * @returns {boolean} if this is a pay to pubkey hash output script */ Script.prototype.isPublicKeyHashOut = function() { return !!(this.chunks.length === 5 && this.chunks[0].opcodenum === Opcode.OP_DUP && this.chunks[1].opcodenum === Opcode.OP_HASH160 && this.chunks[2].buf && this.chunks[2].buf.length === 20 && this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY && this.chunks[4].opcodenum === Opcode.OP_CHECKSIG); }; /** * @returns {boolean} if this is a pay to public key hash input script */ Script.prototype.isPublicKeyHashIn = function() { if (this.chunks.length === 2) { var signatureBuf = this.chunks[0].buf; var pubkeyBuf = this.chunks[1].buf; if (signatureBuf && signatureBuf.length && signatureBuf[0] === 0x30 && pubkeyBuf && pubkeyBuf.length ) { var version = pubkeyBuf[0]; if ((version === 0x04 || version === 0x06 || version === 0x07) && pubkeyBuf.length === 65) { return true; } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) { return true; } } } return false; }; Script.prototype.getPublicKey = function() { $.checkState(this.isPublicKeyOut(), 'Can\'t retrieve PublicKey from a non-PK output'); return this.chunks[0].buf; }; Script.prototype.getPublicKeyHash = function() { $.checkState(this.isPublicKeyHashOut(), 'Can\'t retrieve PublicKeyHash from a non-PKH output'); return this.chunks[2].buf; }; /** * @returns {boolean} if this is a public key output script */ Script.prototype.isPublicKeyOut = function() { if (this.chunks.length === 2 && this.chunks[0].buf && this.chunks[0].buf.length && this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) { var pubkeyBuf = this.chunks[0].buf; var version = pubkeyBuf[0]; var isVersion = false; if ((version === 0x04 || version === 0x06 || version === 0x07) && pubkeyBuf.length === 65) { isVersion = true; } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) { isVersion = true; } if (isVersion) { return PublicKey.isValid(pubkeyBuf); } } return false; }; /** * @returns {boolean} if this is a pay to public key input script */ Script.prototype.isPublicKeyIn = function() { if (this.chunks.length === 1) { var signatureBuf = this.chunks[0].buf; if (signatureBuf && signatureBuf.length && signatureBuf[0] === 0x30) { return true; } } return false; }; /** * @returns {boolean} if this is a p2sh output script */ Script.prototype.isScriptHashOut = function() { var buf = this.toBuffer(); return (buf.length === 23 && buf[0] === Opcode.OP_HASH160 && buf[1] === 0x14 && buf[buf.length - 1] === Opcode.OP_EQUAL); }; /** * @returns {boolean} if this is a p2wsh output script */ Script.prototype.isWitnessScriptHashOut = function() { var buf = this.toBuffer(); return (buf.length === 34 && buf[0] === 0 && buf[1] === 32); }; /** * @returns {boolean} if this is a p2wpkh output script */ Script.prototype.isWitnessPublicKeyHashOut = function() { var buf = this.toBuffer(); return (buf.length === 22 && buf[0] === 0 && buf[1] === 20); }; /** * @param {Object=} values - The return values * @param {Number} values.version - Set with the witness version * @param {Buffer} values.program - Set with the witness program * @returns {boolean} if this is a p2wpkh output script */ Script.prototype.isWitnessProgram = function(values) { if (!values) { values = {}; } var buf = this.toBuffer(); if (buf.length < 4 || buf.length > 34) { return false; } if (buf[0] >= Opcode.OP_0 && (buf[0] < 1 && buf[0] > 16)) { return false; } if (buf.length === buf[1] + 2) { values.version = buf[0]; values.program = buf.slice(2, buf.length); return true; } return false; }; /** * @returns {boolean} if this is a p2sh input script * Note that these are frequently indistinguishable from pubkeyhashin */ Script.prototype.isScriptHashIn = function() { if (this.chunks.length <= 1) { return false; } var redeemChunk = this.chunks[this.chunks.length - 1]; var redeemBuf = redeemChunk.buf; if (!redeemBuf) { return false; } var redeemScript; try { redeemScript = Script.fromBuffer(redeemBuf); } catch (e) { if (e instanceof errors.Script.InvalidBuffer) { return false; } throw e; } var type = redeemScript.classify(); return type !== Script.types.UNKNOWN; }; /** * @returns {boolean} if this is a mutlsig output script */ Script.prototype.isMultisigOut = function() { return (this.chunks.length > 3 && Opcode.isSmallIntOp(this.chunks[0].opcodenum) && this.chunks.slice(1, this.chunks.length - 2).every(function(obj) { return obj.buf && BufferUtil.isBuffer(obj.buf); }) && Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) && this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG); }; /** * @returns {boolean} if this is a multisig input script */ Script.prototype.isMultisigIn = function() { return this.chunks.length >= 2 && this.chunks[0].opcodenum === 0 && this.chunks.slice(1, this.chunks.length).every(function(obj) { return obj.buf && BufferUtil.isBuffer(obj.buf) && Signature.isTxDER(obj.buf); }); }; /** * @returns {boolean} true if this is a valid standard OP_RETURN output */ Script.prototype.isDataOut = function() { return this.chunks.length >= 1 && this.chunks[0].opcodenum === Opcode.OP_RETURN && (this.chunks.length === 1 || (this.chunks.length === 2 && this.chunks[1].buf && this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE && this.chunks[1].length === this.chunks.len)); }; /** * Retrieve the associated data for this script. * In the case of a pay to public key hash or P2SH, return the hash. * In the case of a standard OP_RETURN, return the data * @returns {Buffer} */ Script.prototype.getData = function() { if (this.isDataOut() || this.isScriptHashOut()) { if (_.isUndefined(this.chunks[1])) { return new Buffer(0); } else { return new Buffer(this.chunks[1].buf); } } if (this.isPublicKeyHashOut()) { return new Buffer(this.chunks[2].buf); } throw new Error('Unrecognized script type to get data from'); }; /** * @returns {boolean} if the script is only composed of data pushing * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16) */ Script.prototype.isPushOnly = function() { return _.every(this.chunks, function(chunk) { return chunk.opcodenum <= Opcode.OP_16; }); }; Script.types = {}; Script.types.UNKNOWN = 'Unknown'; Script.types.PUBKEY_OUT = 'Pay to public key'; Script.types.PUBKEY_IN = 'Spend from public key'; Script.types.PUBKEYHASH_OUT = 'Pay to public key hash'; Script.types.PUBKEYHASH_IN = 'Spend from public key hash'; Script.types.SCRIPTHASH_OUT = 'Pay to script hash'; Script.types.SCRIPTHASH_IN = 'Spend from script hash'; Script.types.MULTISIG_OUT = 'Pay to multisig'; Script.types.MULTISIG_IN = 'Spend from multisig'; Script.types.DATA_OUT = 'Data push'; Script.OP_RETURN_STANDARD_SIZE = 80; /** * @returns {object} The Script type if it is a known form, * or Script.UNKNOWN if it isn't */ Script.prototype.classify = function() { if (this._isInput) { return this.classifyInput(); } else if (this._isOutput) { return this.classifyOutput(); } else { var outputType = this.classifyOutput(); return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput(); } }; Script.outputIdentifiers = {}; Script.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut; Script.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut; Script.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut; Script.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut; Script.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut; /** * @returns {object} The Script type if it is a known form, * or Script.UNKNOWN if it isn't */ Script.prototype.classifyOutput = function() { for (var type in Script.outputIdentifiers) { if (Script.outputIdentifiers[type].bind(this)()) { return Script.types[type]; } } return Script.types.UNKNOWN; }; Script.inputIdentifiers = {}; Script.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn; Script.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn; Script.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn; Script.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn; /** * @returns {object} The Script type if it is a known form, * or Script.UNKNOWN if it isn't */ Script.prototype.classifyInput = function() { for (var type in Script.inputIdentifiers) { if (Script.inputIdentifiers[type].bind(this)()) { return Script.types[type]; } } return Script.types.UNKNOWN; }; /** * @returns {boolean} if script is one of the known types */ Script.prototype.isStandard = function() { // TODO: Add BIP62 compliance return this.classify() !== Script.types.UNKNOWN; }; // Script construction methods /** * Adds a script element at the start of the script. * @param {*} obj a string, number, Opcode, Buffer, or object to add * @returns {Script} this script instance */ Script.prototype.prepend = function(obj) { this._addByType(obj, true); return this; }; /** * Compares a script with another script */ Script.prototype.equals = function(script) { $.checkState(script instanceof Script, 'Must provide another script'); if (this.chunks.length !== script.chunks.length) { return false; } var i; for (i = 0; i < this.chunks.length; i++) { if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) { return false; } if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) { return false; } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) { return false; } } return true; }; /** * Adds a script element to the end of the script. * * @param {*} obj a string, number, Opcode, Buffer, or object to add * @returns {Script} this script instance * */ Script.prototype.add = function(obj) { this._addByType(obj, false); return this; }; Script.prototype._addByType = function(obj, prepend) { if (typeof obj === 'string') { this._addOpcode(obj, prepend); } else if (typeof obj === 'number') { this._addOpcode(obj, prepend); } else if (obj instanceof Opcode) { this._addOpcode(obj, prepend); } else if (BufferUtil.isBuffer(obj)) { this._addBuffer(obj, prepend); } else if (obj instanceof Script) { this.chunks = this.chunks.concat(obj.chunks); } else if (typeof obj === 'object') { this._insertAtPosition(obj, prepend); } else { throw new Error('Invalid script chunk'); } }; Script.prototype._insertAtPosition = function(op, prepend) { if (prepend) { this.chunks.unshift(op); } else { this.chunks.push(op); } }; Script.prototype._addOpcode = function(opcode, prepend) { var op; if (typeof opcode === 'number') { op = opcode; } else if (opcode instanceof Opcode) { op = opcode.toNumber(); } else { op = Opcode(opcode).toNumber(); } this._insertAtPosition({ opcodenum: op }, prepend); return this; }; Script.prototype._addBuffer = function(buf, prepend) { var opcodenum; var len = buf.length; if (len >= 0 && len < Opcode.OP_PUSHDATA1) { opcodenum = len; } else if (len < Math.pow(2, 8)) { opcodenum = Opcode.OP_PUSHDATA1; } else if (len < Math.pow(2, 16)) { opcodenum = Opcode.OP_PUSHDATA2; } else if (len < Math.pow(2, 32)) { opcodenum = Opcode.OP_PUSHDATA4; } else { throw new Error('You can\'t push that much data'); } this._insertAtPosition({ buf: buf, len: len, opcodenum: opcodenum }, prepend); return this; }; Script.prototype.hasCodeseparators = function() { for (var i = 0; i < this.chunks.length; i++) { if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) { return true; } } return false; }; Script.prototype.removeCodeseparators = function() { var chunks = []; for (var i = 0; i < this.chunks.length; i++) { if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) { chunks.push(this.chunks[i]); } } this.chunks = chunks; return this; }; // high level script builder methods /** * @returns {Script} a new Multisig output script for given public keys, * requiring m of those public keys to spend * @param {PublicKey[]} publicKeys - list of all public keys controlling the output * @param {number} threshold - amount of required signatures to spend the output * @param {Object=} opts - Several options: * - noSorting: defaults to false, if true, don't sort the given * public keys before creating the script */ Script.buildMultisigOut = function(publicKeys, threshold, opts) { $.checkArgument(threshold <= publicKeys.length, 'Number of required signatures must be less than or equal to the number of public keys'); opts = opts || {}; var script = new Script(); script.add(Opcode.smallInt(threshold)); publicKeys = _.map(publicKeys, PublicKey); var sorted = publicKeys; if (!opts.noSorting) { sorted = _.sortBy(publicKeys, function(publicKey) { return publicKey.toString('hex'); }); } for (var i = 0; i < sorted.length; i++) { var publicKey = sorted[i]; script.add(publicKey.toBuffer()); } script.add(Opcode.smallInt(publicKeys.length)); script.add(Opcode.OP_CHECKMULTISIG); return script; }; Script.buildWitnessMultisigOutFromScript = function(script) { if (script instanceof Script) { var s = new Script(); s.add(Opcode.OP_0); s.add(Hash.sha256(script.toBuffer())); return s; } else { throw new TypeError('First argument is expected to be a p2sh script'); } }; /** * A new Multisig input script for the given public keys, requiring m of those public keys to spend * * @param {PublicKey[]} pubkeys list of all public keys controlling the output * @param {number} threshold amount of required signatures to spend the output * @param {Array} signatures and array of signature buffers to append to the script * @param {Object=} opts * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default) * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript * * @returns {Script} */ Script.buildMultisigIn = function(pubkeys, threshold, signatures, opts) { $.checkArgument(_.isArray(pubkeys)); $.checkArgument(_.isNumber(threshold)); $.checkArgument(_.isArray(signatures)); opts = opts || {}; var s = new Script(); s.add(Opcode.OP_0); _.each(signatures, function(signature) { $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers'); // TODO: allow signatures to be an array of Signature objects s.add(signature); }); return s; }; /** * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend * * @param {PublicKey[]} pubkeys list of all public keys controlling the output * @param {number} threshold amount of required signatures to spend the output * @param {Array} signatures and array of signature buffers to append to the script * @param {Object=} opts * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default) * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript * * @returns {Script} */ Script.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) { $.checkArgument(_.isArray(pubkeys)); $.checkArgument(_.isNumber(threshold)); $.checkArgument(_.isArray(signatures)); opts = opts || {}; var s = new Script(); s.add(Opcode.OP_0); _.each(signatures, function(signature) { $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers'); // TODO: allow signatures to be an array of Signature objects s.add(signature); }); s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer()); return s; }; /** * @returns {Script} a new pay to public key hash output for the given * address or public key * @param {(Address|PublicKey)} to - destination address or public key */ Script.buildPublicKeyHashOut = function(to) { $.checkArgument(!_.isUndefined(to)); $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to)); if (to instanceof PublicKey) { to = to.toAddress(); } else if (_.isString(to)) { to = new Address(to); } var s = new Script(); s.add(Opcode.OP_DUP) .add(Opcode.OP_HASH160) .add(to.hashBuffer) .add(Opcode.OP_EQUALVERIFY) .add(Opcode.OP_CHECKSIG); s._network = to.network; return s; }; /** * @returns {Script} a new pay to public key output for the given * public key */ Script.buildPublicKeyOut = function(pubkey) { $.checkArgument(pubkey instanceof PublicKey); var s = new Script(); s.add(pubkey.toBuffer()) .add(Opcode.OP_CHECKSIG); return s; }; /** * @returns {Script} a new OP_RETURN script with data * @param {(string|Buffer)} data - the data to embed in the output * @param {(string)} encoding - the type of encoding of the string */ Script.buildDataOut = function(data, encoding) { $.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data)); if (_.isString(data)) { data = new Buffer(data, encoding); } var s = new Script(); s.add(Opcode.OP_RETURN); if (!_.isUndefined(data)) { s.add(data); } return s; }; /** * @param {Script|Address} script - the redeemScript for the new p2sh output. * It can also be a p2sh address * @returns {Script} new pay to script hash script for given script */ Script.buildScriptHashOut = function(script) { $.checkArgument(script instanceof Script || (script instanceof Address && script.isPayToScriptHash())); var s = new Script(); s.add(Opcode.OP_HASH160) .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer())) .add(Opcode.OP_EQUAL); s._network = script._network || script.network; return s; }; /** * Builds a scriptSig (a script for an input) that signs a public key output script. * * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL) */ Script.buildPublicKeyIn = function(signature, sigtype) { $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature)); $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype)); if (signature instanceof Signature) { signature = signature.toBuffer(); } var script = new Script(); script.add(BufferUtil.concat([ signature, BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL) ])); return script; }; /** * Builds a scriptSig (a script for an input) that signs a public key hash * output script. * * @param {Buffer|string|PublicKey} publicKey * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL) */ Script.buildPublicKeyHashIn = function(publicKey, signature, sigtype) { $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature)); $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype)); if (signature instanceof Signature) { signature = signature.toBuffer(); } var script = new Script() .add(BufferUtil.concat([ signature, BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL) ])) .add(new PublicKey(publicKey).toBuffer()); return script; }; /** * @returns {Script} an empty script */ Script.empty = function() { return new Script(); }; /** * @returns {Script} a new pay to script hash script that pays to this script */ Script.prototype.toScriptHashOut = function() { return Script.buildScriptHashOut(this); }; /** * @return {Script} an output script built from the address */ Script.fromAddress = function(address) { address = Address(address); if (address.isPayToScriptHash()) { return Script.buildScriptHashOut(address); } else if (address.isPayToPublicKeyHash()) { return Script.buildPublicKeyHashOut(address); } throw new errors.Script.UnrecognizedAddress(address); }; /** * Will return the associated address information object * @return {Address|boolean} */ Script.prototype.getAddressInfo = function(opts) { if (this._isInput) { return this._getInputAddressInfo(); } else if (this._isOutput) { return this._getOutputAddressInfo(); } else { var info = this._getOutputAddressInfo(); if (!info) { return this._getInputAddressInfo(); } return info; } }; /** * Will return the associated output scriptPubKey address information object * @return {Address|boolean} * @private */ Script.prototype._getOutputAddressInfo = function() { var info = {}; if (this.isScriptHashOut()) { info.hashBuffer = this.getData(); info.type = Address.PayToScriptHash; } else if (this.isPublicKeyHashOut()) { info.hashBuffer = this.getData(); info.type = Address.PayToPublicKeyHash; } else { return false; } return info; }; /** * Will return the associated input scriptSig address information object * @return {Address|boolean} * @private */ Script.prototype._getInputAddressInfo = function() { var info = {}; if (this.isPublicKeyHashIn()) { // hash the publickey found in the scriptSig info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf); info.type = Address.PayToPublicKeyHash; } else if (this.isScriptHashIn()) { // hash the redeemscript found at the end of the scriptSig info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf); info.type = Address.PayToScriptHash; } else { return false; } return info; }; /** * @param {Network=} network * @return {Address|boolean} the associated address for this script if possible, or false */ Script.prototype.toAddress = function(network) { var info = this.getAddressInfo(); if (!info) { return false; } info.network = Networks.get(network) || this._network || Networks.defaultNetwork; return new Address(info); }; /** * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks, * typically used with push data chunks. Note that this will find and delete * not just the same data, but the same data with the same push data op as * produced by default. i.e., if a pushdata in a tx does not use the minimal * pushdata op, then when you try to remove the data it is pushing, it will not * be removed, because they do not use the same pushdata op. */ Script.prototype.findAndDelete = function(script) { var buf = script.toBuffer(); var hex = buf.toString('hex'); for (var i = 0; i < this.chunks.length; i++) { var script2 = Script({ chunks: [this.chunks[i]] }); var buf2 = script2.toBuffer(); var hex2 = buf2.toString('hex'); if (hex === hex2) { this.chunks.splice(i, 1); } } return this; }; /** * Comes from bitcoind's script interpreter CheckMinimalPush function * @returns {boolean} if the chunk {i} is the smallest way to push that particular data. */ Script.prototype.checkMinimalPush = function(i) { var chunk = this.chunks[i]; var buf = chunk.buf; var opcodenum = chunk.opcodenum; if (!buf) { return true; } if (buf.length === 0) { // Could have used OP_0. return opcodenum === Opcode.OP_0; } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) { // Could have used OP_1 .. OP_16. return opcodenum === Opcode.OP_1 + (buf[0] - 1); } else if (buf.length === 1 && buf[0] === 0x81) { // Could have used OP_1NEGATE return opcodenum === Opcode.OP_1NEGATE; } else if (buf.length <= 75) { // Could have used a direct push (opcode indicating number of bytes pushed + those bytes). return opcodenum === buf.length; } else if (buf.length <= 255) { // Could have used OP_PUSHDATA. return opcodenum === Opcode.OP_PUSHDATA1; } else if (buf.length <= 65535) { // Could have used OP_PUSHDATA2. return opcodenum === Opcode.OP_PUSHDATA2; } return true; }; /** * Comes from bitcoind's script DecodeOP_N function * @param {number} opcode * @returns {number} numeric value in range of 0 to 16 */ Script.prototype._decodeOP_N = function(opcode) { if (opcode === Opcode.OP_0) { return 0; } else if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) { return opcode - (Opcode.OP_1 - 1); } else { throw new Error('Invalid opcode: ' + JSON.stringify(opcode)); } }; /** * Comes from bitcoind's script GetSigOpCount(boolean) function * @param {boolean} use current (true) or pre-version-0.6 (false) logic * @returns {number} number of signature operations required by this script */ Script.prototype.getSignatureOperationsCount = function(accurate) { accurate = (_.isUndefined(accurate) ? true : accurate); var self = this; var n = 0; var lastOpcode = Opcode.OP_INVALIDOPCODE; _.each(self.chunks, function getChunk(chunk) { var opcode = chunk.opcodenum; if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) { n++; } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) { if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) { n += self._decodeOP_N(lastOpcode); } else { n += 20; } } lastOpcode = opcode; }); return n; }; module.exports = Script; }).call(this,require("buffer").Buffer) },{"../address":99,"../crypto/hash":106,"../crypto/signature":109,"../encoding/bufferreader":112,"../encoding/bufferwriter":113,"../errors":115,"../networks":119,"../opcode":120,"../publickey":122,"../util/buffer":141,"../util/js":142,"../util/preconditions":143,"buffer":75,"lodash":146}],126:[function(require,module,exports){ module.exports = require('./transaction'); module.exports.Input = require('./input'); module.exports.Output = require('./output'); module.exports.UnspentOutput = require('./unspentoutput'); module.exports.Signature = require('./signature'); module.exports.Sighash = require('./sighash'); module.exports.SighashWitness = require('./sighashwitness'); },{"./input":127,"./output":133,"./sighash":134,"./sighashwitness":135,"./signature":136,"./transaction":137,"./unspentoutput":138}],127:[function(require,module,exports){ module.exports = require('./input'); module.exports.PublicKey = require('./publickey'); module.exports.PublicKeyHash = require('./publickeyhash'); module.exports.MultiSig = require('./multisig.js'); module.exports.MultiSigScriptHash = require('./multisigscripthash.js'); },{"./input":128,"./multisig.js":129,"./multisigscripthash.js":130,"./publickey":131,"./publickeyhash":132}],128:[function(require,module,exports){ 'use strict'; var _ = require('lodash'); var $ = require('../../util/preconditions'); var errors = require('../../errors'); var BufferWriter = require('../../encoding/bufferwriter'); var buffer = require('buffer'); var BufferUtil = require('../../util/buffer'); var JSUtil = require('../../util/js'); var Script = require('../../script'); var Sighash = require('../sighash'); var Output = require('../output'); var MAXINT = 0xffffffff; // Math.pow(2, 32) - 1; var DEFAULT_RBF_SEQNUMBER = MAXINT - 2; var DEFAULT_SEQNUMBER = MAXINT; var DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1; function Input(params) { if (!(this instanceof Input)) { return new Input(params); } if (params) { return this._fromObject(params); } } Input.MAXINT = MAXINT; Input.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER; Input.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER; Input.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER; Object.defineProperty(Input.prototype, 'script', { configurable: false, enumerable: true, get: function() { if (this.isNull()) { return null; } if (!this._script) { this._script = new Script(this._scriptBuffer); this._script._isInput = true; } return this._script; } }); Input.fromObject = function(obj) { $.checkArgument(_.isObject(obj)); var input = new Input(); return input._fromObject(obj); }; Input.prototype._fromObject = function(params) { var prevTxId; if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) { prevTxId = new buffer.Buffer(params.prevTxId, 'hex'); } else { prevTxId = params.prevTxId; } this.witnesses = []; this.output = params.output ? (params.output instanceof Output ? params.output : new Output(params.output)) : undefined; this.prevTxId = prevTxId || params.txidbuf; this.outputIndex = _.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex; this.sequenceNumber = _.isUndefined(params.sequenceNumber) ? (_.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum) : params.sequenceNumber; if (_.isUndefined(params.script) && _.isUndefined(params.scriptBuffer)) { throw new errors.Transaction.Input.MissingScript(); } this.setScript(params.scriptBuffer || params.script); return this; }; Input.prototype.toObject = Input.prototype.toJSON = function toObject() { var obj = { prevTxId: this.prevTxId.toString('hex'), outputIndex: this.outputIndex, sequenceNumber: this.sequenceNumber, script: this._scriptBuffer.toString('hex'), }; // add human readable form if input contains valid script if (this.script) { obj.scriptString = this.script.toString(); } if (this.output) { obj.output = this.output.toObject(); } return obj; }; Input.fromBufferReader = function(br) { var input = new Input(); input.prevTxId = br.readReverse(32); input.outputIndex = br.readUInt32LE(); input._scriptBuffer = br.readVarLengthBuffer(); input.sequenceNumber = br.readUInt32LE(); // TODO: return different classes according to which input it is // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc. return input; }; Input.prototype.toBufferWriter = function(writer) { if (!writer) { writer = new BufferWriter(); } writer.writeReverse(this.prevTxId); writer.writeUInt32LE(this.outputIndex); var script = this._scriptBuffer; writer.writeVarintNum(script.length); writer.write(script); writer.writeUInt32LE(this.sequenceNumber); return writer; }; Input.prototype.setScript = function(script) { this._script = null; if (script instanceof Script) { this._script = script; this._script._isInput = true; this._scriptBuffer = script.toBuffer(); } else if (JSUtil.isHexa(script)) { // hex string script this._scriptBuffer = new buffer.Buffer(script, 'hex'); } else if (_.isString(script)) { // human readable string script this._script = new Script(script); this._script._isInput = true; this._scriptBuffer = this._script.toBuffer(); } else if (BufferUtil.isBuffer(script)) { // buffer script this._scriptBuffer = new buffer.Buffer(script); } else { throw new TypeError('Invalid argument type: script'); } return this; }; /** * Retrieve signatures for the provided PrivateKey. * * @param {Transaction} transaction - the transaction to be signed * @param {PrivateKey} privateKey - the private key to use when signing * @param {number} inputIndex - the index of this input in the provided transaction * @param {number} sigType - defaults to Signature.SIGHASH_ALL * @param {Buffer} addressHash - if provided, don't calculate the hash of the * public key associated with the private key provided * @abstract */ Input.prototype.getSignatures = function() { throw new errors.AbstractMethodInvoked( 'Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' + ' for input: ' + JSON.stringify(this) ); }; Input.prototype.getSatoshisBuffer = function () { $.checkState(this.output instanceof Output); $.checkState(this.output._satoshisBN); return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer(); }; Input.prototype.isFullySigned = function() { throw new errors.AbstractMethodInvoked('Input#isFullySigned'); }; Input.prototype.isFinal = function() { return this.sequenceNumber !== 4294967295; }; Input.prototype.addSignature = function() { throw new errors.AbstractMethodInvoked('Input#addSignature'); }; Input.prototype.clearSignatures = function() { throw new errors.AbstractMethodInvoked('Input#clearSignatures'); }; Input.prototype.hasWitnesses = function() { if (this.witnesses && this.witnesses.length > 0) { return true; } return false; }; Input.prototype.getWitnesses = function() { return this.witnesses; }; Input.prototype.setWitnesses = function(witnesses) { this.witnesses = witnesses; }; Input.prototype.isValidSignature = function(transaction, signature) { // FIXME: Refactor signature so this is not necessary signature.signature.nhashtype = signature.sigtype; return Sighash.verify( transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script ); }; /** * @returns true if this is a coinbase input (represents no input) */ Input.prototype.isNull = function() { return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' && this.outputIndex === 0xffffffff; }; Input.prototype._estimateSize = function() { return this.toBufferWriter().toBuffer().length; }; module.exports = Input; },{"../../encoding/bufferwriter":113,"../../errors":115,"../../script":123,"../../util/buffer":141,"../../util/js":142,"../../util/preconditions":143,"../output":133,"../sighash":134,"buffer":75,"lodash":146}],129:[function(require,module,exports){ 'use strict'; var _ = require('lodash'); var inherits = require('inherits'); var Transaction = require('../transaction'); var Input = require('./input'); var Output = require('../output'); var $ = require('../../util/preconditions'); var Script = require('../../script'); var Signature = require('../../crypto/signature'); var Sighash = require('../sighash'); var PublicKey = require('../../publickey'); var BufferUtil = require('../../util/buffer'); var TransactionSignature = require('../signature'); /** * @constructor */ function MultiSigInput(input, pubkeys, threshold, signatures) { Input.apply(this, arguments); var self = this; pubkeys = pubkeys || input.publicKeys; threshold = threshold || input.threshold; signatures = signatures || input.signatures; this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); }); $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script), 'Provided public keys don\'t match to the provided output script'); this.publicKeyIndex = {}; _.each(this.publicKeys, function(publicKey, index) { self.publicKeyIndex[publicKey.toString()] = index; }); this.threshold = threshold; // Empty array of signatures this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length); } inherits(MultiSigInput, Input); MultiSigInput.prototype.toObject = function() { var obj = Input.prototype.toObject.apply(this, arguments); obj.threshold = this.threshold; obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); }); obj.signatures = this._serializeSignatures(); return obj; }; MultiSigInput.prototype._deserializeSignatures = function(signatures) { return _.map(signatures, function(signature) { if (!signature) { return undefined; } return new TransactionSignature(signature); }); }; MultiSigInput.prototype._serializeSignatures = function() { return _.map(this.signatures, function(signature) { if (!signature) { return undefined; } return signature.toObject(); }); }; MultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype) { $.checkState(this.output instanceof Output); sigtype = sigtype || Signature.SIGHASH_ALL; var self = this; var results = []; _.each(this.publicKeys, function(publicKey) { if (publicKey.toString() === privateKey.publicKey.toString()) { results.push(new TransactionSignature({ publicKey: privateKey.publicKey, prevTxId: self.prevTxId, outputIndex: self.outputIndex, inputIndex: index, signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script), sigtype: sigtype })); } }); return results; }; MultiSigInput.prototype.addSignature = function(transaction, signature) { $.checkState(!this.isFullySigned(), 'All needed signatures have already been added'); $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]), 'Signature has no matching public key'); $.checkState(this.isValidSignature(transaction, signature)); this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature; this._updateScript(); return this; }; MultiSigInput.prototype._updateScript = function() { this.setScript(Script.buildMultisigIn( this.publicKeys, this.threshold, this._createSignatures() )); return this; }; MultiSigInput.prototype._createSignatures = function() { return _.map( _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }), function(signature) { return BufferUtil.concat([ signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype) ]); } ); }; MultiSigInput.prototype.clearSignatures = function() { this.signatures = new Array(this.publicKeys.length); this._updateScript(); }; MultiSigInput.prototype.isFullySigned = function() { return this.countSignatures() === this.threshold; }; MultiSigInput.prototype.countMissingSignatures = function() { return this.threshold - this.countSignatures(); }; MultiSigInput.prototype.countSignatures = function() { return _.reduce(this.signatures, function(sum, signature) { return sum + (!!signature); }, 0); }; MultiSigInput.prototype.publicKeysWithoutSignature = function() { var self = this; return _.filter(this.publicKeys, function(publicKey) { return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]); }); }; MultiSigInput.prototype.isValidSignature = function(transaction, signature) { // FIXME: Refactor signature so this is not necessary signature.signature.nhashtype = signature.sigtype; return Sighash.verify( transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script ); }; /** * * @param {Buffer[]} signatures * @param {PublicKey[]} publicKeys * @param {Transaction} transaction * @param {Integer} inputIndex * @param {Input} input * @returns {TransactionSignature[]} */ MultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys) { return publicKeys.map(function (pubKey) { var signatureMatch = null; signatures = signatures.filter(function (signatureBuffer) { if (signatureMatch) { return true; } var signature = new TransactionSignature({ signature: Signature.fromTxFormat(signatureBuffer), publicKey: pubKey, prevTxId: input.prevTxId, outputIndex: input.outputIndex, inputIndex: inputIndex, sigtype: Signature.SIGHASH_ALL }); signature.signature.nhashtype = signature.sigtype; var isMatch = Sighash.verify( transaction, signature.signature, signature.publicKey, signature.inputIndex, input.output.script ); if (isMatch) { signatureMatch = signature; return false; } return true; }); return signatureMatch ? signatureMatch : null; }); }; MultiSigInput.OPCODES_SIZE = 1; // 0 MultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72) MultiSigInput.prototype._estimateSize = function() { return MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE; }; module.exports = MultiSigInput; },{"../../crypto/signature":109,"../../publickey":122,"../../script":123,"../../util/buffer":141,"../../util/preconditions":143,"../output":133,"../sighash":134,"../signature":136,"../transaction":137,"./input":128,"inherits":145,"lodash":146}],130:[function(require,module,exports){ (function (Buffer){ 'use strict'; /* jshint maxparams:5 */ var _ = require('lodash'); var inherits = require('inherits'); var Input = require('./input'); var Output = require('../output'); var $ = require('../../util/preconditions'); var Script = require('../../script'); var Signature = require('../../crypto/signature'); var Sighash = require('../sighash'); var SighashWitness = require('../sighashwitness'); var BufferWriter = require('../../encoding/bufferwriter'); var BufferUtil = require('../../util/buffer'); var TransactionSignature = require('../signature'); /** * @constructor */ function MultiSigScriptHashInput(input, pubkeys, threshold, signatures, nestedWitness) { /* jshint maxstatements:20 */ Input.apply(this, arguments); var self = this; pubkeys = pubkeys || input.publicKeys; threshold = threshold || input.threshold; signatures = signatures || input.signatures; this.nestedWitness = nestedWitness ? true : false; this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); }); this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold); if (this.nestedWitness) { var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript); $.checkState(Script.buildScriptHashOut(nested).equals(this.output.script), 'Provided public keys don\'t hash to the provided output (nested witness)'); var scriptSig = new Script(); scriptSig.add(nested.toBuffer()); this.setScript(scriptSig); } else { $.checkState(Script.buildScriptHashOut(this.redeemScript).equals(this.output.script), 'Provided public keys don\'t hash to the provided output'); } this.publicKeyIndex = {}; _.each(this.publicKeys, function(publicKey, index) { self.publicKeyIndex[publicKey.toString()] = index; }); this.threshold = threshold; // Empty array of signatures this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length); } inherits(MultiSigScriptHashInput, Input); MultiSigScriptHashInput.prototype.toObject = function() { var obj = Input.prototype.toObject.apply(this, arguments); obj.threshold = this.threshold; obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); }); obj.signatures = this._serializeSignatures(); return obj; }; MultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) { return _.map(signatures, function(signature) { if (!signature) { return undefined; } return new TransactionSignature(signature); }); }; MultiSigScriptHashInput.prototype._serializeSignatures = function() { return _.map(this.signatures, function(signature) { if (!signature) { return undefined; } return signature.toObject(); }); }; MultiSigScriptHashInput.prototype.getScriptCode = function() { var writer = new BufferWriter(); if (!this.redeemScript.hasCodeseparators()) { var redeemScriptBuffer = this.redeemScript.toBuffer(); writer.writeVarintNum(redeemScriptBuffer.length); writer.write(redeemScriptBuffer); } else { throw new Error('@TODO'); } return writer.toBuffer(); }; MultiSigScriptHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) { var self = this; var hash; if (self.nestedWitness) { var scriptCode = self.getScriptCode(); var satoshisBuffer = self.getSatoshisBuffer(); hash = SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer); } else { hash = Sighash.sighash(transaction, sigtype, index, self.redeemScript); } return hash; }; MultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype) { $.checkState(this.output instanceof Output); sigtype = sigtype || Signature.SIGHASH_ALL; var self = this; var results = []; _.each(this.publicKeys, function(publicKey) { if (publicKey.toString() === privateKey.publicKey.toString()) { var signature; if (self.nestedWitness) { var scriptCode = self.getScriptCode(); var satoshisBuffer = self.getSatoshisBuffer(); signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer); } else { signature = Sighash.sign(transaction, privateKey, sigtype, index, self.redeemScript); } results.push(new TransactionSignature({ publicKey: privateKey.publicKey, prevTxId: self.prevTxId, outputIndex: self.outputIndex, inputIndex: index, signature: signature, sigtype: sigtype })); } }); return results; }; MultiSigScriptHashInput.prototype.addSignature = function(transaction, signature) { $.checkState(!this.isFullySigned(), 'All needed signatures have already been added'); $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]), 'Signature has no matching public key'); $.checkState(this.isValidSignature(transaction, signature)); this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature; this._updateScript(); return this; }; MultiSigScriptHashInput.prototype._updateScript = function() { if (this.nestedWitness) { var stack = [ new Buffer(0), ]; var signatures = this._createSignatures(); for (var i = 0; i < signatures.length; i++) { stack.push(signatures[i]); } stack.push(this.redeemScript.toBuffer()); this.setWitnesses(stack); } else { var scriptSig = Script.buildP2SHMultisigIn( this.publicKeys, this.threshold, this._createSignatures(), { cachedMultisig: this.redeemScript } ); this.setScript(scriptSig); } return this; }; MultiSigScriptHashInput.prototype._createSignatures = function() { return _.map( _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }), function(signature) { return BufferUtil.concat([ signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype) ]); } ); }; MultiSigScriptHashInput.prototype.clearSignatures = function() { this.signatures = new Array(this.publicKeys.length); this._updateScript(); }; MultiSigScriptHashInput.prototype.isFullySigned = function() { return this.countSignatures() === this.threshold; }; MultiSigScriptHashInput.prototype.countMissingSignatures = function() { return this.threshold - this.countSignatures(); }; MultiSigScriptHashInput.prototype.countSignatures = function() { return _.reduce(this.signatures, function(sum, signature) { return sum + (!!signature); }, 0); }; MultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() { var self = this; return _.filter(this.publicKeys, function(publicKey) { return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]); }); }; MultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature) { if (this.nestedWitness) { signature.signature.nhashtype = signature.sigtype; var scriptCode = this.getScriptCode(); var satoshisBuffer = this.getSatoshisBuffer(); return SighashWitness.verify( transaction, signature.signature, signature.publicKey, signature.inputIndex, scriptCode, satoshisBuffer ); } else { // FIXME: Refactor signature so this is not necessary signature.signature.nhashtype = signature.sigtype; return Sighash.verify( transaction, signature.signature, signature.publicKey, signature.inputIndex, this.redeemScript ); } }; MultiSigScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG MultiSigScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1) MultiSigScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33) MultiSigScriptHashInput.prototype._estimateSize = function() { return MultiSigScriptHashInput.OPCODES_SIZE + this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE + this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE; }; module.exports = MultiSigScriptHashInput; }).call(this,require("buffer").Buffer) },{"../../crypto/signature":109,"../../encoding/bufferwriter":113,"../../script":123,"../../util/buffer":141,"../../util/preconditions":143,"../output":133,"../sighash":134,"../sighashwitness":135,"../signature":136,"./input":128,"buffer":75,"inherits":145,"lodash":146}],131:[function(require,module,exports){ 'use strict'; var inherits = require('inherits'); var $ = require('../../util/preconditions'); var BufferUtil = require('../../util/buffer'); var Input = require('./input'); var Output = require('../output'); var Sighash = require('../sighash'); var Script = require('../../script'); var Signature = require('../../crypto/signature'); var TransactionSignature = require('../signature'); /** * Represents a special kind of input of PayToPublicKey kind. * @constructor */ function PublicKeyInput() { Input.apply(this, arguments); } inherits(PublicKeyInput, Input); /** * @param {Transaction} transaction - the transaction to be signed * @param {PrivateKey} privateKey - the private key with which to sign the transaction * @param {number} index - the index of the input in the transaction input vector * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL * @return {Array} of objects that can be */ PublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype) { $.checkState(this.output instanceof Output); sigtype = sigtype || Signature.SIGHASH_ALL; var publicKey = privateKey.toPublicKey(); if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) { return [new TransactionSignature({ publicKey: publicKey, prevTxId: this.prevTxId, outputIndex: this.outputIndex, inputIndex: index, signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script), sigtype: sigtype })]; } return []; }; /** * Add the provided signature * * @param {Object} signature * @param {PublicKey} signature.publicKey * @param {Signature} signature.signature * @param {number=} signature.sigtype * @return {PublicKeyInput} this, for chaining */ PublicKeyInput.prototype.addSignature = function(transaction, signature) { $.checkState(this.isValidSignature(transaction, signature), 'Signature is invalid'); this.setScript(Script.buildPublicKeyIn( signature.signature.toDER(), signature.sigtype )); return this; }; /** * Clear the input's signature * @return {PublicKeyHashInput} this, for chaining */ PublicKeyInput.prototype.clearSignatures = function() { this.setScript(Script.empty()); return this; }; /** * Query whether the input is signed * @return {boolean} */ PublicKeyInput.prototype.isFullySigned = function() { return this.script.isPublicKeyIn(); }; PublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72) PublicKeyInput.prototype._estimateSize = function() { return PublicKeyInput.SCRIPT_MAX_SIZE; }; module.exports = PublicKeyInput; },{"../../crypto/signature":109,"../../script":123,"../../util/buffer":141,"../../util/preconditions":143,"../output":133,"../sighash":134,"../signature":136,"./input":128,"inherits":145}],132:[function(require,module,exports){ 'use strict'; var inherits = require('inherits'); var $ = require('../../util/preconditions'); var BufferUtil = require('../../util/buffer'); var Hash = require('../../crypto/hash'); var Input = require('./input'); var Output = require('../output'); var Sighash = require('../sighash'); var Script = require('../../script'); var Signature = require('../../crypto/signature'); var TransactionSignature = require('../signature'); /** * Represents a special kind of input of PayToPublicKeyHash kind. * @constructor */ function PublicKeyHashInput() { Input.apply(this, arguments); } inherits(PublicKeyHashInput, Input); /* jshint maxparams: 5 */ /** * @param {Transaction} transaction - the transaction to be signed * @param {PrivateKey} privateKey - the private key with which to sign the transaction * @param {number} index - the index of the input in the transaction input vector * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided * @return {Array} of objects that can be */ PublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData) { $.checkState(this.output instanceof Output); hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer()); sigtype = sigtype || Signature.SIGHASH_ALL; if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) { return [new TransactionSignature({ publicKey: privateKey.publicKey, prevTxId: this.prevTxId, outputIndex: this.outputIndex, inputIndex: index, signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script), sigtype: sigtype })]; } return []; }; /* jshint maxparams: 3 */ /** * Add the provided signature * * @param {Object} signature * @param {PublicKey} signature.publicKey * @param {Signature} signature.signature * @param {number=} signature.sigtype * @return {PublicKeyHashInput} this, for chaining */ PublicKeyHashInput.prototype.addSignature = function(transaction, signature) { $.checkState(this.isValidSignature(transaction, signature), 'Signature is invalid'); this.setScript(Script.buildPublicKeyHashIn( signature.publicKey, signature.signature.toDER(), signature.sigtype )); return this; }; /** * Clear the input's signature * @return {PublicKeyHashInput} this, for chaining */ PublicKeyHashInput.prototype.clearSignatures = function() { this.setScript(Script.empty()); return this; }; /** * Query whether the input is signed * @return {boolean} */ PublicKeyHashInput.prototype.isFullySigned = function() { return this.script.isPublicKeyHashIn(); }; PublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33) PublicKeyHashInput.prototype._estimateSize = function() { return PublicKeyHashInput.SCRIPT_MAX_SIZE; }; module.exports = PublicKeyHashInput; },{"../../crypto/hash":106,"../../crypto/signature":109,"../../script":123,"../../util/buffer":141,"../../util/preconditions":143,"../output":133,"../sighash":134,"../signature":136,"./input":128,"inherits":145}],133:[function(require,module,exports){ 'use strict'; var _ = require('lodash'); var BN = require('../crypto/bn'); var buffer = require('buffer'); var bufferUtil = require('../util/buffer'); var JSUtil = require('../util/js'); var BufferWriter = require('../encoding/bufferwriter'); var Script = require('../script'); var $ = require('../util/preconditions'); var errors = require('../errors'); var MAX_SAFE_INTEGER = 0x1fffffffffffff; function Output(args) { if (!(this instanceof Output)) { return new Output(args); } if (_.isObject(args)) { this.satoshis = args.satoshis; if (bufferUtil.isBuffer(args.script)) { this._scriptBuffer = args.script; } else { var script; if (_.isString(args.script) && JSUtil.isHexa(args.script)) { script = new buffer.Buffer(args.script, 'hex'); } else { script = args.script; } this.setScript(script); } } else { throw new TypeError('Unrecognized argument for Output'); } } Object.defineProperty(Output.prototype, 'script', { configurable: false, enumerable: true, get: function() { if (this._script) { return this._script; } else { this.setScriptFromBuffer(this._scriptBuffer); return this._script; } } }); Object.defineProperty(Output.prototype, 'satoshis', { configurable: false, enumerable: true, get: function() { return this._satoshis; }, set: function(num) { if (num instanceof BN) { this._satoshisBN = num; this._satoshis = num.toNumber(); } else if (_.isString(num)) { this._satoshis = parseInt(num); this._satoshisBN = BN.fromNumber(this._satoshis); } else { $.checkArgument( JSUtil.isNaturalNumber(num), 'Output satoshis is not a natural number' ); this._satoshisBN = BN.fromNumber(num); this._satoshis = num; } $.checkState( JSUtil.isNaturalNumber(this._satoshis), 'Output satoshis is not a natural number' ); } }); Output.prototype.invalidSatoshis = function() { if (this._satoshis > MAX_SAFE_INTEGER) { return 'transaction txout satoshis greater than max safe integer'; } if (this._satoshis !== this._satoshisBN.toNumber()) { return 'transaction txout satoshis has corrupted value'; } if (this._satoshis < 0) { return 'transaction txout negative'; } return false; }; Output.prototype.toObject = Output.prototype.toJSON = function toObject() { var obj = { satoshis: this.satoshis }; obj.script = this._scriptBuffer.toString('hex'); return obj; }; Output.fromObject = function(data) { return new Output(data); }; Output.prototype.setScriptFromBuffer = function(buffer) { this._scriptBuffer = buffer; try { this._script = Script.fromBuffer(this._scriptBuffer); this._script._isOutput = true; } catch(e) { if (e instanceof errors.Script.InvalidBuffer) { this._script = null; } else { throw e; } } }; Output.prototype.setScript = function(script) { if (script instanceof Script) { this._scriptBuffer = script.toBuffer(); this._script = script; this._script._isOutput = true; } else if (_.isString(script)) { this._script = Script.fromString(script); this._scriptBuffer = this._script.toBuffer(); this._script._isOutput = true; } else if (bufferUtil.isBuffer(script)) { this.setScriptFromBuffer(script); } else { throw new TypeError('Invalid argument type: script'); } return this; }; Output.prototype.inspect = function() { var scriptStr; if (this.script) { scriptStr = this.script.inspect(); } else { scriptStr = this._scriptBuffer.toString('hex'); } return '<Output (' + this.satoshis + ' sats) ' + scriptStr + '>'; }; Output.fromBufferReader = function(br) { var obj = {}; obj.satoshis = br.readUInt64LEBN(); var size = br.readVarintNum(); if (size !== 0) { obj.script = br.read(size); } else { obj.script = new buffer.Buffer([]); } return new Output(obj); }; Output.prototype.toBufferWriter = function(writer) { if (!writer) { writer = new BufferWriter(); } writer.writeUInt64LEBN(this._satoshisBN); var script = this._scriptBuffer; writer.writeVarintNum(script.length); writer.write(script); return writer; }; module.exports = Output; },{"../crypto/bn":104,"../encoding/bufferwriter":113,"../errors":115,"../script":123,"../util/buffer":141,"../util/js":142,"../util/preconditions":143,"buffer":75,"lodash":146}],134:[function(require,module,exports){ (function (Buffer){ 'use strict'; var buffer = require('buffer'); var Signature = require('../crypto/signature'); var Script = require('../script'); var Output = require('./output'); var BufferReader = require('../encoding/bufferreader'); var BufferWriter = require('../encoding/bufferwriter'); var BN = require('../crypto/bn'); var Hash = require('../crypto/hash'); var ECDSA = require('../crypto/ecdsa'); var $ = require('../util/preconditions'); var _ = require('lodash'); var SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001'; var BITS_64_ON = 'ffffffffffffffff'; /** * Returns a buffer of length 32 bytes with the hash that needs to be signed * for OP_CHECKSIG. * * @name Signing.sighash * @param {Transaction} transaction the transaction to sign * @param {number} sighashType the type of the hash * @param {number} inputNumber the input index for the signature * @param {Script} subscript the script that will be signed */ var sighash = function sighash(transaction, sighashType, inputNumber, subscript) { var Transaction = require('./transaction'); var Input = require('./input'); var i; // Copy transaction var txcopy = Transaction.shallowCopy(transaction); // Copy script subscript = new Script(subscript); subscript.removeCodeseparators(); for (i = 0; i < txcopy.inputs.length; i++) { // Blank signatures for other inputs txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty()); } txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript); if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) { // clear all sequenceNumbers for (i = 0; i < txcopy.inputs.length; i++) { if (i !== inputNumber) { txcopy.inputs[i].sequenceNumber = 0; } } } if ((sighashType & 31) === Signature.SIGHASH_NONE) { txcopy.outputs = []; } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) { // The SIGHASH_SINGLE bug. // https://bitcointalk.org/index.php?topic=260595.0 if (inputNumber >= txcopy.outputs.length) { return new Buffer(SIGHASH_SINGLE_BUG, 'hex'); } txcopy.outputs.length = inputNumber + 1; for (i = 0; i < inputNumber; i++) { txcopy.outputs[i] = new Output({ satoshis: BN.fromBuffer(new buffer.Buffer(BITS_64_ON, 'hex')), script: Script.empty() }); } } if (sighashType & Signature.SIGHASH_ANYONECANPAY) { txcopy.inputs = [txcopy.inputs[inputNumber]]; } var buf = new BufferWriter() .write(txcopy.toBuffer()) .writeInt32LE(sighashType) .toBuffer(); var ret = Hash.sha256sha256(buf); ret = new BufferReader(ret).readReverse(); return ret; }; /** * Create a signature * * @name Signing.sign * @param {Transaction} transaction * @param {PrivateKey} privateKey * @param {number} sighash * @param {number} inputIndex * @param {Script} subscript * @return {Signature} */ function sign(transaction, privateKey, sighashType, inputIndex, subscript) { var hashbuf = sighash(transaction, sighashType, inputIndex, subscript); var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({ nhashtype: sighashType }); return sig; } /** * Verify a signature * * @name Signing.verify * @param {Transaction} transaction * @param {Signature} signature * @param {PublicKey} publicKey * @param {number} inputIndex * @param {Script} subscript * @return {boolean} */ function verify(transaction, signature, publicKey, inputIndex, subscript) { $.checkArgument(!_.isUndefined(transaction)); $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype)); var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript); return ECDSA.verify(hashbuf, signature, publicKey, 'little'); } /** * @namespace Signing */ module.exports = { sighash: sighash, sign: sign, verify: verify }; }).call(this,require("buffer").Buffer) },{"../crypto/bn":104,"../crypto/ecdsa":105,"../crypto/hash":106,"../crypto/signature":109,"../encoding/bufferreader":112,"../encoding/bufferwriter":113,"../script":123,"../util/preconditions":143,"./input":127,"./output":133,"./transaction":137,"buffer":75,"lodash":146}],135:[function(require,module,exports){ (function (Buffer){ 'use strict'; /* jshint maxparams:5 */ var Signature = require('../crypto/signature'); var Script = require('../script'); var Output = require('./output'); var BufferReader = require('../encoding/bufferreader'); var BufferWriter = require('../encoding/bufferwriter'); var BN = require('../crypto/bn'); var Hash = require('../crypto/hash'); var ECDSA = require('../crypto/ecdsa'); var $ = require('../util/preconditions'); var _ = require('lodash'); /** * Returns a buffer of length 32 bytes with the hash that needs to be signed * for witness programs as defined by: * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki * * @name Signing.sighash * @param {Transaction} transaction the transaction to sign * @param {number} sighashType the type of the hash * @param {number} inputNumber the input index for the signature * @param {Buffer} scriptCode * @param {Buffer} satoshisBuffer */ var sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) { /* jshint maxstatements: 50 */ var hashPrevouts; var hashSequence; var hashOutputs; if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) { var buffers = []; for (var n = 0; n < transaction.inputs.length; n++) { var input = transaction.inputs[n]; var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse(); buffers.push(prevTxIdBuffer); var outputIndexBuffer = new Buffer(new Array(4)); outputIndexBuffer.writeUInt32LE(input.outputIndex, 0); buffers.push(outputIndexBuffer); } hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers)); } if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) { var sequenceBuffers = []; for (var m = 0; m < transaction.inputs.length; m++) { var sequenceBuffer = new Buffer(new Array(4)); sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0); sequenceBuffers.push(sequenceBuffer); } hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers)); } var outputWriter = new BufferWriter(); if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) { for (var p = 0; p < transaction.outputs.length; p++) { transaction.outputs[p].toBufferWriter(outputWriter); } hashOutputs = Hash.sha256sha256(outputWriter.toBuffer()); } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) { transaction.outputs[inputNumber].toBufferWriter(outputWriter); hashOutputs = Hash.sha256sha256(outputWriter.toBuffer()); } // Version var writer = new BufferWriter(); writer.writeUInt32LE(transaction.version); // Input prevouts/nSequence (none/all, depending on flags) writer.write(hashPrevouts); writer.write(hashSequence); // The input being signed (replacing the scriptSig with scriptCode + amount) // The prevout may already be contained in hashPrevout, and the nSequence // may already be contain in hashSequence. var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse(); writer.write(outpointId); writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex); writer.write(scriptCode); writer.write(satoshisBuffer); writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber); // Outputs (none/one/all, depending on flags) writer.write(hashOutputs); // Locktime writer.writeUInt32LE(transaction.nLockTime); // Sighash type writer.writeInt32LE(sighashType); return Hash.sha256sha256(writer.toBuffer()); }; /** * Create a signature * * @name Signing.sign * @param {Transaction} transaction * @param {PrivateKey} privateKey * @param {number} sighash * @param {number} inputIndex * @param {Script} subscript * @return {Signature} */ function sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer) { var hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer); var sig = ECDSA.sign(hashbuf, privateKey).set({ nhashtype: sighashType }); return sig; } /** * Verify a signature * * @name Signing.verify * @param {Transaction} transaction * @param {Signature} signature * @param {PublicKey} publicKey * @param {number} inputIndex * @param {Script} subscript * @return {boolean} */ function verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer) { $.checkArgument(!_.isUndefined(transaction)); $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype)); var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer); return ECDSA.verify(hashbuf, signature, publicKey); } /** * @namespace Signing */ module.exports = { sighash: sighash, sign: sign, verify: verify }; }).call(this,require("buffer").Buffer) },{"../crypto/bn":104,"../crypto/ecdsa":105,"../crypto/hash":106,"../crypto/signature":109,"../encoding/bufferreader":112,"../encoding/bufferwriter":113,"../script":123,"../util/preconditions":143,"./output":133,"buffer":75,"lodash":146}],136:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var $ = require('../util/preconditions'); var inherits = require('inherits'); var BufferUtil = require('../util/buffer'); var JSUtil = require('../util/js'); var PublicKey = require('../publickey'); var errors = require('../errors'); var Signature = require('../crypto/signature'); /** * @desc * Wrapper around Signature with fields related to signing a transaction specifically * * @param {Object|string|TransactionSignature} arg * @constructor */ function TransactionSignature(arg) { if (!(this instanceof TransactionSignature)) { return new TransactionSignature(arg); } if (arg instanceof TransactionSignature) { return arg; } if (_.isObject(arg)) { return this._fromObject(arg); } throw new errors.InvalidArgument('TransactionSignatures must be instantiated from an object'); } inherits(TransactionSignature, Signature); TransactionSignature.prototype._fromObject = function(arg) { this._checkObjectArgs(arg); this.publicKey = new PublicKey(arg.publicKey); this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : new Buffer(arg.prevTxId, 'hex'); this.outputIndex = arg.outputIndex; this.inputIndex = arg.inputIndex; this.signature = (arg.signature instanceof Signature) ? arg.signature : BufferUtil.isBuffer(arg.signature) ? Signature.fromBuffer(arg.signature) : Signature.fromString(arg.signature); this.sigtype = arg.sigtype; return this; }; TransactionSignature.prototype._checkObjectArgs = function(arg) { $.checkArgument(PublicKey(arg.publicKey), 'publicKey'); $.checkArgument(!_.isUndefined(arg.inputIndex), 'inputIndex'); $.checkArgument(!_.isUndefined(arg.outputIndex), 'outputIndex'); $.checkState(_.isNumber(arg.inputIndex), 'inputIndex must be a number'); $.checkState(_.isNumber(arg.outputIndex), 'outputIndex must be a number'); $.checkArgument(arg.signature, 'signature'); $.checkArgument(arg.prevTxId, 'prevTxId'); $.checkState(arg.signature instanceof Signature || BufferUtil.isBuffer(arg.signature) || JSUtil.isHexa(arg.signature), 'signature must be a buffer or hexa value'); $.checkState(BufferUtil.isBuffer(arg.prevTxId) || JSUtil.isHexa(arg.prevTxId), 'prevTxId must be a buffer or hexa value'); $.checkArgument(arg.sigtype, 'sigtype'); $.checkState(_.isNumber(arg.sigtype), 'sigtype must be a number'); }; /** * Serializes a transaction to a plain JS object * @return {Object} */ TransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject() { return { publicKey: this.publicKey.toString(), prevTxId: this.prevTxId.toString('hex'), outputIndex: this.outputIndex, inputIndex: this.inputIndex, signature: this.signature.toString(), sigtype: this.sigtype }; }; /** * Builds a TransactionSignature from an object * @param {Object} object * @return {TransactionSignature} */ TransactionSignature.fromObject = function(object) { $.checkArgument(object); return new TransactionSignature(object); }; module.exports = TransactionSignature; }).call(this,require("buffer").Buffer) },{"../crypto/signature":109,"../errors":115,"../publickey":122,"../util/buffer":141,"../util/js":142,"../util/preconditions":143,"buffer":75,"inherits":145,"lodash":146}],137:[function(require,module,exports){ (function (Buffer){ 'use strict'; var _ = require('lodash'); var $ = require('../util/preconditions'); var buffer = require('buffer'); var compare = Buffer.compare || require('buffer-compare'); var errors = require('../errors'); var BufferUtil = require('../util/buffer'); var JSUtil = require('../util/js'); var BufferReader = require('../encoding/bufferreader'); var BufferWriter = require('../encoding/bufferwriter'); var Hash = require('../crypto/hash'); var Signature = require('../crypto/signature'); var Sighash = require('./sighash'); var SighashWitness = require('./sighashwitness'); var Address = require('../address'); var UnspentOutput = require('./unspentoutput'); var Input = require('./input'); var PublicKeyHashInput = Input.PublicKeyHash; var PublicKeyInput = Input.PublicKey; var MultiSigScriptHashInput = Input.MultiSigScriptHash; var MultiSigInput = Input.MultiSig; var Output = require('./output'); var Script = require('../script'); var PrivateKey = require('../privatekey'); var BN = require('../crypto/bn'); /** * Represents a transaction, a set of inputs and outputs to change ownership of tokens * * @param {*} serialized * @constructor */ function Transaction(serialized) { if (!(this instanceof Transaction)) { return new Transaction(serialized); } this.inputs = []; this.outputs = []; this._inputAmount = undefined; this._outputAmount = undefined; if (serialized) { if (serialized instanceof Transaction) { return Transaction.shallowCopy(serialized); } else if (JSUtil.isHexa(serialized)) { this.fromString(serialized); } else if (BufferUtil.isBuffer(serialized)) { this.fromBuffer(serialized); } else if (_.isObject(serialized)) { this.fromObject(serialized); } else { throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction'); } } else { this._newTransaction(); } } var CURRENT_VERSION = 1; var DEFAULT_NLOCKTIME = 0; var MAX_BLOCK_SIZE = 1000000; // Minimum amount for an output for it not to be considered a dust output Transaction.DUST_AMOUNT = 546; // Margin of error to allow fees in the vecinity of the expected value but doesn't allow a big difference Transaction.FEE_SECURITY_MARGIN = 150; // max amount of satoshis in circulation Transaction.MAX_MONEY = 84000000 * 1e8; // Litecoin has 84M coins // nlocktime limit to be considered block height rather than a timestamp Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8; // Max value for an unsigned 32 bit value Transaction.NLOCKTIME_MAX_VALUE = 4294967295; // Value used for fee estimation (satoshis per kilobyte) Transaction.FEE_PER_KB = 100000; // Litecoin default fees is 0.001 LTC // Safe upper bound for change address script size in bytes Transaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4; Transaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4; /* Constructors and Serialization */ /** * Create a 'shallow' copy of the transaction, by serializing and deserializing * it dropping any additional information that inputs and outputs may have hold * * @param {Transaction} transaction * @return {Transaction} */ Transaction.shallowCopy = function(transaction) { var copy = new Transaction(transaction.toBuffer()); return copy; }; var hashProperty = { configurable: false, enumerable: true, get: function() { return new BufferReader(this._getHash()).readReverse().toString('hex'); } }; var witnessHashProperty = { configurable: false, enumerable: true, get: function() { return new BufferReader(this._getWitnessHash()).readReverse().toString('hex'); } }; Object.defineProperty(Transaction.prototype, 'witnessHash', witnessHashProperty); Object.defineProperty(Transaction.prototype, 'hash', hashProperty); Object.defineProperty(Transaction.prototype, 'id', hashProperty); var ioProperty = { configurable: false, enumerable: true, get: function() { return this._getInputAmount(); } }; Object.defineProperty(Transaction.prototype, 'inputAmount', ioProperty); ioProperty.get = function() { return this._getOutputAmount(); }; Object.defineProperty(Transaction.prototype, 'outputAmount', ioProperty); /** * Retrieve the little endian hash of the transaction (used for serialization) * @return {Buffer} */ Transaction.prototype._getHash = function() { return Hash.sha256sha256(this.toBuffer(true)); }; /** * Retrieve the little endian hash of the transaction including witness data * @return {Buffer} */ Transaction.prototype._getWitnessHash = function() { return Hash.sha256sha256(this.toBuffer(false)); }; /** * Retrieve a hexa string that can be used with bitcoind's CLI interface * (decoderawtransaction, sendrawtransaction) * * @param {Object|boolean=} unsafe if true, skip all tests. if it's an object, * it's expected to contain a set of flags to skip certain tests: * * `disableAll`: disable all checks * * `disableSmallFees`: disable checking for fees that are too small * * `disableLargeFees`: disable checking for fees that are too large * * `disableIsFullySigned`: disable checking if all inputs are fully signed * * `disableDustOutputs`: disable checking if there are no outputs that are dust amounts * * `disableMoreOutputThanInput`: disable checking if the transaction spends more bitcoins than the sum of the input amounts * @return {string} */ Transaction.prototype.serialize = function(unsafe) { if (true === unsafe || unsafe && unsafe.disableAll) { return this.uncheckedSerialize(); } else { return this.checkedSerialize(unsafe); } }; Transaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function() { return this.toBuffer().toString('hex'); }; /** * Retrieve a hexa string that can be used with bitcoind's CLI interface * (decoderawtransaction, sendrawtransaction) * * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize} * @return {string} */ Transaction.prototype.checkedSerialize = function(opts) { var serializationError = this.getSerializationError(opts); if (serializationError) { serializationError.message += ' - For more information please see: ' + 'http://litecore.io/guide/transaction.html#serialization-checks'; throw serializationError; } return this.uncheckedSerialize(); }; Transaction.prototype.invalidSatoshis = function() { var invalid = false; for (var i = 0; i < this.outputs.length; i++) { if (this.outputs[i].invalidSatoshis()) { invalid = true; } } return invalid; }; /** * Retrieve a possible error that could appear when trying to serialize and * broadcast this transaction. * * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize} * @return {litecore.Error} */ Transaction.prototype.getSerializationError = function(opts) { opts = opts || {}; if (this.invalidSatoshis()) { return new errors.Transaction.InvalidSatoshis(); } var unspent = this._getUnspentValue(); var unspentError; if (unspent < 0) { if (!opts.disableMoreOutputThanInput) { unspentError = new errors.Transaction.InvalidOutputAmountSum(); } } else { unspentError = this._hasFeeError(opts, unspent); } return unspentError || this._hasDustOutputs(opts) || this._isMissingSignatures(opts); }; Transaction.prototype._hasFeeError = function(opts, unspent) { if (!_.isUndefined(this._fee) && this._fee !== unspent) { return new errors.Transaction.FeeError.Different( 'Unspent value is ' + unspent + ' but specified fee is ' + this._fee ); } if (!opts.disableLargeFees) { var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee()); if (unspent > maximumFee) { if (this._missingChange()) { return new errors.Transaction.ChangeAddressMissing( 'Fee is too large and no change address was provided' ); } return new errors.Transaction.FeeError.TooLarge( 'expected less than ' + maximumFee + ' but got ' + unspent ); } } if (!opts.disableSmallFees) { var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN); if (unspent < minimumFee) { return new errors.Transaction.FeeError.TooSmall( 'expected more than ' + minimumFee + ' but got ' + unspent ); } } }; Transaction.prototype._missingChange = function() { return !this._changeScript; }; Transaction.prototype._hasDustOutputs = function(opts) { if (opts.disableDustOutputs) { return; } var index, output; for (index in this.outputs) { output = this.outputs[index]; if (output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut()) { return new errors.Transaction.DustOutputs(); } } }; Transaction.prototype._isMissingSignatures = function(opts) { if (opts.disableIsFullySigned) { return; } if (!this.isFullySigned()) { return new errors.Transaction.MissingSignatures(); } }; Transaction.prototype.inspect = function() { return '<Transaction: ' + this.uncheckedSerialize() + '>'; }; Transaction.prototype.toBuffer = function(noWitness) { var writer = new BufferWriter(); return this.toBufferWriter(writer, noWitness).toBuffer(); }; Transaction.prototype.hasWitnesses = function() { for (var i = 0; i < this.inputs.length; i++) { if (this.inputs[i].hasWitnesses()) { return true; } } return false; }; Transaction.prototype.toBufferWriter = function(writer, noWitness) { writer.writeInt32LE(this.version); var hasWitnesses = this.hasWitnesses(); if (hasWitnesses && !noWitness) { writer.write(new Buffer('0001', 'hex')); } writer.writeVarintNum(this.inputs.length); _.each(this.inputs, function(input) { input.toBufferWriter(writer); }); writer.writeVarintNum(this.outputs.length); _.each(this.outputs, function(output) { output.toBufferWriter(writer); }); if (hasWitnesses && !noWitness) { _.each(this.inputs, function(input) { var witnesses = input.getWitnesses(); writer.writeVarintNum(witnesses.length); for (var j = 0; j < witnesses.length; j++) { writer.writeVarintNum(witnesses[j].length); writer.write(witnesses[j]); } }); } writer.writeUInt32LE(this.nLockTime); return writer; }; Transaction.prototype.fromBuffer = function(buffer) { var reader = new BufferReader(buffer); return this.fromBufferReader(reader); }; Transaction.prototype.fromBufferReader = function(reader) { $.checkArgument(!reader.finished(), 'No transaction data received'); this.version = reader.readInt32LE(); var sizeTxIns = reader.readVarintNum(); // check for segwit var hasWitnesses = false; if (sizeTxIns === 0 && reader.buf[reader.pos] !== 0) { reader.pos += 1; hasWitnesses = true; sizeTxIns = reader.readVarintNum(); } for (var i = 0; i < sizeTxIns; i++) { var input = Input.fromBufferReader(reader); this.inputs.push(input); } var sizeTxOuts = reader.readVarintNum(); for (var j = 0; j < sizeTxOuts; j++) { this.outputs.push(Output.fromBufferReader(reader)); } if (hasWitnesses) { for (var k = 0; k < sizeTxIns; k++) { var itemCount = reader.readVarintNum(); var witnesses = []; for (var l = 0; l < itemCount; l++) { var size = reader.readVarintNum(); var item = reader.read(size); witnesses.push(item); } this.inputs[k].setWitnesses(witnesses); } } this.nLockTime = reader.readUInt32LE(); return this; }; Transaction.prototype.toObject = Transaction.prototype.toJSON = function toObject() { var inputs = []; this.inputs.forEach(function(input) { inputs.push(input.toObject()); }); var outputs = []; this.outputs.forEach(function(output) { outputs.push(output.toObject()); }); var obj = { hash: this.hash, version: this.version, inputs: inputs, outputs: outputs, nLockTime: this.nLockTime }; if (this._changeScript) { obj.changeScript = this._changeScript.toString(); } if (!_.isUndefined(this._changeIndex)) { obj.changeIndex = this._changeIndex; } if (!_.isUndefined(this._fee)) { obj.fee = this._fee; } return obj; }; Transaction.prototype.fromObject = function fromObject(arg) { /* jshint maxstatements: 20 */ $.checkArgument(_.isObject(arg) || arg instanceof Transaction); var self = this; var transaction; if (arg instanceof Transaction) { transaction = transaction.toObject(); } else { transaction = arg; } _.each(transaction.inputs, function(input) { if (!input.output || !input.output.script) { self.uncheckedAddInput(new Input(input)); return; } var script = new Script(input.output.script); var txin; if (script.isPublicKeyHashOut()) { txin = new Input.PublicKeyHash(input); } else if (script.isScriptHashOut() && input.publicKeys && input.threshold) { txin = new Input.MultiSigScriptHash( input, input.publicKeys, input.threshold, input.signatures ); } else if (script.isPublicKeyOut()) { txin = new Input.PublicKey(input); } else { throw new errors.Transaction.Input.UnsupportedScript(input.output.script); } self.addInput(txin); }); _.each(transaction.outputs, function(output) { self.addOutput(new Output(output)); }); if (transaction.changeIndex) { this._changeIndex = transaction.changeIndex; } if (transaction.changeScript) { this._changeScript = new Script(transaction.changeScript); } if (transaction.fee) { this._fee = transaction.fee; } this.nLockTime = transaction.nLockTime; this.version = transaction.version; this._checkConsistency(arg); return this; }; Transaction.prototype._checkConsistency = function(arg) { if (!_.isUndefined(this._changeIndex)) { $.checkState(this._changeScript); $.checkState(this.outputs[this._changeIndex]); $.checkState(this.outputs[this._changeIndex].script.toString() === this._changeScript.toString()); } if (arg && arg.hash) { $.checkState(arg.hash === this.hash, 'Hash in object does not match transaction hash'); } }; /** * Sets nLockTime so that transaction is not valid until the desired date(a * timestamp in seconds since UNIX epoch is also accepted) * * @param {Date | Number} time * @return {Transaction} this */ Transaction.prototype.lockUntilDate = function(time) { $.checkArgument(time); if (_.isNumber(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) { throw new errors.Transaction.LockTimeTooEarly(); } if (_.isDate(time)) { time = time.getTime() / 1000; } for (var i = 0; i < this.inputs.length; i++) { if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){ this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER; } } this.nLockTime = time; return this; }; /** * Sets nLockTime so that transaction is not valid until the desired block * height. * * @param {Number} height * @return {Transaction} this */ Transaction.prototype.lockUntilBlockHeight = function(height) { $.checkArgument(_.isNumber(height)); if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) { throw new errors.Transaction.BlockHeightTooHigh(); } if (height < 0) { throw new errors.Transaction.NLockTimeOutOfRange(); } for (var i = 0; i < this.inputs.length; i++) { if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){ this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER; } } this.nLockTime = height; return this; }; /** * Returns a semantic version of the transaction's nLockTime. * @return {Number|Date} * If nLockTime is 0, it returns null, * if it is < 500000000, it returns a block height (number) * else it returns a Date object. */ Transaction.prototype.getLockTime = function() { if (!this.nLockTime) { return null; } if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) { return this.nLockTime; } return new Date(1000 * this.nLockTime); }; Transaction.prototype.fromString = function(string) { this.fromBuffer(new buffer.Buffer(string, 'hex')); }; Transaction.prototype._newTransaction = function() { this.version = CURRENT_VERSION; this.nLockTime = DEFAULT_NLOCKTIME; }; /* Transaction creation interface */ /** * @typedef {Object} Transaction~fromObject * @property {string} prevTxId * @property {number} outputIndex * @property {(Buffer|string|Script)} script * @property {number} satoshis */ /** * Add an input to this transaction. This is a high level interface * to add an input, for more control, use @{link Transaction#addInput}. * * Can receive, as output information, the output of bitcoind's `listunspent` command, * and a slightly fancier format recognized by litecore: * * ``` * { * address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1', * txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458', * outputIndex: 0, * script: Script.empty(), * satoshis: 1020000 * } * ``` * Where `address` can be either a string or a litecore Address object. The * same is true for `script`, which can be a string or a litecore Script. * * Beware that this resets all the signatures for inputs (in further versions, * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset). * * @example * ```javascript * var transaction = new Transaction(); * * // From a pay to public key hash output from bitcoind's listunspent * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'}); * * // From a pay to public key hash output * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'}); * * // From a multisig P2SH output * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'}, * ['03000...', '02000...'], 2); * ``` * * @param {(Array.<Transaction~fromObject>|Transaction~fromObject)} utxo * @param {Array=} pubkeys * @param {number=} threshold * @param {boolean=} nestedWitness - Indicates that the utxo is nested witness p2sh */ Transaction.prototype.from = function(utxo, pubkeys, threshold, nestedWitness) { if (_.isArray(utxo)) { var self = this; _.each(utxo, function(utxo) { self.from(utxo, pubkeys, threshold); }); return this; } var exists = _.some(this.inputs, function(input) { // TODO: Maybe prevTxId should be a string? Or defined as read only property? return input.prevTxId.toString('hex') === utxo.txId && input.outputIndex === utxo.outputIndex; }); if (exists) { return this; } if (pubkeys && threshold) { this._fromMultisigUtxo(utxo, pubkeys, threshold, nestedWitness); } else { this._fromNonP2SH(utxo); } return this; }; Transaction.prototype._fromNonP2SH = function(utxo) { var clazz; utxo = new UnspentOutput(utxo); if (utxo.script.isPublicKeyHashOut()) { clazz = PublicKeyHashInput; } else if (utxo.script.isPublicKeyOut()) { clazz = PublicKeyInput; } else { clazz = Input; } this.addInput(new clazz({ output: new Output({ script: utxo.script, satoshis: utxo.satoshis }), prevTxId: utxo.txId, outputIndex: utxo.outputIndex, script: Script.empty() })); }; Transaction.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold, nestedWitness) { $.checkArgument(threshold <= pubkeys.length, 'Number of required signatures must be greater than the number of public keys'); var clazz; utxo = new UnspentOutput(utxo); if (utxo.script.isMultisigOut()) { clazz = MultiSigInput; } else if (utxo.script.isScriptHashOut()) { clazz = MultiSigScriptHashInput; } else { throw new Error("@TODO"); } this.addInput(new clazz({ output: new Output({ script: utxo.script, satoshis: utxo.satoshis }), prevTxId: utxo.txId, outputIndex: utxo.outputIndex, script: Script.empty() }, pubkeys, threshold, false, nestedWitness)); }; /** * Add an input to this transaction. The input must be an instance of the `Input` class. * It should have information about the Output that it's spending, but if it's not already * set, two additional parameters, `outputScript` and `satoshis` can be provided. * * @param {Input} input * @param {String|Script} outputScript * @param {number} satoshis * @return Transaction this, for chaining */ Transaction.prototype.addInput = function(input, outputScript, satoshis) { $.checkArgumentType(input, Input, 'input'); if (!input.output && (_.isUndefined(outputScript) || _.isUndefined(satoshis))) { throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis'); } if (!input.output && outputScript && !_.isUndefined(satoshis)) { outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript); $.checkArgumentType(satoshis, 'number', 'satoshis'); input.output = new Output({ script: outputScript, satoshis: satoshis }); } return this.uncheckedAddInput(input); }; /** * Add an input to this transaction, without checking that the input has information about * the output that it's spending. * * @param {Input} input * @return Transaction this, for chaining */ Transaction.prototype.uncheckedAddInput = function(input) { $.checkArgumentType(input, Input, 'input'); this.inputs.push(input); this._inputAmount = undefined; this._updateChangeOutput(); return this; }; /** * Returns true if the transaction has enough info on all inputs to be correctly validated * * @return {boolean} */ Transaction.prototype.hasAllUtxoInfo = function() { return _.every(this.inputs.map(function(input) { return !!input.output; })); }; /** * Manually set the fee for this transaction. Beware that this resets all the signatures * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not * be reset). * * @param {number} amount satoshis to be sent * @return {Transaction} this, for chaining */ Transaction.prototype.fee = function(amount) { $.checkArgument(_.isNumber(amount), 'amount must be a number'); this._fee = amount; this._updateChangeOutput(); return this; }; /** * Manually set the fee per KB for this transaction. Beware that this resets all the signatures * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not * be reset). * * @param {number} amount satoshis per KB to be sent * @return {Transaction} this, for chaining */ Transaction.prototype.feePerKb = function(amount) { $.checkArgument(_.isNumber(amount), 'amount must be a number'); this._feePerKb = amount; this._updateChangeOutput(); return this; }; /* Output management */ /** * Set the change address for this transaction * * Beware that this resets all the signatures for inputs (in further versions, * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset). * * @param {Address} address An address for change to be sent to. * @return {Transaction} this, for chaining */ Transaction.prototype.change = function(address) { $.checkArgument(address, 'address is required'); this._changeScript = Script.fromAddress(address); this._updateChangeOutput(); return this; }; /** * @return {Output} change output, if it exists */ Transaction.prototype.getChangeOutput = function() { if (!_.isUndefined(this._changeIndex)) { return this.outputs[this._changeIndex]; } return null; }; /** * @typedef {Object} Transaction~toObject * @property {(string|Address)} address * @property {number} satoshis */ /** * Add an output to the transaction. * * Beware that this resets all the signatures for inputs (in further versions, * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset). * * @param {(string|Address|Array.<Transaction~toObject>)} address * @param {number} amount in satoshis * @return {Transaction} this, for chaining */ Transaction.prototype.to = function(address, amount) { if (_.isArray(address)) { var self = this; _.each(address, function(to) { self.to(to.address, to.satoshis); }); return this; } $.checkArgument( JSUtil.isNaturalNumber(amount), 'Amount is expected to be a positive integer' ); this.addOutput(new Output({ script: Script(new Address(address)), satoshis: amount })); return this; }; /** * Add an OP_RETURN output to the transaction. * * Beware that this resets all the signatures for inputs (in further versions, * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset). * * @param {Buffer|string} value the data to be stored in the OP_RETURN output. * In case of a string, the UTF-8 representation will be stored * @return {Transaction} this, for chaining */ Transaction.prototype.addData = function(value) { this.addOutput(new Output({ script: Script.buildDataOut(value), satoshis: 0 })); return this; }; /** * Add an output to the transaction. * * @param {Output} output the output to add. * @return {Transaction} this, for chaining */ Transaction.prototype.addOutput = function(output) { $.checkArgumentType(output, Output, 'output'); this._addOutput(output); this._updateChangeOutput(); return this; }; /** * Remove all outputs from the transaction. * * @return {Transaction} this, for chaining */ Transaction.prototype.clearOutputs = function() { this.outputs = []; this._clearSignatures(); this._outputAmount = undefined; this._changeIndex = undefined; this._updateChangeOutput(); return this; }; Transaction.prototype._addOutput = function(output) { this.outputs.push(output); this._outputAmount = undefined; }; /** * Calculates or gets the total output amount in satoshis * * @return {Number} the transaction total output amount */ Transaction.prototype._getOutputAmount = function() { if (_.isUndefined(this._outputAmount)) { var self = this; this._outputAmount = 0; _.each(this.outputs, function(output) { self._outputAmount += output.satoshis; }); } return this._outputAmount; }; /** * Calculates or gets the total input amount in satoshis * * @return {Number} the transaction total input amount */ Transaction.prototype._getInputAmount = function() { if (_.isUndefined(this._inputAmount)) { var self = this; this._inputAmount = 0; _.each(this.inputs, function(input) { if (_.isUndefined(input.output)) { throw new errors.Transaction.Input.MissingPreviousOutput(); } self._inputAmount += input.output.satoshis; }); } return this._inputAmount; }; Transaction.prototype._updateChangeOutput = function() { if (!this._changeScript) { return; } this._clearSignatures(); if (!_.isUndefined(this._changeIndex)) { this._removeOutput(this._changeIndex); } var available = this._getUnspentValue(); var fee = this.getFee(); var changeAmount = available - fee; if (changeAmount > 0) { this._changeIndex = this.outputs.length; this._addOutput(new Output({ script: this._changeScript, satoshis: changeAmount })); } else { this._changeIndex = undefined; } }; /** * Calculates the fee of the transaction. * * If there's a fixed fee set, return that. * * If there is no change output set, the fee is the * total value of the outputs minus inputs. Note that * a serialized transaction only specifies the value * of its outputs. (The value of inputs are recorded * in the previous transaction outputs being spent.) * This method therefore raises a "MissingPreviousOutput" * error when called on a serialized transaction. * * If there's no fee set and no change address, * estimate the fee based on size. * * @return {Number} fee of this transaction in satoshis */ Transaction.prototype.getFee = function() { if (this.isCoinbase()) { return 0; } if (!_.isUndefined(this._fee)) { return this._fee; } // if no change output is set, fees should equal all the unspent amount if (!this._changeScript) { return this._getUnspentValue(); } return this._estimateFee(); }; /** * Estimates fee from serialized transaction size in bytes. */ Transaction.prototype._estimateFee = function() { var estimatedSize = this._estimateSize(); var available = this._getUnspentValue(); return Transaction._estimateFee(estimatedSize, available, this._feePerKb); }; Transaction.prototype._getUnspentValue = function() { return this._getInputAmount() - this._getOutputAmount(); }; Transaction.prototype._clearSignatures = function() { _.each(this.inputs, function(input) { input.clearSignatures(); }); }; Transaction._estimateFee = function(size, amountAvailable, feePerKb) { var fee = Math.ceil(size / 1000) * (feePerKb || Transaction.FEE_PER_KB); if (amountAvailable > fee) { size += Transaction.CHANGE_OUTPUT_MAX_SIZE; } return Math.ceil(size / 1000) * (feePerKb || Transaction.FEE_PER_KB); }; Transaction.prototype._estimateSize = function() { var result = Transaction.MAXIMUM_EXTRA_SIZE; _.each(this.inputs, function(input) { result += input._estimateSize(); }); _.each(this.outputs, function(output) { result += output.script.toBuffer().length + 9; }); return result; }; Transaction.prototype._removeOutput = function(index) { var output = this.outputs[index]; this.outputs = _.without(this.outputs, output); this._outputAmount = undefined; }; Transaction.prototype.removeOutput = function(index) { this._removeOutput(index); this._updateChangeOutput(); }; /** * Sort a transaction's inputs and outputs according to BIP69 * * @see {https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki} * @return {Transaction} this */ Transaction.prototype.sort = function() { this.sortInputs(function(inputs) { var copy = Array.prototype.concat.apply([], inputs); copy.sort(function(first, second) { return compare(first.prevTxId, second.prevTxId) || first.outputIndex - second.outputIndex; }); return copy; }); this.sortOutputs(function(outputs) { var copy = Array.prototype.concat.apply([], outputs); copy.sort(function(first, second) { return first.satoshis - second.satoshis || compare(first.script.toBuffer(), second.script.toBuffer()); }); return copy; }); return this; }; /** * Randomize this transaction's outputs ordering. The shuffling algorithm is a * version of the Fisher-Yates shuffle, provided by lodash's _.shuffle(). * * @return {Transaction} this */ Transaction.prototype.shuffleOutputs = function() { return this.sortOutputs(_.shuffle); }; /** * Sort this transaction's outputs, according to a given sorting function that * takes an array as argument and returns a new array, with the same elements * but with a different order. The argument function MUST NOT modify the order * of the original array * * @param {Function} sortingFunction * @return {Transaction} this */ Transaction.prototype.sortOutputs = function(sortingFunction) { var outs = sortingFunction(this.outputs); return this._newOutputOrder(outs); }; /** * Sort this transaction's inputs, according to a given sorting function that * takes an array as argument and returns a new array, with the same elements * but with a different order. * * @param {Function} sortingFunction * @return {Transaction} this */ Transaction.prototype.sortInputs = function(sortingFunction) { this.inputs = sortingFunction(this.inputs); this._clearSignatures(); return this; }; Transaction.prototype._newOutputOrder = function(newOutputs) { var isInvalidSorting = (this.outputs.length !== newOutputs.length || _.difference(this.outputs, newOutputs).length !== 0); if (isInvalidSorting) { throw new errors.Transaction.InvalidSorting(); } if (!_.isUndefined(this._changeIndex)) { var changeOutput = this.outputs[this._changeIndex]; this._changeIndex = _.findIndex(newOutputs, changeOutput); } this.outputs = newOutputs; return this; }; Transaction.prototype.removeInput = function(txId, outputIndex) { var index; if (!outputIndex && _.isNumber(txId)) { index = txId; } else { index = _.findIndex(this.inputs, function(input) { return input.prevTxId.toString('hex') === txId && input.outputIndex === outputIndex; }); } if (index < 0 || index >= this.inputs.length) { throw new errors.Transaction.InvalidIndex(index, this.inputs.length); } var input = this.inputs[index]; this.inputs = _.without(this.inputs, input); this._inputAmount = undefined; this._updateChangeOutput(); }; /* Signature handling */ /** * Sign the transaction using one or more private keys. * * It tries to sign each input, verifying that the signature will be valid * (matches a public key). * * @param {Array|String|PrivateKey} privateKey * @param {number} sigtype * @return {Transaction} this, for chaining */ Transaction.prototype.sign = function(privateKey, sigtype) { $.checkState(this.hasAllUtxoInfo()); var self = this; if (_.isArray(privateKey)) { _.each(privateKey, function(privateKey) { self.sign(privateKey, sigtype); }); return this; } _.each(this.getSignatures(privateKey, sigtype), function(signature) { self.applySignature(signature); }); return this; }; Transaction.prototype.getSignatures = function(privKey, sigtype) { privKey = new PrivateKey(privKey); sigtype = sigtype || Signature.SIGHASH_ALL; var transaction = this; var results = []; var hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer()); _.each(this.inputs, function forEachInput(input, index) { _.each(input.getSignatures(transaction, privKey, index, sigtype, hashData), function(signature) { results.push(signature); }); }); return results; }; /** * Add a signature to the transaction * * @param {Object} signature * @param {number} signature.inputIndex * @param {number} signature.sigtype * @param {PublicKey} signature.publicKey * @param {Signature} signature.signature * @return {Transaction} this, for chaining */ Transaction.prototype.applySignature = function(signature) { this.inputs[signature.inputIndex].addSignature(this, signature); return this; }; Transaction.prototype.isFullySigned = function() { _.each(this.inputs, function(input) { if (input.isFullySigned === Input.prototype.isFullySigned) { throw new errors.Transaction.UnableToVerifySignature( 'Unrecognized script kind, or not enough information to execute script.' + 'This usually happens when creating a transaction from a serialized transaction' ); } }); return _.every(_.map(this.inputs, function(input) { return input.isFullySigned(); })); }; Transaction.prototype.isValidSignature = function(signature) { var self = this; if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) { throw new errors.Transaction.UnableToVerifySignature( 'Unrecognized script kind, or not enough information to execute script.' + 'This usually happens when creating a transaction from a serialized transaction' ); } return this.inputs[signature.inputIndex].isValidSignature(self, signature); }; /** * @returns {bool} whether the signature is valid for this transaction input */ Transaction.prototype.verifySignature = function(sig, pubkey, nin, subscript, sigversion) { if (_.isUndefined(sigversion)) { sigversion = 0; } if (sigversion == 1) { var subscriptBuffer = subscript.toBuffer(); var scriptCodeWriter = new BufferWriter(); scriptCodeWriter.writeVarintNum(subscriptBuffer.length); scriptCodeWriter.write(subscriptBuffer); return SighashWitness.verify(this, sig, pubkey, nin, scriptCodeWriter.toBuffer(), this.inputs[nin].getSatoshisBuffer()); } return Sighash.verify(this, sig, pubkey, nin, subscript); }; /** * Check that a transaction passes basic sanity tests. If not, return a string * describing the error. This function contains the same logic as * CheckTransaction in bitcoin core. */ Transaction.prototype.verify = function() { // Basic checks that don't depend on any context if (this.inputs.length === 0) { return 'transaction txins empty'; } if (this.outputs.length === 0) { return 'transaction txouts empty'; } // Check for negative or overflow output values var valueoutbn = new BN(0); for (var i = 0; i < this.outputs.length; i++) { var txout = this.outputs[i]; if (txout.invalidSatoshis()) { return 'transaction txout ' + i + ' satoshis is invalid'; } if (txout._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) { return 'transaction txout ' + i + ' greater than MAX_MONEY'; } valueoutbn = valueoutbn.add(txout._satoshisBN); if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) { return 'transaction txout ' + i + ' total output greater than MAX_MONEY'; } } // Size limits if (this.toBuffer().length > MAX_BLOCK_SIZE) { return 'transaction over the maximum block size'; } // Check for duplicate inputs var txinmap = {}; for (i = 0; i < this.inputs.length; i++) { var txin = this.inputs[i]; var inputid = txin.prevTxId + ':' + txin.outputIndex; if (!_.isUndefined(txinmap[inputid])) { return 'transaction input ' + i + ' duplicate input'; } txinmap[inputid] = true; } var isCoinbase = this.isCoinbase(); if (isCoinbase) { var buf = this.inputs[0]._scriptBuffer; if (buf.length < 2 || buf.length > 100) { return 'coinbase transaction script size invalid'; } } else { for (i = 0; i < this.inputs.length; i++) { if (this.inputs[i].isNull()) { return 'transaction input ' + i + ' has null input'; } } } return true; }; /** * Analogous to bitcoind's IsCoinBase function in transaction.h */ Transaction.prototype.isCoinbase = function() { return (this.inputs.length === 1 && this.inputs[0].isNull()); }; /** * Determines if this transaction can be replaced in the mempool with another * transaction that provides a sufficiently higher fee (RBF). */ Transaction.prototype.isRBF = function() { for (var i = 0; i < this.inputs.length; i++) { var input = this.inputs[i]; if (input.sequenceNumber < Input.MAXINT - 1) { return true; } } return false; }; /** * Enable this transaction to be replaced in the mempool (RBF) if a transaction * includes a sufficiently higher fee. It will set the sequenceNumber to * DEFAULT_RBF_SEQNUMBER for all inputs if the sequence number does not * already enable RBF. */ Transaction.prototype.enableRBF = function() { for (var i = 0; i < this.inputs.length; i++) { var input = this.inputs[i]; if (input.sequenceNumber >= Input.MAXINT - 1) { input.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER; } } return this; }; module.exports = Transaction; }).call(this,require("buffer").Buffer) },{"../address":99,"../crypto/bn":104,"../crypto/hash":106,"../crypto/signature":109,"../encoding/bufferreader":112,"../encoding/bufferwriter":113,"../errors":115,"../privatekey":121,"../script":123,"../util/buffer":141,"../util/js":142,"../util/preconditions":143,"./input":127,"./output":133,"./sighash":134,"./sighashwitness":135,"./unspentoutput":138,"buffer":75,"buffer-compare":73,"lodash":146}],138:[function(require,module,exports){ 'use strict'; var _ = require('lodash'); var $ = require('../util/preconditions'); var JSUtil = require('../util/js'); var Script = require('../script'); var Address = require('../address'); var Unit = require('../unit'); /** * Represents an unspent output information: its script, associated amount and address, * transaction id and output index. * * @constructor * @param {object} data * @param {string} data.txid the previous transaction id * @param {string=} data.txId alias for `txid` * @param {number} data.vout the index in the transaction * @param {number=} data.outputIndex alias for `vout` * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds * @param {string|Script=} data.script alias for `scriptPubKey` * @param {number} data.amount amount of bitcoins associated * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis (1 DGB = 1e8 satoshis) * @param {string|Address=} data.address the associated address to the script, if provided */ function UnspentOutput(data) { /* jshint maxcomplexity: 20 */ /* jshint maxstatements: 20 */ if (!(this instanceof UnspentOutput)) { return new UnspentOutput(data); } $.checkArgument(_.isObject(data), 'Must provide an object from where to extract data'); var address = data.address ? new Address(data.address) : undefined; var txId = data.txid ? data.txid : data.txId; if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) { // TODO: Use the errors library throw new Error('Invalid TXID in object', data); } var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout; if (!_.isNumber(outputIndex)) { throw new Error('Invalid outputIndex, received ' + outputIndex); } $.checkArgument(!_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script), 'Must provide the scriptPubKey for that output!'); var script = new Script(data.scriptPubKey || data.script); $.checkArgument(!_.isUndefined(data.amount) || !_.isUndefined(data.satoshis), 'Must provide an amount for the output'); var amount = !_.isUndefined(data.amount) ? new Unit.fromDGB(data.amount).toSatoshis() : data.satoshis; $.checkArgument(_.isNumber(amount), 'Amount must be a number'); JSUtil.defineImmutable(this, { address: address, txId: txId, outputIndex: outputIndex, script: script, satoshis: amount }); } /** * Provide an informative output when displaying this object in the console * @returns string */ UnspentOutput.prototype.inspect = function() { return '<UnspentOutput: ' + this.txId + ':' + this.outputIndex + ', satoshis: ' + this.satoshis + ', address: ' + this.address + '>'; }; /** * String representation: just "txid:index" * @returns string */ UnspentOutput.prototype.toString = function() { return this.txId + ':' + this.outputIndex; }; /** * Deserialize an UnspentOutput from an object * @param {object|string} data * @return UnspentOutput */ UnspentOutput.fromObject = function(data) { return new UnspentOutput(data); }; /** * Returns a plain object (no prototype or methods) with the associated info for this output * @return {object} */ UnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject() { return { address: this.address ? this.address.toString() : undefined, txid: this.txId, vout: this.outputIndex, scriptPubKey: this.script.toBuffer().toString('hex'), amount: Unit.fromSatoshis(this.satoshis).toDGB() }; }; module.exports = UnspentOutput; },{"../address":99,"../script":123,"../unit":139,"../util/js":142,"../util/preconditions":143,"lodash":146}],139:[function(require,module,exports){ 'use strict'; var _ = require('lodash'); var errors = require('./errors'); var $ = require('./util/preconditions'); var UNITS = { 'DGB' : [1e8, 8], 'mDGB' : [1e5, 5], 'uDGB' : [1e2, 2], 'bits' : [1e2, 2], 'satoshis' : [1, 0] }; /** * Utility for handling and converting bitcoins units. The supported units are * DGB, mDGB, bits (also named uDGB) and satoshis. A unit instance can be created with an * amount and a unit code, or alternatively using static methods like {fromDGB}. * It also allows to be created from a fiat amount and the exchange rate, or * alternatively using the {fromFiat} static method. * You can consult for different representation of a unit instance using it's * {to} method, the fixed unit methods like {toSatoshis} or alternatively using * the unit accessors. It also can be converted to a fiat amount by providing the * corresponding DGB/fiat exchange rate. * * @example * ```javascript * var sats = Unit.fromDGB(1.3).toSatoshis(); * var mili = Unit.fromBits(1.3).to(Unit.mDGB); * var bits = Unit.fromFiat(1.3, 350).bits; * var dgb = new Unit(1.3, Unit.bits).DGB; * ``` * * @param {Number} amount - The amount to be represented * @param {String|Number} code - The unit of the amount or the exchange rate * @returns {Unit} A new instance of an Unit * @constructor */ function Unit(amount, code) { if (!(this instanceof Unit)) { return new Unit(amount, code); } // convert fiat to DGB if (_.isNumber(code)) { if (code <= 0) { throw new errors.Unit.InvalidRate(code); } amount = amount / code; code = Unit.DGB; } this._value = this._from(amount, code); var self = this; var defineAccesor = function(key) { Object.defineProperty(self, key, { get: function() { return self.to(key); }, enumerable: true, }); }; Object.keys(UNITS).forEach(defineAccesor); } Object.keys(UNITS).forEach(function(key) { Unit[key] = key; }); /** * Returns a Unit instance created from JSON string or object * * @param {String|Object} json - JSON with keys: amount and code * @returns {Unit} A Unit instance */ Unit.fromObject = function fromObject(data){ $.checkArgument(_.isObject(data), 'Argument is expected to be an object'); return new Unit(data.amount, data.code); }; /** * Returns a Unit instance created from an amount in DGB * * @param {Number} amount - The amount in DGB * @returns {Unit} A Unit instance */ Unit.fromDGB = function(amount) { return new Unit(amount, Unit.DGB); }; /** * Returns a Unit instance created from an amount in mDGB * * @param {Number} amount - The amount in mDGB * @returns {Unit} A Unit instance */ Unit.fromMillis = Unit.fromMilis = function(amount) { return new Unit(amount, Unit.mDGB); }; /** * Returns a Unit instance created from an amount in bits * * @param {Number} amount - The amount in bits * @returns {Unit} A Unit instance */ Unit.fromMicros = Unit.fromBits = function(amount) { return new Unit(amount, Unit.bits); }; /** * Returns a Unit instance created from an amount in satoshis * * @param {Number} amount - The amount in satoshis * @returns {Unit} A Unit instance */ Unit.fromSatoshis = function(amount) { return new Unit(amount, Unit.satoshis); }; /** * Returns a Unit instance created from a fiat amount and exchange rate. * * @param {Number} amount - The amount in fiat * @param {Number} rate - The exchange rate DGB/fiat * @returns {Unit} A Unit instance */ Unit.fromFiat = function(amount, rate) { return new Unit(amount, rate); }; Unit.prototype._from = function(amount, code) { if (!UNITS[code]) { throw new errors.Unit.UnknownCode(code); } return parseInt((amount * UNITS[code][0]).toFixed()); }; /** * Returns the value represented in the specified unit * * @param {String|Number} code - The unit code or exchange rate * @returns {Number} The converted value */ Unit.prototype.to = function(code) { if (_.isNumber(code)) { if (code <= 0) { throw new errors.Unit.InvalidRate(code); } return parseFloat((this.DGB * code).toFixed(2)); } if (!UNITS[code]) { throw new errors.Unit.UnknownCode(code); } var value = this._value / UNITS[code][0]; return parseFloat(value.toFixed(UNITS[code][1])); }; /** * Returns the value represented in DGB * * @returns {Number} The value converted to DGB */ Unit.prototype.toDGB = function() { return this.to(Unit.DGB); }; /** * Returns the value represented in mDGB * * @returns {Number} The value converted to mDGB */ Unit.prototype.toMillis = Unit.prototype.toMilis = function() { return this.to(Unit.mDGB); }; /** * Returns the value represented in bits * * @returns {Number} The value converted to bits */ Unit.prototype.toMicros = Unit.prototype.toBits = function() { return this.to(Unit.bits); }; /** * Returns the value represented in satoshis * * @returns {Number} The value converted to satoshis */ Unit.prototype.toSatoshis = function() { return this.to(Unit.satoshis); }; /** * Returns the value represented in fiat * * @param {string} rate - The exchange rate between DGB/currency * @returns {Number} The value converted to satoshis */ Unit.prototype.atRate = function(rate) { return this.to(rate); }; /** * Returns a the string representation of the value in satoshis * * @returns {string} the value in satoshis */ Unit.prototype.toString = function() { return this.satoshis + ' satoshis'; }; /** * Returns a plain object representation of the Unit * * @returns {Object} An object with the keys: amount and code */ Unit.prototype.toObject = Unit.prototype.toJSON = function toObject() { return { amount: this.DGB, code: Unit.DGB }; }; /** * Returns a string formatted for the console * * @returns {string} the value in satoshis */ Unit.prototype.inspect = function() { return '<Unit: ' + this.toString() + '>'; }; module.exports = Unit; },{"./errors":115,"./util/preconditions":143,"lodash":146}],140:[function(require,module,exports){ 'use strict'; var _ = require('lodash'); var URL = require('url'); var Address = require('./address'); var Unit = require('./unit'); /** * Bitcore URI * * Instantiate an URI from a bitcoin URI String or an Object. An URI instance * can be created with a bitcoin uri string or an object. All instances of * URI are valid, the static method isValid allows checking before instantiation. * * All standard parameters can be found as members of the class, the address * is represented using an {Address} instance and the amount is represented in * satoshis. Any other non-standard parameters can be found under the extra member. * * @example * ```javascript * * var uri = new URI('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2'); * console.log(uri.address, uri.amount); * ``` * * @param {string|Object} data - A bitcoin URI string or an Object * @param {Array.<string>=} knownParams - Required non-standard params * @throws {TypeError} Invalid bitcoin address * @throws {TypeError} Invalid amount * @throws {Error} Unknown required argument * @returns {URI} A new valid and frozen instance of URI * @constructor */ var URI = function(data, knownParams) { if (!(this instanceof URI)) { return new URI(data, knownParams); } this.extras = {}; this.knownParams = knownParams || []; this.address = this.network = this.amount = this.message = null; if (typeof(data) === 'string') { var params = URI.parse(data); if (params.amount) { params.amount = this._parseAmount(params.amount); } this._fromObject(params); } else if (typeof(data) === 'object') { this._fromObject(data); } else { throw new TypeError('Unrecognized data format.'); } }; /** * Instantiate a URI from a String * * @param {string} str - JSON string or object of the URI * @returns {URI} A new instance of a URI */ URI.fromString = function fromString(str) { if (typeof(str) !== 'string') { throw new TypeError('Expected a string'); } return new URI(str); }; /** * Instantiate a URI from an Object * * @param {Object} data - object of the URI * @returns {URI} A new instance of a URI */ URI.fromObject = function fromObject(json) { return new URI(json); }; /** * Check if an bitcoin URI string is valid * * @example * ```javascript * * var valid = URI.isValid('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu'); * // true * ``` * * @param {string|Object} data - A bitcoin URI string or an Object * @param {Array.<string>=} knownParams - Required non-standard params * @returns {boolean} Result of uri validation */ URI.isValid = function(arg, knownParams) { try { new URI(arg, knownParams); } catch (err) { return false; } return true; }; /** * Convert a bitcoin URI string into a simple object. * * @param {string} uri - A bitcoin URI string * @throws {TypeError} Invalid bitcoin URI * @returns {Object} An object with the parsed params */ URI.parse = function(uri) { var info = URL.parse(uri, true); if (info.protocol !== 'digibyte:') { throw new TypeError('Invalid bitcoin URI'); } // workaround to host insensitiveness var group = /[^:]*:\/?\/?([^?]*)/.exec(uri); info.query.address = group && group[1] || undefined; return info.query; }; URI.Members = ['address', 'amount', 'message', 'label', 'r']; /** * Internal function to load the URI instance with an object. * * @param {Object} obj - Object with the information * @throws {TypeError} Invalid bitcoin address * @throws {TypeError} Invalid amount * @throws {Error} Unknown required argument */ URI.prototype._fromObject = function(obj) { /* jshint maxcomplexity: 10 */ if (!Address.isValid(obj.address)) { throw new TypeError('Invalid bitcoin address'); } this.address = new Address(obj.address); this.network = this.address.network; this.amount = obj.amount; for (var key in obj) { if (key === 'address' || key === 'amount') { continue; } if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) { throw Error('Unknown required argument ' + key); } var destination = URI.Members.indexOf(key) > -1 ? this : this.extras; destination[key] = obj[key]; } }; /** * Internal function to transform a DGB string amount into satoshis * * @param {string} amount - Amount DGB string * @throws {TypeError} Invalid amount * @returns {Object} Amount represented in satoshis */ URI.prototype._parseAmount = function(amount) { amount = Number(amount); if (isNaN(amount)) { throw new TypeError('Invalid amount'); } return Unit.fromDGB(amount).toSatoshis(); }; URI.prototype.toObject = URI.prototype.toJSON = function toObject() { var json = {}; for (var i = 0; i < URI.Members.length; i++) { var m = URI.Members[i]; if (this.hasOwnProperty(m) && typeof(this[m]) !== 'undefined') { json[m] = this[m].toString(); } } _.extend(json, this.extras); return json; }; /** * Will return a the string representation of the URI * * @returns {string} Bitcoin URI string */ URI.prototype.toString = function() { var query = {}; if (this.amount) { query.amount = Unit.fromSatoshis(this.amount).toDGB(); } if (this.message) { query.message = this.message; } if (this.label) { query.label = this.label; } if (this.r) { query.r = this.r; } _.extend(query, this.extras); return URL.format({ protocol: 'digibyte:', host: this.address, query: query }); }; /** * Will return a string formatted for the console * * @returns {string} Bitcoin URI */ URI.prototype.inspect = function() { return '<URI: ' + this.toString() + '>'; }; module.exports = URI; },{"./address":99,"./unit":139,"lodash":146,"url":288}],141:[function(require,module,exports){ (function (Buffer){ 'use strict'; var buffer = require('buffer'); var assert = require('assert'); var js = require('./js'); var $ = require('./preconditions'); function equals(a, b) { if (a.length !== b.length) { return false; } var length = a.length; for (var i = 0; i < length; i++) { if (a[i] !== b[i]) { return false; } } return true; } module.exports = { /** * Fill a buffer with a value. * * @param {Buffer} buffer * @param {number} value * @return {Buffer} */ fill: function fill(buffer, value) { $.checkArgumentType(buffer, 'Buffer', 'buffer'); $.checkArgumentType(value, 'number', 'value'); var length = buffer.length; for (var i = 0; i < length; i++) { buffer[i] = value; } return buffer; }, /** * Return a copy of a buffer * * @param {Buffer} original * @return {Buffer} */ copy: function(original) { var buffer = new Buffer(original.length); original.copy(buffer); return buffer; }, /** * Returns true if the given argument is an instance of a buffer. Tests for * both node's Buffer and Uint8Array * * @param {*} arg * @return {boolean} */ isBuffer: function isBuffer(arg) { return buffer.Buffer.isBuffer(arg) || arg instanceof Uint8Array; }, /** * Returns a zero-filled byte array * * @param {number} bytes * @return {Buffer} */ emptyBuffer: function emptyBuffer(bytes) { $.checkArgumentType(bytes, 'number', 'bytes'); var result = new buffer.Buffer(bytes); for (var i = 0; i < bytes; i++) { result.write('\0', i); } return result; }, /** * Concatenates a buffer * * Shortcut for <tt>buffer.Buffer.concat</tt> */ concat: buffer.Buffer.concat, equals: equals, equal: equals, /** * Transforms a number from 0 to 255 into a Buffer of size 1 with that value * * @param {number} integer * @return {Buffer} */ integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) { $.checkArgumentType(integer, 'number', 'integer'); return new buffer.Buffer([integer & 0xff]); }, /** * Transform a 4-byte integer into a Buffer of length 4. * * @param {number} integer * @return {Buffer} */ integerAsBuffer: function integerAsBuffer(integer) { $.checkArgumentType(integer, 'number', 'integer'); var bytes = []; bytes.push((integer >> 24) & 0xff); bytes.push((integer >> 16) & 0xff); bytes.push((integer >> 8) & 0xff); bytes.push(integer & 0xff); return new Buffer(bytes); }, /** * Transform the first 4 values of a Buffer into a number, in little endian encoding * * @param {Buffer} buffer * @return {number} */ integerFromBuffer: function integerFromBuffer(buffer) { $.checkArgumentType(buffer, 'Buffer', 'buffer'); return buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3]; }, /** * Transforms the first byte of an array into a number ranging from -128 to 127 * @param {Buffer} buffer * @return {number} */ integerFromSingleByteBuffer: function integerFromBuffer(buffer) { $.checkArgumentType(buffer, 'Buffer', 'buffer'); return buffer[0]; }, /** * Transforms a buffer into a string with a number in hexa representation * * Shorthand for <tt>buffer.toString('hex')</tt> * * @param {Buffer} buffer * @return {string} */ bufferToHex: function bufferToHex(buffer) { $.checkArgumentType(buffer, 'Buffer', 'buffer'); return buffer.toString('hex'); }, /** * Reverse a buffer * @param {Buffer} param * @return {Buffer} */ reverse: function reverse(param) { var ret = new buffer.Buffer(param.length); for (var i = 0; i < param.length; i++) { ret[i] = param[param.length - i - 1]; } return ret; }, /** * Transforms an hexa encoded string into a Buffer with binary values * * Shorthand for <tt>Buffer(string, 'hex')</tt> * * @param {string} string * @return {Buffer} */ hexToBuffer: function hexToBuffer(string) { assert(js.isHexa(string)); return new buffer.Buffer(string, 'hex'); } }; module.exports.NULL_HASH = module.exports.fill(new Buffer(32), 0); module.exports.EMPTY_BUFFER = new Buffer(0); }).call(this,require("buffer").Buffer) },{"./js":142,"./preconditions":143,"assert":29,"buffer":75}],142:[function(require,module,exports){ 'use strict'; var _ = require('lodash'); /** * Determines whether a string contains only hexadecimal values * * @name JSUtil.isHexa * @param {string} value * @return {boolean} true if the string is the hexa representation of a number */ var isHexa = function isHexa(value) { if (!_.isString(value)) { return false; } return /^[0-9a-fA-F]+$/.test(value); }; /** * @namespace JSUtil */ module.exports = { /** * Test if an argument is a valid JSON object. If it is, returns a truthy * value (the json object decoded), so no double JSON.parse call is necessary * * @param {string} arg * @return {Object|boolean} false if the argument is not a JSON string. */ isValidJSON: function isValidJSON(arg) { var parsed; if (!_.isString(arg)) { return false; } try { parsed = JSON.parse(arg); } catch (e) { return false; } if (typeof(parsed) === 'object') { return true; } return false; }, isHexa: isHexa, isHexaString: isHexa, /** * Clone an array */ cloneArray: function(array) { return [].concat(array); }, /** * Define immutable properties on a target object * * @param {Object} target - An object to be extended * @param {Object} values - An object of properties * @return {Object} The target object */ defineImmutable: function defineImmutable(target, values) { Object.keys(values).forEach(function(key){ Object.defineProperty(target, key, { configurable: false, enumerable: true, value: values[key] }); }); return target; }, /** * Checks that a value is a natural number, a positive integer or zero. * * @param {*} value * @return {Boolean} */ isNaturalNumber: function isNaturalNumber(value) { return typeof value === 'number' && isFinite(value) && Math.floor(value) === value && value >= 0; } }; },{"lodash":146}],143:[function(require,module,exports){ 'use strict'; var errors = require('../errors'); var _ = require('lodash'); module.exports = { checkState: function(condition, message) { if (!condition) { throw new errors.InvalidState(message); } }, checkArgument: function(condition, argumentName, message, docsPath) { if (!condition) { throw new errors.InvalidArgument(argumentName, message, docsPath); } }, checkArgumentType: function(argument, type, argumentName) { argumentName = argumentName || '(unknown name)'; if (_.isString(type)) { if (type === 'Buffer') { var buffer = require('buffer'); // './buffer' fails on cordova & RN if (!buffer.Buffer.isBuffer(argument)) { throw new errors.InvalidArgumentType(argument, type, argumentName); } } else if (typeof argument !== type) { throw new errors.InvalidArgumentType(argument, type, argumentName); } } else { if (!(argument instanceof type)) { throw new errors.InvalidArgumentType(argument, type.name, argumentName); } } } }; },{"../errors":115,"buffer":75,"lodash":146}],144:[function(require,module,exports){ var basex = require('base-x') var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz' module.exports = basex(ALPHABET) },{"base-x":34}],145:[function(require,module,exports){ arguments[4][30][0].apply(exports,arguments) },{"dup":30}],146:[function(require,module,exports){ (function (global){ /** * @license * Lodash <https://lodash.com/> * Copyright JS Foundation and other contributors <https://js.foundation/> * Released under MIT license <https://lodash.com/license> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors */ ;(function() { /** Used as a safe reference for `undefined` in pre-ES5 environments. */ var undefined; /** Used as the semantic version number. */ var VERSION = '4.17.4'; /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200; /** Error message constants. */ var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.', FUNC_ERROR_TEXT = 'Expected a function'; /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__'; /** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500; /** Used as the internal argument placeholder. */ var PLACEHOLDER = '__lodash_placeholder__'; /** Used to compose bitmasks for cloning. */ var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4; /** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2; /** Used to compose bitmasks for function metadata. */ var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512; /** Used as default options for `_.truncate`. */ var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...'; /** Used to detect hot functions by number of calls within a span of milliseconds. */ var HOT_COUNT = 800, HOT_SPAN = 16; /** Used to indicate the type of lazy iteratees. */ var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3; /** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0; /** Used as references for the maximum length and index of an array. */ var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1; /** Used to associate wrap methods with their bit flags. */ var wrapFlags = [ ['ary', WRAP_ARY_FLAG], ['bind', WRAP_BIND_FLAG], ['bindKey', WRAP_BIND_KEY_FLAG], ['curry', WRAP_CURRY_FLAG], ['curryRight', WRAP_CURRY_RIGHT_FLAG], ['flip', WRAP_FLIP_FLAG], ['partial', WRAP_PARTIAL_FLAG], ['partialRight', WRAP_PARTIAL_RIGHT_FLAG], ['rearg', WRAP_REARG_FLAG] ]; /** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', domExcTag = '[object DOMException]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', promiseTag = '[object Promise]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]', weakSetTag = '[object WeakSet]'; var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]'; /** Used to match empty string literals in compiled template source. */ var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g; /** Used to match HTML entities and HTML characters. */ var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source); /** Used to match template delimiters. */ var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g; /** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g; /** * Used to match `RegExp` * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns). */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source); /** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/; /** Used to match wrap detail comments. */ var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /; /** Used to match words composed of alphanumeric characters. */ var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g; /** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g; /** * Used to match * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components). */ var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g; /** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/; /** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i; /** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i; /** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/; /** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i; /** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/; /** Used to match Latin Unicode letters (excluding mathematical operators). */ var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g; /** Used to ensure capturing order of template delimiters. */ var reNoMatch = /($^)/; /** Used to match unescaped characters in compiled string literals. */ var reUnescapedString = /['\n\r\u2028\u2029\\]/g; /** Used to compose unicode character classes. */ var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsPunctuationRange = '\\u2000-\\u206f', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange; /** Used to compose unicode capture groups. */ var rsApos = "['\u2019]", rsAstral = '[' + rsAstralRange + ']', rsBreak = '[' + rsBreakRange + ']', rsCombo = '[' + rsComboRange + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ = '\\u200d'; /** Used to compose unicode regexes. */ var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')', rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*', rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)', rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq, rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')'; /** Used to match apostrophes. */ var reApos = RegExp(rsApos, 'g'); /** * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols). */ var reComboMark = RegExp(rsCombo, 'g'); /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */ var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g'); /** Used to match complex or compound words. */ var reUnicodeWord = RegExp([ rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji ].join('|'), 'g'); /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */ var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']'); /** Used to detect strings that need a more robust regexp to match words. */ var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/; /** Used to assign default `context` object properties. */ var contextProps = [ 'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object', 'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout' ]; /** Used to make template sourceURLs easier to identify. */ var templateCounter = -1; /** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {}; typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true; typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false; /** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {}; cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true; cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false; /** Used to map Latin Unicode letters to basic Latin letters. */ var deburredLetters = { // Latin-1 Supplement block. '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A', '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a', '\xc7': 'C', '\xe7': 'c', '\xd0': 'D', '\xf0': 'd', '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E', '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e', '\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I', '\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i', '\xd1': 'N', '\xf1': 'n', '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O', '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o', '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U', '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u', '\xdd': 'Y', '\xfd': 'y', '\xff': 'y', '\xc6': 'Ae', '\xe6': 'ae', '\xde': 'Th', '\xfe': 'th', '\xdf': 'ss', // Latin Extended-A block. '\u0100': 'A', '\u0102': 'A', '\u0104': 'A', '\u0101': 'a', '\u0103': 'a', '\u0105': 'a', '\u0106': 'C', '\u0108': 'C', '\u010a': 'C', '\u010c': 'C', '\u0107': 'c', '\u0109': 'c', '\u010b': 'c', '\u010d': 'c', '\u010e': 'D', '\u0110': 'D', '\u010f': 'd', '\u0111': 'd', '\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E', '\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e', '\u011c': 'G', '\u011e': 'G', '\u0120': 'G', '\u0122': 'G', '\u011d': 'g', '\u011f': 'g', '\u0121': 'g', '\u0123': 'g', '\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h', '\u0128': 'I', '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I', '\u0129': 'i', '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i', '\u0134': 'J', '\u0135': 'j', '\u0136': 'K', '\u0137': 'k', '\u0138': 'k', '\u0139': 'L', '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L', '\u013a': 'l', '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l', '\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014a': 'N', '\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014b': 'n', '\u014c': 'O', '\u014e': 'O', '\u0150': 'O', '\u014d': 'o', '\u014f': 'o', '\u0151': 'o', '\u0154': 'R', '\u0156': 'R', '\u0158': 'R', '\u0155': 'r', '\u0157': 'r', '\u0159': 'r', '\u015a': 'S', '\u015c': 'S', '\u015e': 'S', '\u0160': 'S', '\u015b': 's', '\u015d': 's', '\u015f': 's', '\u0161': 's', '\u0162': 'T', '\u0164': 'T', '\u0166': 'T', '\u0163': 't', '\u0165': 't', '\u0167': 't', '\u0168': 'U', '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U', '\u0169': 'u', '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u', '\u0174': 'W', '\u0175': 'w', '\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y', '\u0179': 'Z', '\u017b': 'Z', '\u017d': 'Z', '\u017a': 'z', '\u017c': 'z', '\u017e': 'z', '\u0132': 'IJ', '\u0133': 'ij', '\u0152': 'Oe', '\u0153': 'oe', '\u0149': "'n", '\u017f': 's' }; /** Used to map characters to HTML entities. */ var htmlEscapes = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }; /** Used to map HTML entities to characters. */ var htmlUnescapes = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', '&#39;': "'" }; /** Used to escape characters for inclusion in compiled string literals. */ var stringEscapes = { '\\': '\\', "'": "'", '\n': 'n', '\r': 'r', '\u2028': 'u2028', '\u2029': 'u2029' }; /** Built-in method references without a dependency on `root`. */ var freeParseFloat = parseFloat, freeParseInt = parseInt; /** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global; /** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self; /** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')(); /** Detect free variable `exports`. */ var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports; /** Detect free variable `module`. */ var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module; /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports; /** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process; /** Used to access faster Node.js helpers. */ var nodeUtil = (function() { try { return freeProcess && freeProcess.binding && freeProcess.binding('util'); } catch (e) {} }()); /* Node.js helper references. */ var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray; /*--------------------------------------------------------------------------*/ /** * Adds the key-value `pair` to `map`. * * @private * @param {Object} map The map to modify. * @param {Array} pair The key-value pair to add. * @returns {Object} Returns `map`. */ function addMapEntry(map, pair) { // Don't return `map.set` because it's not chainable in IE 11. map.set(pair[0], pair[1]); return map; } /** * Adds `value` to `set`. * * @private * @param {Object} set The set to modify. * @param {*} value The value to add. * @returns {Object} Returns `set`. */ function addSetEntry(set, value) { // Don't return `set.add` because it's not chainable in IE 11. set.add(value); return set; } /** * A faster alternative to `Function#apply`, this function invokes `func` * with the `this` binding of `thisArg` and the arguments of `args`. * * @private * @param {Function} func The function to invoke. * @param {*} thisArg The `this` binding of `func`. * @param {Array} args The arguments to invoke `func` with. * @returns {*} Returns the result of `func`. */ function apply(func, thisArg, args) { switch (args.length) { case 0: return func.call(thisArg); case 1: return func.call(thisArg, args[0]); case 2: return func.call(thisArg, args[0], args[1]); case 3: return func.call(thisArg, args[0], args[1], args[2]); } return func.apply(thisArg, args); } /** * A specialized version of `baseAggregator` for arrays. * * @private * @param {Array} [array] The array to iterate over. * @param {Function} setter The function to set `accumulator` values. * @param {Function} iteratee The iteratee to transform keys. * @param {Object} accumulator The initial aggregated object. * @returns {Function} Returns `accumulator`. */ function arrayAggregator(array, setter, iteratee, accumulator) { var index = -1, length = array == null ? 0 : array.length; while (++index < length) { var value = array[index]; setter(accumulator, value, iteratee(value), array); } return accumulator; } /** * A specialized version of `_.forEach` for arrays without support for * iteratee shorthands. * * @private * @param {Array} [array] The array to iterate over. * @param {Function} iteratee The function invoked per iteration. * @returns {Array} Returns `array`. */ function arrayEach(array, iteratee) { var index = -1, length = array == null ? 0 : array.length; while (++index < length) { if (iteratee(array[index], index, array) === false) { break; } } return array; } /** * A specialized version of `_.forEachRight` for arrays without support for * iteratee shorthands. * * @private * @param {Array} [array] The array to iterate over. * @param {Function} iteratee The function invoked per iteration. * @returns {Array} Returns `array`. */ function arrayEachRight(array, iteratee) { var length = array == null ? 0 : array.length; while (length--) { if (iteratee(array[length], length, array) === false) { break; } } return array; } /** * A specialized version of `_.every` for arrays without support for * iteratee shorthands. * * @private * @param {Array} [array] The array to iterate over. * @param {Function} predicate The function invoked per iteration. * @returns {boolean} Returns `true` if all elements pass the predicate check, * else `false`. */ function arrayEvery(array, predicate) { var index = -1, length = array == null ? 0 : array.length; while (++index < length) { if (!predicate(array[index], index, array)) { return false; } } return true; } /** * A specialized version of `_.filter` for arrays without support for * iteratee shorthands. * * @private * @param {Array} [array] The array to iterate over. * @param {Function} predicate The function invoked per iteration. * @returns {Array} Returns the new filtered array. */ function arrayFilter(array, predicate) { var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = []; while (++index < length) { var value = array[index]; if (predicate(value, index, array)) { result[resIndex++] = value; } } return result; } /** * A specialized version of `_.includes` for arrays without support for * specifying an index to search from. * * @private * @param {Array} [array] The array to inspect. * @param {*} target The value to search for. * @returns {boolean} Returns `true` if `target` is found, else `false`. */ function arrayIncludes(array, value) { var length = array == null ? 0 : array.length; return !!length && baseIndexOf(array, value, 0) > -1; } /** * This function is like `arrayIncludes` except that it accepts a comparator. * * @private * @param {Array} [array] The array to inspect. * @param {*} target The value to search for. * @param {Function} comparator The comparator invoked per element. * @returns {boolean} Returns `true` if `target` is found, else `false`. */ function arrayIncludesWith(array, value, comparator) { var index = -1, length = array == null ? 0 : array.length; while (++index < length) { if (comparator(value, array[index])) { return true; } } return false; } /** * A specialized version of `_.map` for arrays without support for iteratee * shorthands. * * @private * @param {Array} [array] The array to iterate over. * @param {Function} iteratee The function invoked per iteration. * @returns {Array} Returns the new mapped array. */ function arrayMap(array, iteratee) { var index = -1, length = array == null ? 0 : array.length, result = Array(length); while (++index < length) { result[index] = iteratee(array[index], index, array); } return result; } /** * Appends the elements of `values` to `array`. * * @private * @param {Array} array The array to modify. * @param {Array} values The values to append. * @returns {Array} Returns `array`. */ function arrayPush(array, values) { var index = -1, length = values.length, offset = array.length; while (++index < length) { array[offset + index] = values[index]; } return array; } /** * A specialized version of `_.reduce` for arrays without support for * iteratee shorthands. * * @private * @param {Array} [array] The array to iterate over. * @param {Function} iteratee The function invoked per iteration. * @param {*} [accumulator] The initial value. * @param {boolean} [initAccum] Specify using the first element of `array` as * the initial value. * @returns {*} Returns the accumulated value. */ function arrayReduce(array, iteratee, accumulator, initAccum) { var index = -1, length = array == null ? 0 : array.length; if (initAccum && length) { accumulator = array[++index]; } while (++index < length) { accumulator = iteratee(accumulator, array[index], index, array); } return accumulator; } /** * A specialized version of `_.reduceRight` for arrays without support for * iteratee shorthands. * * @private * @param {Array} [array] The array to iterate over. * @param {Function} iteratee The function invoked per iteration. * @param {*} [accumulator] The initial value. * @param {boolean} [initAccum] Specify using the last element of `array` as * the initial value. * @returns {*} Returns the accumulated value. */ function arrayReduceRight(array, iteratee, accumulator, initAccum) { var length = array == null ? 0 : array.length; if (initAccum && length) { accumulator = array[--length]; } while (length--) { accumulator = iteratee(accumulator, array[length], length, array); } return accumulator; } /** * A specialized version of `_.some` for arrays without support for iteratee * shorthands. * * @private * @param {Array} [array] The array to iterate over. * @param {Function} predicate The function invoked per iteration. * @returns {boolean} Returns `true` if any element passes the predicate check, * else `false`. */ function arraySome(array, predicate) { var index = -1, length = array == null ? 0 : array.length; while (++index < length) { if (predicate(array[index], index, array)) { return true; } } return false; } /** * Gets the size of an ASCII `string`. * * @private * @param {string} string The string inspect. * @returns {number} Returns the string size. */ var asciiSize = baseProperty('length'); /** * Converts an ASCII `string` to an array. * * @private * @param {string} string The string to convert. * @returns {Array} Returns the converted array. */ function asciiToArray(string) { return string.split(''); } /** * Splits an ASCII `string` into an array of its words. * * @private * @param {string} The string to inspect. * @returns {Array} Returns the words of `string`. */ function asciiWords(string) { return string.match(reAsciiWord) || []; } /** * The base implementation of methods like `_.findKey` and `_.findLastKey`, * without support for iteratee shorthands, which iterates over `collection` * using `eachFunc`. * * @private * @param {Array|Object} collection The collection to inspect. * @param {Function} predicate The function invoked per iteration. * @param {Function} eachFunc The function to iterate over `collection`. * @returns {*} Returns the found element or its key, else `undefined`. */ function baseFindKey(collection, predicate, eachFunc) { var result; eachFunc(collection, function(value, key, collection) { if (predicate(value, key, collection)) { result = key; return false; } }); return result; } /** * The base implementation of `_.findIndex` and `_.findLastIndex` without * support for iteratee shorthands. * * @private * @param {Array} array The array to inspect. * @param {Function} predicate The function invoked per iteration. * @param {number} fromIndex The index to search from. * @param {boolean} [fromRight] Specify iterating from right to left. * @returns {number} Returns the index of the matched value, else `-1`. */ function baseFindIndex(array, predicate, fromIndex, fromRight) { var length = array.length, index = fromIndex + (fromRight ? 1 : -1); while ((fromRight ? index-- : ++index < length)) { if (predicate(array[index], index, array)) { return index; } } return -1; } /** * The base implementation of `_.indexOf` without `fromIndex` bounds checks. * * @private * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @param {number} fromIndex The index to search from. * @returns {number} Returns the index of the matched value, else `-1`. */ function baseIndexOf(array, value, fromIndex) { return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex); } /** * This function is like `baseIndexOf` except that it accepts a comparator. * * @private * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @param {number} fromIndex The index to search from. * @param {Function} comparator The comparator invoked per element. * @returns {number} Returns the index of the matched value, else `-1`. */ function baseIndexOfWith(array, value, fromIndex, comparator) { var index = fromIndex - 1, length = array.length; while (++index < length) { if (comparator(array[index], value)) { return index; } } return -1; } /** * The base implementation of `_.isNaN` without support for number objects. * * @private * @param {*} value The value to check. * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`. */ function baseIsNaN(value) { return value !== value; } /** * The base implementation of `_.mean` and `_.meanBy` without support for * iteratee shorthands. * * @private * @param {Array} array The array to iterate over. * @param {Function} iteratee The function invoked per iteration. * @returns {number} Returns the mean. */ function baseMean(array, iteratee) { var length = array == null ? 0 : array.length; return length ? (baseSum(array, iteratee) / length) : NAN; } /** * The base implementation of `_.property` without support for deep paths. * * @private * @param {string} key The key of the property to get. * @returns {Function} Returns the new accessor function. */ function baseProperty(key) { return function(object) { return object == null ? undefined : object[key]; }; } /** * The base implementation of `_.propertyOf` without support for deep paths. * * @private * @param {Object} object The object to query. * @returns {Function} Returns the new accessor function. */ function basePropertyOf(object) { return function(key) { return object == null ? undefined : object[key]; }; } /** * The base implementation of `_.reduce` and `_.reduceRight`, without support * for iteratee shorthands, which iterates over `collection` using `eachFunc`. * * @private * @param {Array|Object} collection The collection to iterate over. * @param {Function} iteratee The function invoked per iteration. * @param {*} accumulator The initial value. * @param {boolean} initAccum Specify using the first or last element of * `collection` as the initial value. * @param {Function} eachFunc The function to iterate over `collection`. * @returns {*} Returns the accumulated value. */ function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) { eachFunc(collection, function(value, index, collection) { accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection); }); return accumulator; } /** * The base implementation of `_.sortBy` which uses `comparer` to define the * sort order of `array` and replaces criteria objects with their corresponding * values. * * @private * @param {Array} array The array to sort. * @param {Function} comparer The function to define sort order. * @returns {Array} Returns `array`. */ function baseSortBy(array, comparer) { var length = array.length; array.sort(comparer); while (length--) { array[length] = array[length].value; } return array; } /** * The base implementation of `_.sum` and `_.sumBy` without support for * iteratee shorthands. * * @private * @param {Array} array The array to iterate over. * @param {Function} iteratee The function invoked per iteration. * @returns {number} Returns the sum. */ function baseSum(array, iteratee) { var result, index = -1, length = array.length; while (++index < length) { var current = iteratee(array[index]); if (current !== undefined) { result = result === undefined ? current : (result + current); } } return result; } /** * The base implementation of `_.times` without support for iteratee shorthands * or max array length checks. * * @private * @param {number} n The number of times to invoke `iteratee`. * @param {Function} iteratee The function invoked per iteration. * @returns {Array} Returns the array of results. */ function baseTimes(n, iteratee) { var index = -1, result = Array(n); while (++index < n) { result[index] = iteratee(index); } return result; } /** * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array * of key-value pairs for `object` corresponding to the property names of `props`. * * @private * @param {Object} object The object to query. * @param {Array} props The property names to get values for. * @returns {Object} Returns the key-value pairs. */ function baseToPairs(object, props) { return arrayMap(props, function(key) { return [key, object[key]]; }); } /** * The base implementation of `_.unary` without support for storing metadata. * * @private * @param {Function} func The function to cap arguments for. * @returns {Function} Returns the new capped function. */ function baseUnary(func) { return function(value) { return func(value); }; } /** * The base implementation of `_.values` and `_.valuesIn` which creates an * array of `object` property values corresponding to the property names * of `props`. * * @private * @param {Object} object The object to query. * @param {Array} props The property names to get values for. * @returns {Object} Returns the array of property values. */ function baseValues(object, props) { return arrayMap(props, function(key) { return object[key]; }); } /** * Checks if a `cache` value for `key` exists. * * @private * @param {Object} cache The cache to query. * @param {string} key The key of the entry to check. * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`. */ function cacheHas(cache, key) { return cache.has(key); } /** * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol * that is not found in the character symbols. * * @private * @param {Array} strSymbols The string symbols to inspect. * @param {Array} chrSymbols The character symbols to find. * @returns {number} Returns the index of the first unmatched string symbol. */ function charsStartIndex(strSymbols, chrSymbols) { var index = -1, length = strSymbols.length; while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {} return index; } /** * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol * that is not found in the character symbols. * * @private * @param {Array} strSymbols The string symbols to inspect. * @param {Array} chrSymbols The character symbols to find. * @returns {number} Returns the index of the last unmatched string symbol. */ function charsEndIndex(strSymbols, chrSymbols) { var index = strSymbols.length; while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {} return index; } /** * Gets the number of `placeholder` occurrences in `array`. * * @private * @param {Array} array The array to inspect. * @param {*} placeholder The placeholder to search for. * @returns {number} Returns the placeholder count. */ function countHolders(array, placeholder) { var length = array.length, result = 0; while (length--) { if (array[length] === placeholder) { ++result; } } return result; } /** * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A * letters to basic Latin letters. * * @private * @param {string} letter The matched letter to deburr. * @returns {string} Returns the deburred letter. */ var deburrLetter = basePropertyOf(deburredLetters); /** * Used by `_.escape` to convert characters to HTML entities. * * @private * @param {string} chr The matched character to escape. * @returns {string} Returns the escaped character. */ var escapeHtmlChar = basePropertyOf(htmlEscapes); /** * Used by `_.template` to escape characters for inclusion in compiled string literals. * * @private * @param {string} chr The matched character to escape. * @returns {string} Returns the escaped character. */ function escapeStringChar(chr) { return '\\' + stringEscapes[chr]; } /** * Gets the value at `key` of `object`. * * @private * @param {Object} [object] The object to query. * @param {string} key The key of the property to get. * @returns {*} Returns the property value. */ function getValue(object, key) { return object == null ? undefined : object[key]; } /** * Checks if `string` contains Unicode symbols. * * @private * @param {string} string The string to inspect. * @returns {boolean} Returns `true` if a symbol is found, else `false`. */ function hasUnicode(string) { return reHasUnicode.test(string); } /** * Checks if `string` contains a word composed of Unicode symbols. * * @private * @param {string} string The string to inspect. * @returns {boolean} Returns `true` if a word is found, else `false`. */ function hasUnicodeWord(string) { return reHasUnicodeWord.test(string); } /** * Converts `iterator` to an array. * * @private * @param {Object} iterator The iterator to convert. * @returns {Array} Returns the converted array. */ function iteratorToArray(iterator) { var data, result = []; while (!(data = iterator.next()).done) { result.push(data.value); } return result; } /** * Converts `map` to its key-value pairs. * * @private * @param {Object} map The map to convert. * @returns {Array} Returns the key-value pairs. */ function mapToArray(map) { var index = -1, result = Array(map.size); map.forEach(function(value, key) { result[++index] = [key, value]; }); return result; } /** * Creates a unary function that invokes `func` with its argument transformed. * * @private * @param {Function} func The function to wrap. * @param {Function} transform The argument transform. * @returns {Function} Returns the new function. */ function overArg(func, transform) { return function(arg) { return func(transform(arg)); }; } /** * Replaces all `placeholder` elements in `array` with an internal placeholder * and returns an array of their indexes. * * @private * @param {Array} array The array to modify. * @param {*} placeholder The placeholder to replace. * @returns {Array} Returns the new array of placeholder indexes. */ function replaceHolders(array, placeholder) { var index = -1, length = array.length, resIndex = 0, result = []; while (++index < length) { var value = array[index]; if (value === placeholder || value === PLACEHOLDER) { array[index] = PLACEHOLDER; result[resIndex++] = index; } } return result; } /** * Converts `set` to an array of its values. * * @private * @param {Object} set The set to convert. * @returns {Array} Returns the values. */ function setToArray(set) { var index = -1, result = Array(set.size); set.forEach(function(value) { result[++index] = value; }); return result; } /** * Converts `set` to its value-value pairs. * * @private * @param {Object} set The set to convert. * @returns {Array} Returns the value-value pairs. */ function setToPairs(set) { var index = -1, result = Array(set.size); set.forEach(function(value) { result[++index] = [value, value]; }); return result; } /** * A specialized version of `_.indexOf` which performs strict equality * comparisons of values, i.e. `===`. * * @private * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @param {number} fromIndex The index to search from. * @returns {number} Returns the index of the matched value, else `-1`. */ function strictIndexOf(array, value, fromIndex) { var index = fromIndex - 1, length = array.length; while (++index < length) { if (array[index] === value) { return index; } } return -1; } /** * A specialized version of `_.lastIndexOf` which performs strict equality * comparisons of values, i.e. `===`. * * @private * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @param {number} fromIndex The index to search from. * @returns {number} Returns the index of the matched value, else `-1`. */ function strictLastIndexOf(array, value, fromIndex) { var index = fromIndex + 1; while (index--) { if (array[index] === value) { return index; } } return index; } /** * Gets the number of symbols in `string`. * * @private * @param {string} string The string to inspect. * @returns {number} Returns the string size. */ function stringSize(string) { return hasUnicode(string) ? unicodeSize(string) : asciiSize(string); } /** * Converts `string` to an array. * * @private * @param {string} string The string to convert. * @returns {Array} Returns the converted array. */ function stringToArray(string) { return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string); } /** * Used by `_.unescape` to convert HTML entities to characters. * * @private * @param {string} chr The matched character to unescape. * @returns {string} Returns the unescaped character. */ var unescapeHtmlChar = basePropertyOf(htmlUnescapes); /** * Gets the size of a Unicode `string`. * * @private * @param {string} string The string inspect. * @returns {number} Returns the string size. */ function unicodeSize(string) { var result = reUnicode.lastIndex = 0; while (reUnicode.test(string)) { ++result; } return result; } /** * Converts a Unicode `string` to an array. * * @private * @param {string} string The string to convert. * @returns {Array} Returns the converted array. */ function unicodeToArray(string) { return string.match(reUnicode) || []; } /** * Splits a Unicode `string` into an array of its words. * * @private * @param {string} The string to inspect. * @returns {Array} Returns the words of `string`. */ function unicodeWords(string) { return string.match(reUnicodeWord) || []; } /*--------------------------------------------------------------------------*/ /** * Create a new pristine `lodash` function using the `context` object. * * @static * @memberOf _ * @since 1.1.0 * @category Util * @param {Object} [context=root] The context object. * @returns {Function} Returns a new `lodash` function. * @example * * _.mixin({ 'foo': _.constant('foo') }); * * var lodash = _.runInContext(); * lodash.mixin({ 'bar': lodash.constant('bar') }); * * _.isFunction(_.foo); * // => true * _.isFunction(_.bar); * // => false * * lodash.isFunction(lodash.foo); * // => false * lodash.isFunction(lodash.bar); * // => true * * // Create a suped-up `defer` in Node.js. * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer; */ var runInContext = (function runInContext(context) { context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps)); /** Built-in constructor references. */ var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError; /** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype; /** Used to detect overreaching core-js shims. */ var coreJsData = context['__core-js_shared__']; /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString; /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty; /** Used to generate unique IDs. */ var idCounter = 0; /** Used to detect methods masquerading as native. */ var maskSrcKey = (function() { var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || ''); return uid ? ('Symbol(src)_1.' + uid) : ''; }()); /** * Used to resolve the * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring) * of values. */ var nativeObjectToString = objectProto.toString; /** Used to infer the `Object` constructor. */ var objectCtorString = funcToString.call(Object); /** Used to restore the original `_` reference in `_.noConflict`. */ var oldDash = root._; /** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&') .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$' ); /** Built-in value references. */ var Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined; var defineProperty = (function() { try { var func = getNative(Object, 'defineProperty'); func({}, '', {}); return func; } catch (e) {} }()); /** Mocked built-ins. */ var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout; /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse; /* Built-in method references that are verified to be native. */ var DataView = getNative(context, 'DataView'), Map = getNative(context, 'Map'), Promise = getNative(context, 'Promise'), Set = getNative(context, 'Set'), WeakMap = getNative(context, 'WeakMap'), nativeCreate = getNative(Object, 'create'); /** Used to store function metadata. */ var metaMap = WeakMap && new WeakMap; /** Used to lookup unminified function names. */ var realNames = {}; /** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap); /** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined; /*------------------------------------------------------------------------*/ /** * Creates a `lodash` object which wraps `value` to enable implicit method * chain sequences. Methods that operate on and return arrays, collections, * and functions can be chained together. Methods that retrieve a single value * or may return a primitive value will automatically end the chain sequence * and return the unwrapped value. Otherwise, the value must be unwrapped * with `_#value`. * * Explicit chain sequences, which must be unwrapped with `_#value`, may be * enabled using `_.chain`. * * The execution of chained methods is lazy, that is, it's deferred until * `_#value` is implicitly or explicitly called. * * Lazy evaluation allows several methods to support shortcut fusion. * Shortcut fusion is an optimization to merge iteratee calls; this avoids * the creation of intermediate arrays and can greatly reduce the number of * iteratee executions. Sections of a chain sequence qualify for shortcut * fusion if the section is applied to an array and iteratees accept only * one argument. The heuristic for whether a section qualifies for shortcut * fusion is subject to change. * * Chaining is supported in custom builds as long as the `_#value` method is * directly or indirectly included in the build. * * In addition to lodash methods, wrappers have `Array` and `String` methods. * * The wrapper `Array` methods are: * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift` * * The wrapper `String` methods are: * `replace` and `split` * * The wrapper methods that support shortcut fusion are: * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`, * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`, * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray` * * The chainable wrapper methods are: * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`, * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`, * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`, * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`, * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`, * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`, * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`, * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`, * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`, * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`, * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`, * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`, * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`, * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`, * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`, * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`, * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`, * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`, * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`, * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`, * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`, * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`, * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`, * `zipObject`, `zipObjectDeep`, and `zipWith` * * The wrapper methods that are **not** chainable by default are: * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`, * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`, * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`, * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`, * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`, * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`, * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`, * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`, * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`, * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`, * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`, * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`, * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`, * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`, * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`, * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`, * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`, * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`, * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`, * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`, * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`, * `upperFirst`, `value`, and `words` * * @name _ * @constructor * @category Seq * @param {*} value The value to wrap in a `lodash` instance. * @returns {Object} Returns the new `lodash` wrapper instance. * @example * * function square(n) { * return n * n; * } * * var wrapped = _([1, 2, 3]); * * // Returns an unwrapped value. * wrapped.reduce(_.add); * // => 6 * * // Returns a wrapped value. * var squares = wrapped.map(square); * * _.isArray(squares); * // => false * * _.isArray(squares.value()); * // => true */ function lodash(value) { if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) { if (value instanceof LodashWrapper) { return value; } if (hasOwnProperty.call(value, '__wrapped__')) { return wrapperClone(value); } } return new LodashWrapper(value); } /** * The base implementation of `_.create` without support for assigning * properties to the created object. * * @private * @param {Object} proto The object to inherit from. * @returns {Object} Returns the new object. */ var baseCreate = (function() { function object() {} return function(proto) { if (!isObject(proto)) { return {}; } if (objectCreate) { return objectCreate(proto); } object.prototype = proto; var result = new object; object.prototype = undefined; return result; }; }()); /** * The function whose prototype chain sequence wrappers inherit from. * * @private */ function baseLodash() { // No operation performed. } /** * The base constructor for creating `lodash` wrapper objects. * * @private * @param {*} value The value to wrap. * @param {boolean} [chainAll] Enable explicit method chain sequences. */ function LodashWrapper(value, chainAll) { this.__wrapped__ = value; this.__actions__ = []; this.__chain__ = !!chainAll; this.__index__ = 0; this.__values__ = undefined; } /** * By default, the template delimiters used by lodash are like those in * embedded Ruby (ERB) as well as ES2015 template strings. Change the * following template settings to use alternative delimiters. * * @static * @memberOf _ * @type {Object} */ lodash.templateSettings = { /** * Used to detect `data` property values to be HTML-escaped. * * @memberOf _.templateSettings * @type {RegExp} */ 'escape': reEscape, /** * Used to detect code to be evaluated. * * @memberOf _.templateSettings * @type {RegExp} */ 'evaluate': reEvaluate, /** * Used to detect `data` property values to inject. * * @memberOf _.templateSettings * @type {RegExp} */ 'interpolate': reInterpolate, /** * Used to reference the data object in the template text. * * @memberOf _.templateSettings * @type {string} */ 'variable': '', /** * Used to import variables into the compiled template. * * @memberOf _.templateSettings * @type {Object} */ 'imports': { /** * A reference to the `lodash` function. * * @memberOf _.templateSettings.imports * @type {Function} */ '_': lodash } }; // Ensure wrappers are instances of `baseLodash`. lodash.prototype = baseLodash.prototype; lodash.prototype.constructor = lodash; LodashWrapper.prototype = baseCreate(baseLodash.prototype); LodashWrapper.prototype.constructor = LodashWrapper; /*------------------------------------------------------------------------*/ /** * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation. * * @private * @constructor * @param {*} value The value to wrap. */ function LazyWrapper(value) { this.__wrapped__ = value; this.__actions__ = []; this.__dir__ = 1; this.__filtered__ = false; this.__iteratees__ = []; this.__takeCount__ = MAX_ARRAY_LENGTH; this.__views__ = []; } /** * Creates a clone of the lazy wrapper object. * * @private * @name clone * @memberOf LazyWrapper * @returns {Object} Returns the cloned `LazyWrapper` object. */ function lazyClone() { var result = new LazyWrapper(this.__wrapped__); result.__actions__ = copyArray(this.__actions__); result.__dir__ = this.__dir__; result.__filtered__ = this.__filtered__; result.__iteratees__ = copyArray(this.__iteratees__); result.__takeCount__ = this.__takeCount__; result.__views__ = copyArray(this.__views__); return result; } /** * Reverses the direction of lazy iteration. * * @private * @name reverse * @memberOf LazyWrapper * @returns {Object} Returns the new reversed `LazyWrapper` object. */ function lazyReverse() { if (this.__filtered__) { var result = new LazyWrapper(this); result.__dir__ = -1; result.__filtered__ = true; } else { result = this.clone(); result.__dir__ *= -1; } return result; } /** * Extracts the unwrapped value from its lazy wrapper. * * @private * @name value * @memberOf LazyWrapper * @returns {*} Returns the unwrapped value. */ function lazyValue() { var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : (start - 1), iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__); if (!isArr || (!isRight && arrLength == length && takeCount == length)) { return baseWrapperValue(array, this.__actions__); } var result = []; outer: while (length-- && resIndex < takeCount) { index += dir; var iterIndex = -1, value = array[index]; while (++iterIndex < iterLength) { var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value); if (type == LAZY_MAP_FLAG) { value = computed; } else if (!computed) { if (type == LAZY_FILTER_FLAG) { continue outer; } else { break outer; } } } result[resIndex++] = value; } return result; } // Ensure `LazyWrapper` is an instance of `baseLodash`. LazyWrapper.prototype = baseCreate(baseLodash.prototype); LazyWrapper.prototype.constructor = LazyWrapper; /*------------------------------------------------------------------------*/ /** * Creates a hash object. * * @private * @constructor * @param {Array} [entries] The key-value pairs to cache. */ function Hash(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index < length) { var entry = entries[index]; this.set(entry[0], entry[1]); } } /** * Removes all key-value entries from the hash. * * @private * @name clear * @memberOf Hash */ function hashClear() { this.__data__ = nativeCreate ? nativeCreate(null) : {}; this.size = 0; } /** * Removes `key` and its value from the hash. * * @private * @name delete * @memberOf Hash * @param {Object} hash The hash to modify. * @param {string} key The key of the value to remove. * @returns {boolean} Returns `true` if the entry was removed, else `false`. */ function hashDelete(key) { var result = this.has(key) && delete this.__data__[key]; this.size -= result ? 1 : 0; return result; } /** * Gets the hash value for `key`. * * @private * @name get * @memberOf Hash * @param {string} key The key of the value to get. * @returns {*} Returns the entry value. */ function hashGet(key) { var data = this.__data__; if (nativeCreate) { var result = data[key]; return result === HASH_UNDEFINED ? undefined : result; } return hasOwnProperty.call(data, key) ? data[key] : undefined; } /** * Checks if a hash value for `key` exists. * * @private * @name has * @memberOf Hash * @param {string} key The key of the entry to check. * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`. */ function hashHas(key) { var data = this.__data__; return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key); } /** * Sets the hash `key` to `value`. * * @private * @name set * @memberOf Hash * @param {string} key The key of the value to set. * @param {*} value The value to set. * @returns {Object} Returns the hash instance. */ function hashSet(key, value) { var data = this.__data__; this.size += this.has(key) ? 0 : 1; data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value; return this; } // Add methods to `Hash`. Hash.prototype.clear = hashClear; Hash.prototype['delete'] = hashDelete; Hash.prototype.get = hashGet; Hash.prototype.has = hashHas; Hash.prototype.set = hashSet; /*------------------------------------------------------------------------*/ /** * Creates an list cache object. * * @private * @constructor * @param {Array} [entries] The key-value pairs to cache. */ function ListCache(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index < length) { var entry = entries[index]; this.set(entry[0], entry[1]); } } /** * Removes all key-value entries from the list cache. * * @private * @name clear * @memberOf ListCache */ function listCacheClear() { this.__data__ = []; this.size = 0; } /** * Removes `key` and its value from the list cache. * * @private * @name delete * @memberOf ListCache * @param {string} key The key of the value to remove. * @returns {boolean} Returns `true` if the entry was removed, else `false`. */ function listCacheDelete(key) { var data = this.__data__, index = assocIndexOf(data, key); if (index < 0) { return false; } var lastIndex = data.length - 1; if (index == lastIndex) { data.pop(); } else { splice.call(data, index, 1); } --this.size; return true; } /** * Gets the list cache value for `key`. * * @private * @name get * @memberOf ListCache * @param {string} key The key of the value to get. * @returns {*} Returns the entry value. */ function listCacheGet(key) { var data = this.__data__, index = assocIndexOf(data, key); return index < 0 ? undefined : data[index][1]; } /** * Checks if a list cache value for `key` exists. * * @private * @name has * @memberOf ListCache * @param {string} key The key of the entry to check. * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`. */ function listCacheHas(key) { return assocIndexOf(this.__data__, key) > -1; } /** * Sets the list cache `key` to `value`. * * @private * @name set * @memberOf ListCache * @param {string} key The key of the value to set. * @param {*} value The value to set. * @returns {Object} Returns the list cache instance. */ function listCacheSet(key, value) { var data = this.__data__, index = assocIndexOf(data, key); if (index < 0) { ++this.size; data.push([key, value]); } else { data[index][1] = value; } return this; } // Add methods to `ListCache`. ListCache.prototype.clear = listCacheClear; ListCache.prototype['delete'] = listCacheDelete; ListCache.prototype.get = listCacheGet; ListCache.prototype.has = listCacheHas; ListCache.prototype.set = listCacheSet; /*------------------------------------------------------------------------*/ /** * Creates a map cache object to store key-value pairs. * * @private * @constructor * @param {Array} [entries] The key-value pairs to cache. */ function MapCache(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index < length) { var entry = entries[index]; this.set(entry[0], entry[1]); } } /** * Removes all key-value entries from the map. * * @private * @name clear * @memberOf MapCache */ function mapCacheClear() { this.size = 0; this.__data__ = { 'hash': new Hash, 'map': new (Map || ListCache), 'string': new Hash }; } /** * Removes `key` and its value from the map. * * @private * @name delete * @memberOf MapCache * @param {string} key The key of the value to remove. * @returns {boolean} Returns `true` if the entry was removed, else `false`. */ function mapCacheDelete(key) { var result = getMapData(this, key)['delete'](key); this.size -= result ? 1 : 0; return result; } /** * Gets the map value for `key`. * * @private * @name get * @memberOf MapCache * @param {string} key The key of the value to get. * @returns {*} Returns the entry value. */ function mapCacheGet(key) { return getMapData(this, key).get(key); } /** * Checks if a map value for `key` exists. * * @private * @name has * @memberOf MapCache * @param {string} key The key of the entry to check. * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`. */ function mapCacheHas(key) { return getMapData(this, key).has(key); } /** * Sets the map `key` to `value`. * * @private * @name set * @memberOf MapCache * @param {string} key The key of the value to set. * @param {*} value The value to set. * @returns {Object} Returns the map cache instance. */ function mapCacheSet(key, value) { var data = getMapData(this, key), size = data.size; data.set(key, value); this.size += data.size == size ? 0 : 1; return this; } // Add methods to `MapCache`. MapCache.prototype.clear = mapCacheClear; MapCache.prototype['delete'] = mapCacheDelete; MapCache.prototype.get = mapCacheGet; MapCache.prototype.has = mapCacheHas; MapCache.prototype.set = mapCacheSet; /*------------------------------------------------------------------------*/ /** * * Creates an array cache object to store unique values. * * @private * @constructor * @param {Array} [values] The values to cache. */ function SetCache(values) { var index = -1, length = values == null ? 0 : values.length; this.__data__ = new MapCache; while (++index < length) { this.add(values[index]); } } /** * Adds `value` to the array cache. * * @private * @name add * @memberOf SetCache * @alias push * @param {*} value The value to cache. * @returns {Object} Returns the cache instance. */ function setCacheAdd(value) { this.__data__.set(value, HASH_UNDEFINED); return this; } /** * Checks if `value` is in the array cache. * * @private * @name has * @memberOf SetCache * @param {*} value The value to search for. * @returns {number} Returns `true` if `value` is found, else `false`. */ function setCacheHas(value) { return this.__data__.has(value); } // Add methods to `SetCache`. SetCache.prototype.add = SetCache.prototype.push = setCacheAdd; SetCache.prototype.has = setCacheHas; /*------------------------------------------------------------------------*/ /** * Creates a stack cache object to store key-value pairs. * * @private * @constructor * @param {Array} [entries] The key-value pairs to cache. */ function Stack(entries) { var data = this.__data__ = new ListCache(entries); this.size = data.size; } /** * Removes all key-value entries from the stack. * * @private * @name clear * @memberOf Stack */ function stackClear() { this.__data__ = new ListCache; this.size = 0; } /** * Removes `key` and its value from the stack. * * @private * @name delete * @memberOf Stack * @param {string} key The key of the value to remove. * @returns {boolean} Returns `true` if the entry was removed, else `false`. */ function stackDelete(key) { var data = this.__data__, result = data['delete'](key); this.size = data.size; return result; } /** * Gets the stack value for `key`. * * @private * @name get * @memberOf Stack * @param {string} key The key of the value to get. * @returns {*} Returns the entry value. */ function stackGet(key) { return this.__data__.get(key); } /** * Checks if a stack value for `key` exists. * * @private * @name has * @memberOf Stack * @param {string} key The key of the entry to check. * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`. */ function stackHas(key) { return this.__data__.has(key); } /** * Sets the stack `key` to `value`. * * @private * @name set * @memberOf Stack * @param {string} key The key of the value to set. * @param {*} value The value to set. * @returns {Object} Returns the stack cache instance. */ function stackSet(key, value) { var data = this.__data__; if (data instanceof ListCache) { var pairs = data.__data__; if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) { pairs.push([key, value]); this.size = ++data.size; return this; } data = this.__data__ = new MapCache(pairs); } data.set(key, value); this.size = data.size; return this; } // Add methods to `Stack`. Stack.prototype.clear = stackClear; Stack.prototype['delete'] = stackDelete; Stack.prototype.get = stackGet; Stack.prototype.has = stackHas; Stack.prototype.set = stackSet; /*------------------------------------------------------------------------*/ /** * Creates an array of the enumerable property names of the array-like `value`. * * @private * @param {*} value The value to query. * @param {boolean} inherited Specify returning inherited property names. * @returns {Array} Returns the array of property names. */ function arrayLikeKeys(value, inherited) { var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length; for (var key in value) { if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode. key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers. (isBuff && (key == 'offset' || key == 'parent')) || // PhantomJS 2 has enumerable non-index properties on typed arrays. (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) || // Skip index properties. isIndex(key, length) ))) { result.push(key); } } return result; } /** * A specialized version of `_.sample` for arrays. * * @private * @param {Array} array The array to sample. * @returns {*} Returns the random element. */ function arraySample(array) { var length = array.length; return length ? array[baseRandom(0, length - 1)] : undefined; } /** * A specialized version of `_.sampleSize` for arrays. * * @private * @param {Array} array The array to sample. * @param {number} n The number of elements to sample. * @returns {Array} Returns the random elements. */ function arraySampleSize(array, n) { return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length)); } /** * A specialized version of `_.shuffle` for arrays. * * @private * @param {Array} array The array to shuffle. * @returns {Array} Returns the new shuffled array. */ function arrayShuffle(array) { return shuffleSelf(copyArray(array)); } /** * This function is like `assignValue` except that it doesn't assign * `undefined` values. * * @private * @param {Object} object The object to modify. * @param {string} key The key of the property to assign. * @param {*} value The value to assign. */ function assignMergeValue(object, key, value) { if ((value !== undefined && !eq(object[key], value)) || (value === undefined && !(key in object))) { baseAssignValue(object, key, value); } } /** * Assigns `value` to `key` of `object` if the existing value is not equivalent * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. * * @private * @param {Object} object The object to modify. * @param {string} key The key of the property to assign. * @param {*} value The value to assign. */ function assignValue(object, key, value) { var objValue = object[key]; if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || (value === undefined && !(key in object))) { baseAssignValue(object, key, value); } } /** * Gets the index at which the `key` is found in `array` of key-value pairs. * * @private * @param {Array} array The array to inspect. * @param {*} key The key to search for. * @returns {number} Returns the index of the matched value, else `-1`. */ function assocIndexOf(array, key) { var length = array.length; while (length--) { if (eq(array[length][0], key)) { return length; } } return -1; } /** * Aggregates elements of `collection` on `accumulator` with keys transformed * by `iteratee` and values set by `setter`. * * @private * @param {Array|Object} collection The collection to iterate over. * @param {Function} setter The function to set `accumulator` values. * @param {Function} iteratee The iteratee